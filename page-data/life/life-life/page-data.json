{"componentChunkName":"component---src-templates-blogs-blog-post-jsx","path":"/life/life-life","result":{"data":{"markdownRemark":{"html":"<p>Live each day to the fullest. Get the most from each hour, each day and for each age of your life. Then you can look forward with confidence and back without regrets. Be yourself, but be your best self. Dare to be different and to follow your start and don't be afraid to be happy.</p>\n<p>Enjoy what is beautiful. Love withh all your heart and soul. Believe that those whom you love, love you.\nForget what you have done for your friends and remember what they have done for your. Disregard what the world owes you and concentrate on what you owe the world.</p>\n<p>When you are faced with a decision, make that decision as wisely as possible - then forget about it. The moment of absoulte certainty never arrives. Above all, remember that God helps those who help themselts. Act as if everything depended on you and pray as if everything dependend on God.</p>\n<p><em>Author unknown</em></p>","frontmatter":{"title":"Live Life!","subtitle":"live life to the fullest","date":"May, 07, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":null,"thumbnail":null,"teaser":null,"credit":null,"creditlink":null},"path":"/life/life-life","tags":["Live","Love","Laugh","Life"],"excerpt":"live life to the fullest"}}},"pageContext":{"prev":{"html":"<p>Memoization ensures that a function doesn't run for the same inputs more than once by keeping a record of the results for given inputs (usually in a dictionary).</p>\n<p>For example, a simple recursive function for computing the n<sup>th</sup> fibonacci number:</p>\n<pre><code class=\"language-python\">def fib_recursive(n):\n    if n &#x3C; 0:\n        raise IndexError('Index was negative. No such thing as a negative index in a series.')\n\n    # base cases\n    if n in [0, 1]:\n        return n\n\n    print \"computing fib_recursive(%i)\" % n\n    return fib_recursive(n - 1) + fib_recursive(n - 2)\n</code></pre>\n<p>This will run the same input a couple of times</p>\n<pre><code class=\"language-bash\">>>> fib_recursive(8)\ncomputing fib_recursive(8)\ncomputing fib_recursive(7)\ncomputing fib_recursive(6)\ncomputing fib_recursive(5)\ncomputing fib_recursive(4)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(2)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(4)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(2)\ncomputing fib_recursive(5)\ncomputing fib_recursive(4)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(2)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(6)\ncomputing fib_recursive(5)\ncomputing fib_recursive(4)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(2)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(4)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(2)\n21\n</code></pre>\n<p>We can imagine the recursive calls of this function as a tree, where the two children of a node are the two recursive calls it makes. We can see that the tree quickly branches out of control:</p>\n<p><img src=\"https://www.interviewcake.com/images/svgs/fibonacci__binary_tree_recursive.svg?bust=145\"></p>\n<p>To avoid the duplicate work caused by the branching, we can wrap the function in a class that stores an instance variable, memo, that maps inputs to outputs. Then we simply:</p>\n<ol>\n<li>Check memo to see if we can avoid computing the answer for any given input, and</li>\n<li>Save the results of any calculations to memo.</li>\n</ol>\n<pre><code class=\"language-python\">class Fibber:\n    def __init__(self):\n        self.memo = {}\n\n    def fib(self, n):\n\n        if n &#x3C; 0:\n            raise Exception(\"Index was negative. No such thing as a negative index in a series.\")\n\n        # base cases\n        elif n in [0, 1]:\n            return n\n\n        # see if we've already calculated this\n        if n in self.memo:\n            print \"grabbing memo[%i]\" % n\n            return self.memo[n]\n\n        print \"computing fib(%i)\" % n\n        result = self.fib(n - 1) + self.fib(n - 2)\n\n        # memoize\n        self.memo[n] = result\n\n        return result\n</code></pre>\n<p>We save a bunch of calls by checking the memo:</p>\n<pre><code class=\"language-python\">>>> Fibber().fib(8)\ncomputing fib(8)\ncomputing fib(7)\ncomputing fib(6)\ncomputing fib(5)\ncomputing fib(4)\ncomputing fib(3)\ncomputing fib(2)\ngrabbing memo[2]\ngrabbing memo[3]\ngrabbing memo[4]\ngrabbing memo[5]\ngrabbing memo[6]\n21\n</code></pre>\n<p>Now in our recurrence tree, no node appears more than twice:</p>\n<p><img src=\"https://www.interviewcake.com/images/svgs/fibonacci__binary_tree_memoized.svg?bust=145\"></p>\n<p>Memoization is a common strategy for dynamic programming problems, which are problems where the solution is composed of solutions to the same problem with smaller inputs (as with the fibonacci problem, above). The other common strategy for dynamic programming problems is going bottom-up, which is usually cleaner and often more efficient.</p>","id":"d909b4b2-5b5f-5ea1-8202-b09de00a5bea","timeToRead":2,"frontmatter":{"title":"Concept of Memoize","subtitle":"A gentle introduction to memoize","excerpt":"Memoization ensures that a function doesn't run for the same inputs more than once by keeping a record of the results for given inputs (usually in a dictionary).","path":"/tech/memoize-python","category":"tech","date":"May 17, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":null,"thumbnail":"memoize.png","teaser":"memoize.png","credit":null,"creditlink":null},"tags":["data-structures","python","algorithms","memoize"],"published":true}},"next":{"html":"<p>Academic excellence is overrated! There I said it. Being top of your class does not necessarily guarantee that you will be at the top of life. You could graduate as the best student in finace but it doesn't mean you will make more money thatn everybody else. The best graduating law student does not necessarily make the best lawyer.</p>\n<p>The fact is life requires more than the ability to understand a concept, memoriese it and reproduce it in an exam. School rewards people for their memory, Life rewards people for their imagination.</p>\n<p>School rewards caution, while life rewards daring.\nSchool hails those who live by the rules, byt life exalts those who break the rules and set new ones.</p>\n<p>So, do I mean people should not study hard in school? Oh no! By all means you should. However, don't sacrifice every other thing on the alter of first class.</p>\n<p>Do not limit yourself to the classrorm. Do something practical. Take a leadership position. Start a business and fail. That is a better Entrepreneurship 101.</p>\n<p>Join or start a club. Contest and election and lose. It will teach you something Polition Science 101 will not teach you. Attend a seminar. Read books outside the scope of your corse. Go on missions and win a soul for eternal rewards...Do something you believe in!</p>\n<p>Think less of becoming an excellent student but think more of becoming an excellent person. Make the world your classroom.</p>\n<p>Don't you ever allow the level of education you have become your prision.</p>\n<p>Make the world your classroom! Have an amazing week ahead.</p>","id":"39a2931a-762d-5456-90c1-a4ecb9c8132f","timeToRead":1,"frontmatter":{"title":"Of education and academics","subtitle":"Academia and education","excerpt":"Academia and education","path":"/life/education-and-academics","category":"life","date":"May 06, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":null,"thumbnail":null,"teaser":null,"credit":null,"creditlink":null},"tags":["eduction","academics","life"],"published":true}}}}}