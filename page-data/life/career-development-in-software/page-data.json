{"componentChunkName":"component---src-templates-blogs-blog-post-jsx","path":"/life/career-development-in-software","result":{"data":{"markdownRemark":{"html":"<p>Software development the world of technology is constantly shifting &#x26; changing. No 2 years are ever the same. New technologies are developed, old ones are improved and ideologies are challenged every single day. With this kind of climate, it is often difficult for any engineer to navigate without at some point hitting a wall or 2. Oftentimes developers struggle to find a true north to stick to due to the constant change in the tides &#x26; new upcoming trends that often leave everyone wondering if what they have been learning for the past year is worth it anymore.</p>\n<p>Truth is, we have all been here &#x26; I would bet that any engineer who claims has not had any struggles understanding and surfing this wave of <em>technological change</em> has not truly been working in this industry as they claim they have. A little context is necessary.</p>\n<p><a href=\"https://golang.org/\">Golang</a> is now a very popular programming language &#x26; is used almost everywhere &#x26; is the go to programming language for cloud computing(which by the way now runs the world as it is), but it is just slightly 10 years old. No one saw this shift happening. It is not only popular for cloud, but it is being used everywhere now, even <a href=\"https://www.zdnet.com/article/what-is-the-internet-of-things-everything-you-need-to-know-about-the-iot-right-now/\">IoT</a> devices &#x26; in distributed systems because of how the language was built. 10 years ago, no one would have even thought that a language could change the very ideology of how people build software. This speaks to the fact that the tech world will always shift &#x26; there will be something 10 years from now that will be used to power the next generation of computing.</p>\n<p>With this in mind, a lot of new developers always struggle to find a balance between being relevant &#x26; learning something that will set them apart for years to come. This is due to the fact that there is a lot of <em>noise</em> in the industry with new buzzwords &#x26; terminologies that could confuse anyone &#x26; everyone. But if you look closely, they are not really new. Most of these new technologies are just old technologies that have been re-branded to fit in the current fast moving world. It is because back in the 80s &#x26; 70s, there was no supporting hardware or technology for what we have now to exist. But, the ideas were there, we just could not execute them.</p>\n<p>Now, why would I sort of digress like this? This is to just highlight that it is fundamental to learn the basics of software development &#x26; by that I mean good practices of building modern day technologies with an allowance for it to improve &#x26; be built upon. This is agnostic to any programming language, framework, tool or cloud technology. This is the very building block of software development. In this day &#x26; age we get caught up in the latest front-end framework someone knows to the most recent cutting edge back-end development a company is using to the hosting solution we are adopting to run all these applications to the point that we forget to just build good software. At the end of the day, all these are tools, but let me emphasise, <em>it is important to pick the right tools for the job</em>. No carpenter will pick a screw driver to hammer in a nail, when it is obvious that a hammer will be perfect for the job. That is why there are many options in software development &#x26; herein lies the beauty of it &#x26; the confusion at the same time.</p>\n<p>Now as a recently fresh graduate of any coding boot-camp or any school that teaches software development it is quite common to have a lot of questions about the industry. Especially how to navigate it. You will come out with certain skill sets, but the reality of it is they will never be enough for the industry as it is right now. It is at this point that you realise you need to go far &#x26; beyond &#x26; build on top of what you know &#x26; this needs, no, <em>has</em> to be a constant endeavour.</p>\n<p>Growing your career as a software developer is a constant effort &#x26; will require discipline &#x26; this goes for any career out there. You have to put in the work to constantly improve on your skills (both non-technical &#x26; technical). There is simply no shortcut, you just have to work at it. Some of the things you can do are:</p>\n<ul>\n<li>\n<p><em>Attend conferences and webinars</em>(at this time due to the Covid-19 pandemic, this is very possible to attend conferences that you possibly never could due to either distance or financial constraints)</p>\n<p>This gives you a wider view of how the current industry is shaped &#x26; allows you to adapt to it &#x26; learn new things &#x26; see what gaps you have in your knowledge base</p>\n</li>\n<li><em>Network with your peers</em>. It is important to network with people &#x26; learn from them. You will not be able to learn everything there is to learn in the world. This is where networking comes in. Speaking to other developers gives you insights into what else you can do with your knowledge base. Stuck with a bug? How about you reach out to a friend before reaching for Google? You never know. They could have literally solved the same issue a few minutes prior.</li>\n<li><em>Read, read &#x26; read</em>. This is key for me. I suppose because a lot of times some developers do not take the time to actually dive into documentation provided in tools or programming languages that they are using &#x26; just immediately dive into Stack Overflow &#x26; even though SO is a great tool. Chances are you just did not read the fine print in the documentation. Also adding on top of that, take the time to read some software engineering books &#x26; articles. This will give you even more insights into the software world.</li>\n<li>Find a mentor who will act as a guide for you. This will help as they will warn you of any missteps &#x26; encourage you on decisions that you may be hesitant to make. I think it is important to highlight that it is not the mentor's responsibility to be checking up on you all the time. It is up to you to communicate what progress you have been making in your growth &#x26; assistance you may need. This is an initiative that you have to make.</li>\n<li><em>Join a software community &#x26; be part of discussions</em> &#x26; ask silly questions if you have to &#x26; no, I am not talking about Stack Overflow(in as much as it is a community). I am talking about a software development community in your region or even globally. There are a lot of ways to do so(Slack, Telegram, Github, Discord, Reddit, etc). These communities are vibrant &#x26; always have interesting discussions on topics that you can learn from.</li>\n<li><em>Collaborate on a software project or product</em>. Key word being <em>collaborate</em>. This is because no great software is built by one person a lone. This is the new way of working. This is how big players in the industry are building new technologies &#x26; tools. They are being built by people &#x26; there is no exclusion on who can work on what. This is especially key in open source technologies. They are built by communities &#x26; for the communities. You being able to work on a software project along with other developers, helps a lot in your growth as a software developer &#x26; shows that you can work in a team.</li>\n</ul>\n<p>As you can tell, the things that I have mentioned above have not catered or talked about technical skill at all, but this is not to say that technical skills aren't important. They very much are! But, these go hand in hand with them. The reason for highlighting these, is that a lot times, developers ignore these things or never look out for them, because they do not regard them as important, thinking that they do not matter.</p>\n<p>On a technical level, it is important to first know your programming language like the back of your hand. Be able to read it like you would read any English(or your mother tongue) text. Be able to interpret it to a point you can explain to anyone else in a very concise &#x26; simple way. Yes, this takes time &#x26; practice, a lot of it. But it is important that you do this. The reason for this, is that at the end of the day, you will be writing code &#x26; if you can't understand your own code, how else do you expect the machine to understand what you want it to do?</p>\n<p>There are many other technical skills you need to have &#x26; these speak a lot to the key competencies that a lot of employers &#x26; companies look for in software developers. I am about to sound like every Job Description(JD) out there, but really, they are key &#x26; organisations do not take the time to write them down for nothing. These speak to the values they seek in candidates:</p>\n<ul>\n<li><em>Know your stack &#x26; know it well</em>. If you say you are a back-end developer or choose the path of a front-end developer or mobile developer, it is important that you know your technologies &#x26; tools well. These tools should not sound very new to you when they are mentioned. Especially during an interview. It would really hurt your chances, when a certain technology or tool is mentioned &#x26; you are oblivious about it yet it should be part of your toolbox. There are certain tools that you expect to find in a tool-shed of any carpenter. Now imagine going to a carpenter, asking him to make a bed for you or any article of furniture &#x26; you realise he does not have certain tools(say, a hammer, screw driver, saw, you name it) &#x26; when you ask him/her about it, they are completely confused by what you are saying. Would you still hire them for the job?</li>\n<li><em>Be an advocate for testing</em> &#x26; I am not talking about manual testing where you run on <em>localhost</em> &#x26; then say you are good to go. I am talking about automated testing, being able to test your code fully. This means understanding that bugs don't crop up out of nowhere, they crop up from not catching edge cases that could have been caught by a simple unit test.</li>\n<li><em>Know about certain paradigms or processes that are common in software development, especially in this day &#x26; age</em>. An example is Continuous Integration &#x26; Continuous Deployment abbreviated as CI/CD. This is very common in this new age of software development &#x26; there are a lot of tools that aid in this paradigm &#x26; as a software developer it is important to know them &#x26; be able to use them. Almost every organisation has adapted to using CI/CD patterns following the advent of Agile practices, as it is a faster way to deliver software to people that benefit people &#x26; the business at large. As an engineer you need to know how to use these tools &#x26; fit them into your workflow. This means being able to know what is needed to build, package &#x26; distribute your application to the masses. Think of your piece of software like processed food. You have to find a way for it to continuously be shipped out to the market for people to consume or they die(not literal in this case, but I hope you get the gist of it).</li>\n</ul>\n<p>Of course this is not an exhaustive list &#x26; with how the software world keeps evolving there are a lot more things that you need to be aware of &#x26; learn.</p>\n<p>I could go on with more letters &#x26; words describing all you need to grow in this career, but the truth is, there is just a lot of things happening in this industry to fit them all in 1 article. I am sure by the time you are done reading this, there will be a new JS library ready for use (:D), that is just how quickly the industry is moving &#x26; shifting these days &#x26; as an individual it is important to know where you are, what you have, then to know what you need to go &#x26; what you need to get there &#x26; then just work on it constantly with zeal &#x26; passion.</p>\n<p>So, what does it take to build &#x26; have a successful career in software development? I would say first humility, then discipline.</p>","frontmatter":{"title":"Tools to a Successful Career in Software Development","subtitle":"Growing a career in software development","date":"May, 21, 2020","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"tools-to-career-development-in-software.jpg","thumbnail":null,"teaser":"tools-to-career-development-in-software.jpg","credit":"Unsplash","creditlink":"https://unsplash.com/photos/IClZBVw5W5A"},"path":"/life/career-development-in-software","tags":["Education","Software","Technology","Life"],"excerpt":"Growing a successful career in software development is not easy & involves a lot hurdles with ups and downs & a little surfing if you are up for it. The point is, it is not a walk in the park & always requires constant reinventint of oneself. Here is my take on it."}}},"pageContext":{"prev":null,"next":{"html":"<p>Chaos is often depicted as negative and literally means \"complete disorder and confusion\". What if we can use this complete lack of organization in our production environment to bring stability and confidence in our systems and completely change the meaning of chaos? Let us explore the possible ways in which we can get harmony from chaos engineering.</p>\n<p>So, if chaos is a lack of organization, complete disfunction and confusion &#x26; engineering is about precision &#x26; using scientific principles to design and build machines, structures, tools and other items. How do these 2 principles exactly come together to bring harmony through chaos engineering?</p>\n<p>First of all, let's start with a bit of a history lesson. Chaos engineering was initially thought of by Greg Orzell in 2011 while Netflix was moving to the cloud. His intent was to move from a development model that assumed zero downtimes and breakdowns to  a model where such breakdowns were inevitable. This stemmed from the fact that during development we often assume the best case scenerios where no breakdowns happen or we control how they happen and can immediately fix these issues. However, that is not the case in the real world as we all know breakdowns could happen at any time. His intention was to drive engineers to consider resilience as an obligation rather than an option.</p>\n<p>In order to achieve this, Neflix came up with a tool known as  <em>Chaos Monkey</em> whose purpose was to randomly choose servers in a production environment and turn them off during business hours. Of course this is a very unpopular opinion and not many would attempt to do this in their production environment that actively serves customers.</p>\n<blockquote>\n<p>\"Imagine a monkey entering a \"data center\", these \"farms\" of servers that host all the critical functions of our online activities. The monkey randomly rips cables, destroys devices and returns everything that passes by the hand [i.e. flings excrement]. The challenge for IT managers is to design the information system they are responsible for so that it can work despite these monkeys, which no one ever knows when they arrive and what they will destroy.\"</p>\n</blockquote>\n<p>In practice this is how chaos engineering can be achieved:</p>\n<p><img src=\"/images/posts/chaos-engineering-flow.png\" alt=\"chaos-engineering-flow\"></p>\n<p>The harder it is to disrupt the steady state, the more confident we are the system can withstand random breakdowns. If a weakness is uncovered, we now have a target for improvement before that behavior manifests in the system at large.</p>\n<h2>Build  a hypothesis around steady state behaviour</h2>\n<p> Focus on the measurable output of a system instead of the internal attributes. By focusing on systemic behavior patterns during experiments, Chaos verifies that the system does work, rather than trying to validate how it works.</p>\n<h2>Vary Real world events</h2>\n<p>Chaos variables reflect real-world events. Prioritize events either by potential impact or estimated frequency. Consider events that correspond to hardware failures like servers dying, software failures like malformed responses, and non-failure events like a spike in traffic or a scaling event. Any event capable of disrupting steady state is a potential variable in a Chaos experiment.</p>\n<h2>Run experiments in production</h2>\n<p>Systems behave differently depending on environment and traffic patterns. Since the behavior of utilization can change at any time, sampling real traffic is the only way to reliably capture the request path. To guarantee both authenticity of the way in which the system is exercised and relevance to the current deployed system, Chaos strongly prefers to experiment directly on production traffic.</p>\n<h2>Automate Experiments to run continuously</h2>\n<p>Running experiments manually is labor-intensive and ultimately unsustainable. Automate experiments and run them continuously. Chaos Engineering builds automation into the system to drive both orchestration and analysis.</p>\n<h2>Minimize the blast radius</h2>\n<p>Experimenting in production has the potential to cause unnecessary customer pain. While there must be an allowance for some short-term negative impact, it is the responsibility and obligation of the Chaos Engineer to ensure the fallout from experiments are minimized and contained.</p>\n<h3>Limitations</h3>\n<p>Despite the buzz and the hype around chaos engineering, there are some drawbacks to it:</p>\n<ol>\n<li>\n<p><strong>Means to an end</strong>.</p>\n<p>It's important to note that it is a <em>means to an end and not an end in itself</em> . What matters most is the production service that is provided at the end. Whatever findings that you discover from perform chaos engineering from your system, must be fed back to the system - in terms of fixing bugs, training people - otherwise it will count as a waste of time.</p>\n</li>\n<li>\n<p><strong>One step forward two steps back</strong></p>\n<p>Who’s to say that being able to uncover weaknesses will automatically lead to positive outcomes, like improved customer experience? As software developers know, identifying a bug and fixing it are two different challenges. Indeed, your optimization efforts in one area might increase brittleness in other areas.</p>\n</li>\n<li>\n<p><strong>One among many</strong></p>\n<p>  Chaos Engineering is not a remedy for all of your reliability concerns, and it never will be. It’s merely one of many approaches used to gain confidence in system correctness (typically in the face of perturbation). Consider it required but not sufficient. And by no means is it – or should it be – the only way to learn from failure.</p>\n</li>\n<li>\n<p><strong>Systems will continue to fail</strong></p>\n<p>  It may sound overly pessimistic, but while Chaos Engineering surely is a net plus, impermanence makes sure that all complex systems will fail no matter how hard we try to avoid it (which is exactly why postmortems are so important). The Holy Grail of Automation – introducing faults automatically instead of manually – won’t change that fact a bit. Don’t fool yourself and set realistic expectations.</p>\n</li>\n<li>\n<p><strong>No Rollback button</strong></p>\n<p>  The rollback button is a lie. That’s not only true for application deployments but also for fault injection, as both face the same fundamental problem: state. Yes, you might be able to revert the direct impact of non-destructive faults, which can be as simple as stopping to generate CPU/memory/disk load or deleting traffic rules created to simulate network conditions. But no, you can’t roll back what has been inflicted on everything else in the system – the targeted application and everything that interacts with it. A prime example is corrupt or incorrect data stored in a database/queue/cache due to a program crash.</p>\n</li>\n</ol>\n<h2>Conclusion</h2>\n<p>This is but a brief introduction about chaos engineering, to just showcase that this is a new paradigm and shift into how products are now built at scale and to ensure that the end user always has the best esperience despite the system experiencing heavy storms. I would recommend using chaos engineering as an everyday tool to ensure that whatever you build will always work at scale and work consistently. Of course this is not everyone's cup of tea and that is acceptable. At certain levels of scale, this just becomes a pain to setup and get to work properly. Remember, the ultimate goal is to bring the best experience to the customer and measuer the overal output of your product and not how it works internally.</p>\n<p>With that I shall leave you with a quote.</p>\n<blockquote>\n<p>But behind all the beauty lies madness and chaos.</p>\n</blockquote>","id":"54fb72cb-10cf-5707-81b0-377f619c67a2","timeToRead":5,"frontmatter":{"title":"Harmony in Chaos Engineering","subtitle":"Making chaos work for you at scale","excerpt":"Chaos is often depicted as negative and literally means \"complete disorder and confusion\". What if we can use this complete lack of organization in our production environment to bring stability and confidence in our systems and completely change the meaning of chaos? Let us explore the possible ways in which we can get harmony from chaos engineering.","path":"/tech/chaos-engineering","category":"tech","date":"October 13, 2019","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"chaos-engineering.jpeg","thumbnail":"chaos-engineering.jpeg","teaser":"chaos-engineering.jpeg","credit":null,"creditlink":null},"tags":["Engineering","Chaos","Testing"],"published":true}}}}}