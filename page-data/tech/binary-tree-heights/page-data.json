{"componentChunkName":"component---src-templates-blogs-blog-post-jsx","path":"/tech/binary-tree-heights","result":{"data":{"markdownRemark":{"html":"<p>A binary tree is a tree where every node has two or fewer children. The children are usually called left and right.</p>\n<pre><code class=\"language-python\">class BinaryTreeNode(object):\n\n    def __init__(self, value):\n        self.value = value\n        self.left  = None\n        self.right = None\n</code></pre>\n<p>This lets us build a structure like this:</p>\n<p><img src=\"https://www.interviewcake.com/images/svgs/binary_tree__depth_5.svg?bust=145\"></p>\n<blockquote>\n<p>A tree represented by cirlces connected with lines.</p>\n</blockquote>\n<p>The root node is on top, and connects to 2 children below it. Each of those children connect to 2 children below them, which all connect to their own 2 children, which all connect to their own 2 children.</p>\n<p>That particular example is special because every level of the tree is completely full. There are no \"gaps.\" We call this kind of tree \"perfect.\"</p>\n<p>Binary trees have a few interesting properties when they're perfect:</p>\n<ol>\n<li><strong>Property 1: the number of total nodes on each \"level\" doubles as we move down the tree.</strong></li>\n</ol>\n<p><img src=\"https://www.interviewcake.com/images/svgs/binary_tree__depth_5_with_number_of_nodes_labelled.svg?bust=145\"></p>\n<p>A binary tree with 5 rows of nodes. The root node is on top, and every node has 2 children in the row below. Each row is labelled with the number of nodes in the row, which doubles from the top down: 1, 2, 4, 8, 16.</p>\n<ol start=\"2\">\n<li><strong>Property 2: the number of nodes on the last level is equal to the sum of the number of nodes on all other levels (plus 1).</strong></li>\n</ol>\n<p>In other words, about half of our nodes are on the last level.</p>\n<p>Let's call the number of nodes <strong>n</strong>, and the height of the tree <strong>h</strong>. <strong>h</strong> can also be thought of as the \"number of levels.\"</p>\n<p>If we had <em>h</em>, how could we calculate <em>n</em>?</p>\n<p>Let's just add up the number of nodes on each level! How many nodes are on each level?</p>\n<p>If we zero-index the levels, the number of nodes on the <em>x<sup>th</sup></em> level is exactly 2<sup>x</sup></p>\n<ol>\n<li>Level 0: 2<sup>0</sup> nodes,</li>\n<li>Level 1: 2<sup>1</sup> nodes,</li>\n<li>Level 2: 2<sup>2</sup> nodes,</li>\n<li>Level 3: 2<sup>3</sup> nodes,</li>\n<li>etc</li>\n</ol>\n<p>So our total number of nodes is:</p>\n<p>n = 2<sup>0</sup> + 2<sup>1</sup> + 2<sup>2</sup> + 2<sup>3</sup> + ... + 2<sup>{h-1}</sup></p>\n<blockquote>\n<p>Why only up to 2<sup>{h-1}</sup>? Notice that we started counting our levels at 0. So if we have h levels in total, the last level is actually the \"h-1\"-th level. That means the number of nodes on the last level is 2<sup>{h-1}</sup>.</p>\n</blockquote>\n<p>But we can simplify. <em>Property 2</em> tells us that the number of nodes on the last level is (1 more than) half of the total number of nodes, so we can just take the number of nodes on the last level, multiply it by 2, and subtract 1 to get the number of nodes overall. We know the number of nodes on the last level is 2<sup>h-1</sup>, So:</p>\n<pre>\nn = 2<sup>h-1</sup> * 2 - 1\n\nn = 2<sup>h-1</sup> * 2 - 1\n\nn = 2<sup>h-1</sup> * 2^1 - 1\n\nn = 2<sup>h-1+1</sup>- 1\n\nn = 2<sup>h</sup> - 1\n</pre>\n<p>So that's how we can go from h to n. What about the other direction?</p>\n<p>We need to bring the h down from the exponent. That's what logs are for!</p>\n<p>First, some quick review. log<sub>10</sub>(100) simply means, <strong>What power must you raise 10 to in order to get 100?</strong>. Which is 2, because 10<sup>2</sup> = 100</p>\n<p>We can use logs in algebra to bring variables down from exponents by exploiting the fact that we can simplify log<sub>10</sub>(10<sup>2</sup>)</p>\n<p>What power must we raise 10 to in order to get 10<sup>2</sup>? That's easyâ€”it's 2.</p>\n<p>So in this case we can take the log<sub>2</sub> of both sides:</p>\n<pre>\nn = 2<sup>h</sup> - 1\nn + 1 = 2<sup>h</sup>\nlog<sub>2</sub>((n+1)) = log<sub>2</sub>(2<sup>h</sup>)\nlog<sub>2</sub>(n+1) = h\n</pre>\n<p>So that's the relationship between height and total nodes in a perfect binary tree.</p>","frontmatter":{"title":"Binary Trees Heights","subtitle":"Relationship between a binary tree's height and its number of nodes","date":"May, 17, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":null,"thumbnail":"binary_tree_depth.svg","teaser":"binary_tree_depth.svg","credit":null,"creditlink":null},"path":"/tech/binary-tree-heights","tags":["data-structures","binary-tree"],"excerpt":"A binary tree is a tree where every node has two or fewer children. The children are usually called left and right."}}},"pageContext":{"prev":{"html":"<p>Going bottom-up is a way to avoid recursion, saving the memory cost that recursion incurs when it builds up the call stack.</p>\n<p>Put simply, a bottom-up algorithm \"starts from the beginning,\" while a recursive algorithm often \"starts from the end and works backwards.\"</p>\n<p>For example, if we wanted to multiply all the numbers in the range 1...n1...n, we could use this cute, top-down, recursive one-liner:</p>\n<pre><code class=\"language-python\">def product_1_to_n(n):\n    # we assume n >= 1\n    return n * product_1_to_n(n-1) if n > 1 else 1\n</code></pre>\n<p>This approach has a problem: it builds up a call stack of size O(n)O(n), which makes our total memory cost O(n)O(n). This makes it vulnerable to a stack overflow error, where the call stack gets too big and runs out of space.</p>\n<p>To avoid this, we can instead go bottom-up:</p>\n<pre><code class=\"language-python\">def product_1_to_n(n):\n    # we assume n >= 1\n\n    result = 1\n    for num in range(1, n+1):\n        result *= num\n\n    return result\n</code></pre>\n<p>This approach uses O(1)O(1) space (O(n)O(n) time).</p>\n<blockquote>\n<p>Some compilers and interpreters will do what's called tail call optimization (TCO), where it can optimize some recursive functions to avoid building up a tall call stack. Python and Java decidedly do not use TCO. Some Ruby implementations do, but most don't. Some C implementations do, and the JavaScript spec recently allowed TCO. Scheme is one of the few languages that guarantee TCO in all implementations. In general, best not to assume your compiler/interpreter will do this work for you.</p>\n</blockquote>\n<p>Going bottom-up is a common strategy for dynamic programming problems, which are problems where the solution is composed of solutions to the same problem with smaller inputs (as with the fibonacci problem, above). The other common strategy for dynamic programming problems is memoization.</p>","id":"2c0a734e-0b99-5fea-bb33-2bd2df9d99ce","timeToRead":1,"frontmatter":{"title":"Bottom up algorithms","subtitle":"A short description on bottom up algorithms","excerpt":"Going bottom-up is a way to avoid recursion, saving the memory cost that recursion incurs when it builds up the call stack.","path":"/tech/bottom-up-algorithms","category":"tech","date":"May 18, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":null,"thumbnail":"bottom-up.png","teaser":"bottom-up.png","credit":null,"creditlink":null},"tags":["data-structures","algorithms"],"published":true}},"next":{"html":"<p>Memoization ensures that a function doesn't run for the same inputs more than once by keeping a record of the results for given inputs (usually in a dictionary).</p>\n<p>For example, a simple recursive function for computing the n<sup>th</sup> fibonacci number:</p>\n<pre><code class=\"language-python\">def fib_recursive(n):\n    if n &#x3C; 0:\n        raise IndexError('Index was negative. No such thing as a negative index in a series.')\n\n    # base cases\n    if n in [0, 1]:\n        return n\n\n    print \"computing fib_recursive(%i)\" % n\n    return fib_recursive(n - 1) + fib_recursive(n - 2)\n</code></pre>\n<p>This will run the same input a couple of times</p>\n<pre><code class=\"language-bash\">>>> fib_recursive(8)\ncomputing fib_recursive(8)\ncomputing fib_recursive(7)\ncomputing fib_recursive(6)\ncomputing fib_recursive(5)\ncomputing fib_recursive(4)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(2)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(4)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(2)\ncomputing fib_recursive(5)\ncomputing fib_recursive(4)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(2)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(6)\ncomputing fib_recursive(5)\ncomputing fib_recursive(4)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(2)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(4)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(2)\n21\n</code></pre>\n<p>We can imagine the recursive calls of this function as a tree, where the two children of a node are the two recursive calls it makes. We can see that the tree quickly branches out of control:</p>\n<p><img src=\"https://www.interviewcake.com/images/svgs/fibonacci__binary_tree_recursive.svg?bust=145\"></p>\n<p>To avoid the duplicate work caused by the branching, we can wrap the function in a class that stores an instance variable, memo, that maps inputs to outputs. Then we simply:</p>\n<ol>\n<li>Check memo to see if we can avoid computing the answer for any given input, and</li>\n<li>Save the results of any calculations to memo.</li>\n</ol>\n<pre><code class=\"language-python\">class Fibber:\n    def __init__(self):\n        self.memo = {}\n\n    def fib(self, n):\n\n        if n &#x3C; 0:\n            raise Exception(\"Index was negative. No such thing as a negative index in a series.\")\n\n        # base cases\n        elif n in [0, 1]:\n            return n\n\n        # see if we've already calculated this\n        if n in self.memo:\n            print \"grabbing memo[%i]\" % n\n            return self.memo[n]\n\n        print \"computing fib(%i)\" % n\n        result = self.fib(n - 1) + self.fib(n - 2)\n\n        # memoize\n        self.memo[n] = result\n\n        return result\n</code></pre>\n<p>We save a bunch of calls by checking the memo:</p>\n<pre><code class=\"language-python\">>>> Fibber().fib(8)\ncomputing fib(8)\ncomputing fib(7)\ncomputing fib(6)\ncomputing fib(5)\ncomputing fib(4)\ncomputing fib(3)\ncomputing fib(2)\ngrabbing memo[2]\ngrabbing memo[3]\ngrabbing memo[4]\ngrabbing memo[5]\ngrabbing memo[6]\n21\n</code></pre>\n<p>Now in our recurrence tree, no node appears more than twice:</p>\n<p><img src=\"https://www.interviewcake.com/images/svgs/fibonacci__binary_tree_memoized.svg?bust=145\"></p>\n<p>Memoization is a common strategy for dynamic programming problems, which are problems where the solution is composed of solutions to the same problem with smaller inputs (as with the fibonacci problem, above). The other common strategy for dynamic programming problems is going bottom-up, which is usually cleaner and often more efficient.</p>","id":"d909b4b2-5b5f-5ea1-8202-b09de00a5bea","timeToRead":2,"frontmatter":{"title":"Concept of Memoize","subtitle":"A gentle introduction to memoize","excerpt":"Memoization ensures that a function doesn't run for the same inputs more than once by keeping a record of the results for given inputs (usually in a dictionary).","path":"/tech/memoize-python","category":"tech","date":"May 17, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":null,"thumbnail":"memoize.png","teaser":"memoize.png","credit":null,"creditlink":null},"tags":["data-structures","python","algorithms","memoize"],"published":true}}}}}