{"componentChunkName":"component---src-templates-blogs-blog-post-jsx","path":"/tech/sorting-algorithms","result":{"data":{"markdownRemark":{"html":"<p>Algorithms are set to achieve a certain outcome. Sorting algoritms follow numerical order and usually has random access to an array. This means that it can access random indexes of an array to perform a sort.</p>\n<h1>Bubble Sort</h1>\n<p>Convinient for small data sets. Consider an array of elements such that:\nint[] arr = new int[]{14,33,27,10,33,19,42,44};\nThe array is not sorted. To sort this array, we compare 2 values at a time.\nSteps:</p>\n<ul>\n<li>compare 14 and 33, since 14 is less than 33, it remains in place</li>\n<li>next we compare 33 and 27, 27 is less than 33, hence we have to swap postions such that;\n<code>arr[1]</code> = 33 takes the place of <code>arr[2]</code> and vice versa.\nThe array now becomes:\n{14,27,33,10,33,19,48,44}</li>\n<li>The next comparison is now between 33 and 10. 10 is less than 33, so we swap positions as before.</li>\n<li>The process continues until all the elements in the array follow natural ordering.</li>\n</ul>\n<p>This is obviously convenient for small data sets as we are comparing 2 elements at a time. If the array was of length 50, it would take much longer to complete and would be inefficient. This is not what an ideal algorithm should achieve.</p>\n<pre><code class=\"language-java\">    /**\n     * @implNote\n     * set flag to true to begin first pass, initialize the step variable, create the temp variable\n     * within while loop, set the flag to false awaiting first pass\n     * record the steps taken in a variable called steps\n     * holds the temp value for the current element in array\n     * assign the current position of the array to the next element\n     * assign the next position of the array to the temp value\n     * set the flag to true to allow continuing of loop, record the steps taken\n     * @param toSort array to perform the bubble sort\n     * @return toSort the sorted array\n     * */\n    public static int[] bubbly(int[] toSort){\n        boolean flag = true;\n        int steps = 0;\n        int temp;\n        while(flag){\n            flag = false;\n            for(int x = 0; x &#x3C; toSort.length-1;x++){\n                if(toSort[x] > toSort[x+1]){\n                    steps++;\n                    temp = toSort[x];\n                    toSort[x] = toSort[x+1];\n                    toSort[x+1] = temp;\n                    flag = true;\n                }\n\n            }\n        }\n        System.out.println(String.valueOf(steps)+ \" steps taken\");\n        return toSort;\n    }\n\n    public static void main(String[] args){\n        int[] arr = new int[]{18,29,1,100,17};\n        int[] arrTwo = new int[]{100,16,33,48,60,21,80};\n        /*Bubble sort Ascending*/\n        System.out.println(Arrays.toString(bubbly(arr)));\n        System.out.println(Arrays.toString(bubbly(arrTwo)));\n        /*5 steps taken\n        [1, 17, 18, 29, 100]\n        9 steps taken\n        [16, 21, 33, 48, 60, 80, 100]*/\n    }\n</code></pre>\n<blockquote>\n<p>Demonstration of a bubble sort algorithm, sorting elements in ascending order</p>\n</blockquote>\n<p>Code snippet right <a href=\"https://github.com/BrianLusina/Java-Playground/blob/master/Toy%20Problems/src/SortingAlgorithms/BubbleSortDemo.java\">here</a>.</p>\n<h1>Merge Sort</h1>\n<p>Uses the <em>divide and conquer rule</em> it divides a problem into smaller parts until it reaches the simplest form possible. Then it rejoins the divided elements in a sorted format until it is a full list again. This sorting algorithm is mostly used in arrays.</p>\n<p>Consider this example\n27 10 12 25 34 16 15 31\ndivide it into two parts\n27 10 12 25 34 16 15 31\ndivide each part into two parts\n27 10 12 25 34 16 15 31\ndivide each part into two parts\n27 10 12 25 34 16 15 31</p>\n<p>merge (cleverly-!) parts</p>\n<p>10 27 12 25 16 34 15 31\nmerge parts\n10 12 25 27 15 16 31 34\nmerge parts into one\n10 12 15 16 25 27 31 34</p>\n<h1>Insertion Sort</h1>","frontmatter":{"title":"Sorting Algorithms","subtitle":"Brief overview of some sorting algorithms","date":"July, 12, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"sorting-algorithms.png","thumbnail":"sorting-algorithms.png","teaser":"sorting-algorithms.png","credit":null,"creditlink":null},"path":"/tech/sorting-algorithms","tags":["algorithms","sorting algorithms","array"],"excerpt":"Algorithms are set to achieve a certain outcome. Sorting algoritms follow numerical order and usually has random access to an array. This means that it can access random indexes of an array to perform a sort."}}},"pageContext":{"prev":{"html":"<p>There are several Abstract data types that are used in Java,</p>\n<h2>Stacks</h2>\n<p>The Stack class represents a last-in-first-out (LIFO) stack of objects, The last element in will be the first one out, which is unfair if you ask me :smile:. It extends class <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/Vector.html\"><strong>Vector</strong></a> with five operations that allow a vector to be treated as a stack.</p>\n<p>The usual push and pop operations are provided, as well as a method to peek at the top item on the stack, a method to test for whether the stack is empty, and a method to search the stack for an item and discover how far it is from the top.</p>\n<p>When a stack is first created, it contains no items.</p>\n<ul>\n<li><strong>push</strong> adds an item to the top of the stack. This will always be the last one in, but the first one out.</li>\n<li><strong>pop</strong> removes an element from the top of the stack and returns it.</li>\n<li><strong>peek</strong> look at the object at the top of the stack without removing it</li>\n<li><strong>empty</strong> tests if the stack is empty</li>\n<li><strong>search</strong> if the object being sought is in the stack, it returns the 1-based position of the object, which is the distance from the top.</li>\n</ul>\n<p>A practical example, trays piled on top of each other, books laid on top of each other, plates laid on top of each other.</p>\n<p>There is no scenerio in which the stack will remain empty. There will always be data flowing in and data flowing out.</p>\n<p>A code snippet:</p>\n<pre><code class=\"language-java\">public class StacksDemo {\n    public static void main(String[] args){\n        Stack stack = new Stack();\n        System.out.println(\"Stack is \" + stack);\n        showPush(stack,52);\n        showPop(stack);\n        /*output:\n        *Stack is []\n        * push 52\n        * Stack is now: [52]\n        * Popped element is 52\n        * Stack is: []\n        * */\n    }\n\n    /**Method showing how to push elements into a stack*/\n    public static void showPush(Stack stack, int a){\n        stack.push(new Integer(a));\n        System.out.println(\"push \" + String.valueOf(a));\n        System.out.println(\"Stack is now: \"+ stack );\n    }\n\n    /**Method demonstrating the use of pop*/\n    public static void showPop(Stack stack){\n        Integer integer = (Integer) stack.pop();\n        System.out.println(\"Popped element is \" + String.valueOf(integer));\n        System.out.println(\"Stack is: \"+ stack);\n    }\n/*Class end*/\n}\n</code></pre>\n<blockquote>\n<p>code snippet can be found <a href=\"https://github.com/BrianLusina/Java-Playground/blob/master/Toy%20Problems/src/DataStructures/DataTypes/StacksDemo.java\">here</a></p>\n</blockquote>\n<h2>Queue</h2>\n<p>Resembles a normal queue on a bus station, the first in line will be the first one to board the bus, the last will obviously be the last. It is based on a first come first serve\nHas 2 major operations:</p>\n<ul>\n<li>Dequeue</li>\n<li>-</li>\n</ul>\n<h2>LinkedLists</h2>\n<p>Data arranged in a list with the first element being the <strong>head</strong> having the node and a pointer. The pointer points to another node and so on and so forth until it reaches the last element with a node that is null. The last element is known as the <strong>tail</strong>\nThe node consists of where the current data is held and where the next data is held.</p>","id":"dbcc8de6-0a00-59d3-8023-fda0563bdd20","timeToRead":2,"frontmatter":{"title":"Abstract Data Types","subtitle":"All about abstract data types","excerpt":"There are several Abstract data types that are used in Java, this is a brief overview of some of them","path":"/tech/abstract-data-types","category":"tech","date":"July 12, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"abstract-data-type.jpg","thumbnail":"abstract-data-type.jpg","teaser":"abstract-data-type.jpg","credit":null,"creditlink":null},"tags":["data","arrays","lists","stacks","queues"],"published":true}},"next":{"html":"<p>Abstraction is one of the principles of Object Oriented Programming where a programmer hides/reduces information of an object and only reveals the relevant information at the time. It works alongside <em>inheritance</em> and <em>encapsulation</em>. This is done in order to reduce complexity and ensure efficiency.</p>\n<p>In the process of abstraction, the programmer tries to ensure that the entity is named in a manner that will make sense and that it will have all the relevant aspects included and none of the extraneous ones.</p>\n<p>A practical example is a car. Not many people are concerned with the inner workings of a motor vehicle, save for mechanics, engineers and car enthusiasts. A car is an object that has certail states and behaviours. It has states such as <em>black</em> paint, <em>engine size</em> and <em>number of doors</em> etc. The behaviours are <em>accelerate</em>, <em>decelerate</em> and <em>stop</em>, just to mention a few. Now, for the driver to intaract with the car, they have to do so through the steering wheel, the gears and the peddles. These are the <strong>interfaces</strong>.</p>\n<p>These are what act as a go-between the driver and the internal components of the car. This is where abstraction steps in. The driver does not particularly know what is going on in the engine when they accelerate and when they stop. All they get to interact with are the steering wheel, pedals and various gauges on the car dashboard. Abstraction basically gives them this relevant information as it is what is needed at the time of driving. All the driver needs to know at all times when they are driving are the fuel gauge, the speed they are on and car temperature. They do not need to know about how the car measures heat every second or how it gauges how much petrol is left in the tank or even how it calculates the current speed. This information is hidden in the internal components of the car (<em>encapsulation</em>) and is queried (say, you take your car apart and study it) only when need be. So at all times only relevant information is displayed(<em>abstraction</em>).</p>\n<p>This, as you can see, reduces the complexity when driving said car and allows the driver to only intaract with what they need to interact with at the time of driving.</p>","id":"1606581a-36ff-54f6-af72-59bed280fe9d","timeToRead":2,"frontmatter":{"title":"A Practical example of Abstraction","subtitle":"A more practical approach to abstraction in OOP","excerpt":"Abstraction in the real world.","path":"/tech/abstraction","category":"tech","date":"July 11, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"abstraction.jpg","thumbnail":"abstraction.jpg","teaser":"abstraction.jpg","credit":null,"creditlink":null},"tags":["encapsulation","objects","object oriented programming","abstraction"],"published":true}}}}}