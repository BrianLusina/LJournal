{"componentChunkName":"component---src-templates-blogs-blog-post-jsx","path":"/tech/ci-with-android","result":{"data":{"markdownRemark":{"html":"<p>Continuous Integration has become an essential part of any software project in recent times. With how fast technology keeps changing and how quickly libraries and dependencies get re-written, it becomes essential for your application code to be maintained, tested and delivered to users quickly and efficiently. This will usually involve you re-writing some old code, testing your new feature and then deploying to users for them to enjoy your new feature in your application.</p>\n<p>Obviously this is not usually easy in Android development as the ecosystem is vast and development can be sometimes slow, especially when you have to deal with recompiling and rebuilding a project every time there is a change you have made to your code (honestly, do not like this part of the job). The even bigger challenge comes when you have to create a release, sign it and manually deploy it on PlayStore. This process becomes even more tedious!</p>\n<p>The good thing is there are many Continuous Integration and Deployment providers that take away the manual process of things and make it more automatic, so that you only deal with the writing of code and they deal with the deployment of the product.</p>\n<p>You will find a lot of these tools used for web projects, OS images servers, but not so much for mobile applications, yet the delivery is more or less the same. Luckily these same tools can be used to deploy your mobile applications and today you shall learn how.</p>\n<h3>A couple of things</h3>\n<p>There are a couple of things that I need to mention before I proceed.</p>\n<p>First, the examples I shall use will be referencing <a href=\"https://circleci.com/\">CircleCI</a>, but does not mean that they can only be used with CircleCI, any CI provider will do the trick.</p>\n<p>Secondly, I assume that you already have a test setup for you Android application and also an Android application you are working on.</p>\n<p>Third, I also assume that you have a PlayStore developer account where you will deploy your application.</p>\n<p>Whether you have these setup or not, the following will prove to be helpful for you down the line.</p>\n<h3>Getting started and setting up.</h3>\n<p>Assuming you already have a working Android project with which you need to automate the boring stuff of testing and deployment, there are a couple of things you will need to have to make the process even smoother.</p>\n<ol>\n<li><strong>Gradle properties file</strong></li>\n</ol>\n<p>Think of this as a file you, your team and your CI should only know about. This is normally labelled as <code>gradle.properties</code> file and contains API keys, Secret Keys and Base URls that your application uses when communicating with a service provider.</p>\n<p>This file should not be checked into a VCS(Github, Gitlab, Bitbucket, etc) as you do not want to expose these secret keys to the public. But if they are not checked into a VCS, then how will your CI know how to build your application properly?</p>\n<pre><code class=\"language-properties\">DEV_API_BASE_URL=&#x3C;YOUR_DEV_BASE_URL>\nAPI_BASE_URL=&#x3C;YOUR_BASE_URL>\nAPI_KEY=&#x3C;YOUR_API_KEY>\nGITHUB_TOKEN=&#x3C;YOUR_GITHUB_TOKEN>\nSERVICE_ACCOUNT_EMAIL=&#x3C;YOUR_SERVICE_ACCOUNT_EMAIL>\nVERSION_NAME=1.0.0\nVERSION_CODE=1\nRELEASE_TRACK=beta\n</code></pre>\n<blockquote>\n<p>A typical generic <code>gradle.properties</code> file with secret keys and what not.</p>\n</blockquote>\n<p>These configurations assume you have such values in your application. The only values that will really be essential to your build environment are <code>VERSION_CODE</code>, <code>VERSION_NAME</code> and <code>RELEASE_TRACK</code>.</p>\n<p>Version code and name are used as unique identifiers for your application when deploying on playstore while release track is used to identify which track your current release will be published on(either beta, alpha or production).</p>\n<p>I prefer setting the track to beta, so as to enable the current release to be first pushed to beta testers before it is upgraded to production. Also beta track is what I use when building from <code>develop</code> or <code>staging</code> branch, which ensures that the master branch will only be used for <code>production</code> releases.</p>\n<p>Here is how we can generate the <code>RELEASE_TRACK</code> value dynamically:</p>\n<pre><code class=\"language-properties\">/**\n * Gets the release track to use for deployment\n * Release tracks are either \"alpha\", \"beta\", \"production\", \"rollout\"\n * */\ndef getReleaseTrack = { ->\n    try{\n        Properties properties = new Properties()\n        properties.load(new FileInputStream(\"gradle.properties\"))\n        return Integer.parseInt(properties.getProperty(\"RELEASE_TRACK\"))\n    }catch (ignored){\n        return \"alpha\"\n    }\n}\n</code></pre>\n<blockquote>\n<p>This will get the release track from the properties file and if it can not get that from the file, then the default is alpha release track. This ensure that we do not touch the production/rollout tracks and leave that up to the CI to handle when the build and tests succeeds.</p>\n</blockquote>\n<p>And to even make it more dynamic we can create a shell script that the CI handles before building the application</p>\n<pre><code class=\"language-bash\"># updates the version code based on the current branch\nfunction updateVersionCodeAndTrack(){\n    versionCode=$(git rev-list --first-parent --count origin/${CIRCLE_BRANCH})\n    versionName=$(git describe --dirty)\n\n#    if [\"${versionName}\" == \"fatal: No names found, cannot describe anything.\"]; then\n#        major=$(expr ${CIRCLE_BUILD_NUM} - ${CIRCLE_PREVIOUS_BUILD_NUM})\n#        versionName=${major}.0.0\n#    fi\n\n    if [\"${versionName}\" == \"fatal: No names found, cannot describe anything.\"]; then\n        versionName=1.0.0\n    fi\n\n    if [ \"${CIRCLE_BRANCH}\" == \"develop\" ]; then\n        echo \"VERSION_NAME=${versionName}\" >> ${GRADLE_PROPERTIES}\n        echo \"VERSION_CODE=${versionCode}\" >> ${GRADLE_PROPERTIES}\n        echo \"RELEASE_TRACK=\\\"beta\\\"\" >> ${GRADLE_PROPERTIES}\n\n    elif [ \"${CIRCLE_BRANCH}\" == \"master\" ] ; then\n        echo \"VERSION_NAME=${versionName}\" >> ${GRADLE_PROPERTIES}\n        echo \"VERSION_CODE=${versionCode}\" >> ${GRADLE_PROPERTIES}\n        echo \"RELEASE_TRACK=\\\"production\\\"\" >> ${GRADLE_PROPERTIES}\n    fi\n}\n</code></pre>\n<blockquote>\n<p>As you can see, the release track is updated according to the branch the CI is running on. ${GRADLE_PROPERTIES} is simply the location of the <code>gradle.properties</code> file.</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>KeyStore</strong></li>\n</ol>\n<p>Android applications have to be signed in order for PlayStore to accept your release APK. This is a simple file (with a .jks extension) that authenticates your application with PlayStore. It is a MUST have when creating releases, otherwise PlayStore will not let your application into the <em>Pearly Gates</em> that is Google PlayStore.</p>\n<p>To create a KeyStore file, simply follow instructions outlined <a href=\"https://developer.android.com/studio/publish/app-signing.html#generate-key\">here</a> and when you are done, come back here with your new shiny keystore file and we can proceed.</p>\n<p>Once you have your File in place, we can now automate the signing of the application easily.</p>\n<p>This file is not pushed to Github and as such means that your CI has be be aware of its <code>existence</code> and build your application as you would locally. but how would it go about this process?</p>\n<p>We start off by creating a <code>keystore.properties</code> file. The contents of this will are simple.</p>\n<pre><code class=\"language-properties\">keyAlias=&#x3C;KEY_ALIAS>\nkeyPassword=&#x3C;KEY_PASSWORD>\nstoreFile=&#x3C;STORE_FILE>\nstorePassword=&#x3C;STORE_PASSWORD>\n</code></pre>\n<blockquote>\n<p>keystore.properties file contents, note the &#x3C;> brackets are where you place your values you used when creating your keystore file.</p>\n</blockquote>\n<p>This file can be placed anywhere in your project tree, but, I advice placing this file at the root of your project tree for easier retrieval.</p>\n<p><em>NB: This file is not pushed to Github</em> as it contains your sensitive information for creating your keystore file.</p>\n<p>Once that is in place we can now update your project level <code>build.gradle</code> file. This will be found at the root of your project tree. The update we make will be used to extract information from your <code>keystore.properties</code> file and be used to sign your application</p>\n<pre><code class=\"language-properties\">/**\n * Get version code from git history\n * This will dynamically increase the version code\n * If it fails to get from git, it will get it from the properties file, ensure that there is a properties\n * file at root of project\n * */\ndef getVersionCode = { ->\n    try{\n        def stdout = new ByteArrayOutputStream()\n        exec {\n            commandLine \"git\", \"rev-list\", \"--first-parent\", \"--count\", \"origin/master\"\n            standardOutput = stdout\n        }\n        Random random = new Random()\n\n        // this ensures that the version code remains unique for every build\n        def number = random.nextInt(10) + random.nextInt(5) * random.nextInt(7) + random.nextInt(4)\n        return Integer.parseInt(stdout.toString().trim()) + number\n    }catch (ignored){\n        Properties properties = new Properties()\n        properties.load(new FileInputStream(\"gradle.properties\"))\n        return Integer.parseInt(properties.getProperty(\"VERSION_CODE\"))\n    }\n}\n\n/**\n * Get version name will ensure that the version name of the application remains unique and ever changing\n * for easier tracking. This will pull the information from git\n * */\ndef getVersionName = { ->\n    try {\n        def stdout = new ByteArrayOutputStream()\n        exec {\n            commandLine \"git\", \"describe\" \"--dirty\"\n            standardOutput = stdout\n        }\n        return stdout.toString().trim()\n    }catch (ignored){\n        Properties properties = new Properties()\n        properties.load(new FileInputStream(\"gradle.properties\"))\n        return properties.getProperty(\"VERSION_NAME\")\n    }\n}\n\n\n/**\n * Gets the  service account email gradle.properties file, Ensure that you have a\n * gradle.properties file in root project directory\n * */\ndef getServiceAccountKey = { ->\n    try {\n        Properties properties = new Properties()\n        properties.load(new FileInputStream(\"gradle.properties\"))\n        return properties.getProperty(\"SERVICE_ACCOUNT_EMAIL\")\n    } catch (Exception ignored) {\n        return \"\"\n    }\n}\n\next {\n    // configurations to send to Play Store for automated publishing\n    pk12KeyFile = rootProject.file(\"keystores/moja_publish_key.p12\")\n    pJsonKeyFile = rootProject.file(\"keystores/moja_publish_key.json\")\n    serviceAccountEmail = getServiceAccountKey()\n\n    debugKeystorePropertiesFile = rootProject.file(\"keystores/debug.keystore.properties\")\n    debugKeystoreProperties = new Properties()\n    debugKeystoreProperties.load(new FileInputStream(ext.debugKeystorePropertiesFile))\n\n    keystorePropertiesFile = rootProject.file(\"keystores/keystore.properties\")\n    keystoreProperties = new Properties()\n    keystoreProperties.load(new FileInputStream(ext.keystorePropertiesFile))\n\n    // ...........\n}\n</code></pre>\n<blockquote>\n<p>A section of project level <code>build.gradle</code> file</p>\n</blockquote>\n<p>A couple of new things you have probably noticed.</p>\n<ul>\n<li><strong>getVersionCode</strong> function</li>\n</ul>\n<p>This, as the name suggests, builds a version code number for your application. This makes sure that you do not have to manually update it every single time you want to upload a new release of your application to PlayStore.</p>\n<p>Let us have a look at it again:</p>\n<pre><code class=\"language-properties\">/**\n * Get version code from git history\n * This will dynamically increase the version\n code\n * If it fails to get from git, it will get it from the properties file, ensure that there is a properties\n * file at root of project\n * */\ndef getVersionCode = { ->\n    try{\n        def stdout = new ByteArrayOutputStream()\n        exec {\n            commandLine \"git\", \"rev-list\", \"--first-parent\", \"--count\", \"origin/master\"\n            standardOutput = stdout\n        }\n        Random random = new Random()\n\n        // this ensures that the version code remains unique for every build\n        def number = random.nextInt(10) + random.nextInt(5) * random.nextInt(7) + random.nextInt(4)\n        return Integer.parseInt(stdout.toString().trim()) + number\n    }catch (ignored){\n        Properties properties = new Properties()\n        properties.load(new FileInputStream(\"gradle.properties\"))\n        return Integer.parseInt(properties.getProperty(\"VERSION_CODE\"))\n    }\n}\n</code></pre>\n<blockquote>\n<p>This randomizes the version code to ensure that it is unique on every build. This removes the pain point of having to update the version code every single time.</p>\n</blockquote>\n<ul>\n<li><strong>getVersionName</strong> function</li>\n</ul>\n<p>This is used to get the version name, nothing fancy about this, but what is unique about it is how it gets the version name.</p>\n<pre><code class=\"language-properties\">/**\n * Get version name will ensure that the version name of the application remains unique and ever changing\n * for easier tracking. This will pull the information from git\n * */\ndef getVersionName = { ->\n    try {\n        def stdout = new ByteArrayOutputStream()\n        exec {\n            commandLine \"git\", \"describe\" \"--dirty\"\n            standardOutput = stdout\n        }\n        return stdout.toString().trim()\n    }catch (ignored){\n        Properties properties = new Properties()\n        properties.load(new FileInputStream(\"gradle.properties\"))\n        return properties.getProperty(\"VERSION_NAME\")\n    }\n}\n</code></pre>\n<blockquote>\n<p>This will get the version name from the tags you have pushed to Github. Check <a href=\"https://git-scm.com/book/en/v2/Git-Basics-Tagging\">here</a> for how to create tags on Github. This will then build a unique version name for you to use when identifying to users the version they are downloading or updating.</p>\n</blockquote>\n<ul>\n<li><strong>getServiceAccountKey</strong> Function</li>\n</ul>\n<pre><code class=\"language-properties\">/**\n * Gets the service account email gradle.properties file, Ensure that you have a\n * gradle.properties file in root project directory\n * */\ndef getServiceAccountKey = { ->\n    try {\n        Properties properties = new Properties()\n        properties.load(new FileInputStream(\"gradle.properties\"))\n        return properties.getProperty(\"SERVICE_ACCOUNT_EMAIL\")\n    } catch (Exception ignored) {\n        return \"\"\n    }\n}\n</code></pre>\n<blockquote>\n<p>This gets the service account email that you will have to create on Google Play Services account to enable automated deployment of your application. Check <a href=\"https://github.com/codepath/android_guides/wiki/Automating-Publishing-to-the-Play-Store\">here</a> for more information on that</p>\n</blockquote>\n<p>Once that is setup, we add the following lines in your <code>app</code> module <code>build.gradle</code> file:</p>\n<pre><code class=\"language-gradle\">android {\n\n  // other configuration ....\n    signingConfigs {\n        release {\n            keyAlias rootProject.ext.keystoreProperties['keyAlias']\n            keyPassword rootProject.ext.keystoreProperties['keyPassword']\n            storeFile rootProject.file(rootProject.ext.keystoreProperties['storeFile'])\n            storePassword rootProject.ext.keystoreProperties['storePassword']\n        }\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled true\n            shrinkResources true\n            debuggable false\n            zipAlignEnabled true\n            signingConfig signingConfigs.release\n            //proguardFiles 'proguard-android-optimize.txt', getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n\n        debug {\n            debuggable true\n            minifyEnabled false\n            applicationIdSuffix \".debug\"\n            testCoverageEnabled true\n        }\n    }\n</code></pre>\n<blockquote>\n<p>Notice the <code>rootProject.ext.&#x3C;VALUE>.</code>\nThis is referencing the values we set in the ext block in our gradle.properties file at the root\nlevel of the project.\nThis will be used to setup the signing of the apk when creating a release build.</p>\n</blockquote>\n<ol start=\"3\">\n<li><strong>Github Triplet Plugin</strong></li>\n</ol>\n<p>This plugin automates the deplyoment to PlayStore when CI tests pass. This includes release notes, screenshots, whats new section, version name, icons etc.\nOne caveat is that you will have to manually upload the APK to PlayStore the first time, but after that this plugin will handle the automation so that all you have to do is focus on the code and features you create. More on this plugin can be found <a href=\"https://github.com/Triple-T/gradle-play-publisher\">here</a>. This includes setup and how to use it. I advice you read through it and understand before proceeding.</p>\n<h3>CI configuration</h3>\n<p>Once we have all this configured, we can then configure Circle CI config file to automate the process. This will run the build, test the application and deploy to PlayStore based on your configuration settings above.</p>\n<p>There are a couple of scripts that may need to be included to make it much easier for deployment of the application. Remember how I mentioned that it is not good practice for the <code>jks</code> file to be pushed to Github or any VCS you use? Yes, these scripts ensure that the automation is seamless as if it were running on your development machine. I will start off with a couple of things you will need to setup.</p>\n<ul>\n<li><strong>Circle CI environment variables</strong></li>\n</ul>\n<p>Start off by setting Circle CI environment variables, These will be used to setup values that are specific for the project and also that will be used by the scripts we will write up. Some of the environment variables you may need to setup:</p>\n<pre><code class=\"language-plain\">DEV_API_BASE_URL=&#x3C;YOUR_DEV_BASE_URL>\nAPI_BASE_URL=&#x3C;YOUR_BASE_URL>\nAPI_KEY=&#x3C;YOUR_API_KEY>\nGITHUB_TOKEN=&#x3C;YOUR_GITHUB_TOKEN>\nSERVICE_ACCOUNT_EMAIL=&#x3C;YOUR_SERVICE_ACCOUNT_EMAIL>\nVERSION_NAME=1.0.0\nVERSION_CODE=1\nRELEASE_TRACK=beta\nPUBLISH_JSON_KEY=&#x3C;JSON_FILE>\nKEY_STORE_URI=&#x3C;KEY_STORE_URI>\nSTORE_FILE=&#x3C;STORE_FILE>\n</code></pre>\n<blockquote>\n<p>You may notice that the values are somewhat the same as the ones in your <code>gradle.properties</code> file, with 3 new additions.</p>\n</blockquote>\n<p><code>PUBLISH_JSON_KEY</code>, this is a unique key that you will use to verify you are the authorized account when publishing to PlayStore. Refer to <a href=\"https://github.com/codepath/android_guides/wiki/Automating-Publishing-to-the-Play-Store\">this</a> for more information on this.</p>\n<p>Once you have your JSON file, copy and paste that information as an env variable.</p>\n<p><code>KEY_STORE_URI</code> is, as the suffix suggests, uri location of your keystore file. Considering that you can not (and should not) push this to Github, you should be able to still access this somehow right?</p>\n<p>There is an easy way to do this using DropBox, yes, DropBox. A very simple hack is to upload your keystore file there and create a shareable link for the keystore file. With this, then you should be able to use that link to download the file and create a key store on your CI.</p>\n<pre><code class=\"language-bash\">export STORE_FILE_LOCATION=$HOME\"/app-dir/app.jks\"\n\n# download key store file from remote location\n# keystore URI will be the location uri for the *.jks file for signing application\nfunction downloadKeyStoreFile {\n    # use curl to download a keystore from $KEYSTORE_URI, if set,\n    # to the path/filename set in $KEYSTORE.\n    echo \"Looking for $STORE_FILE_LOCATION ...\"\n\n    if [ ! -f ${STORE_FILE_LOCATION} ] ; then\n        echo \"Keystore file is missing, performing download\"\n        # we're using curl instead of wget because it will not\n        # expose the sensitive uri in the build logs:\n        curl -L -o ${STORE_FILE} ${KEY_STORE_URI}\n    else\n            echo \"Keystore uri not set.  .APK artifact will not be signed.\"\n    fi\n}\n</code></pre>\n<blockquote>\n<p>This is a sample of the function you can use to download the keystore file in your project root and set up for successful builds.</p>\n</blockquote>\n<ul>\n<li><strong>Circle CI config.yml file</strong></li>\n</ul>\n<p>Configuring the <code>config.yml</code> file should be painless and easy, considering all the workload will be done by the scripts (will include in a few minutes).</p>\n<p>Some of the scripts you can use for deployment:</p>\n<pre><code class=\"language-bash\">#!/usr/bin/env bash\n\n# 1. http://deathstartup.com/?p=81\n# 2. https://gist.github.com/KioKrofovitch/716e6a681acb33859d16\n# 3. https://stackoverflow.com/questions/35440907/can-circle-ci-reference-gradle-properties-credentials\n\nexport GRADLE_PROPERTIES=$HOME\"/app-dir/gradle.properties\"\nexport KEYSTORE_PROPERTIES=$HOME\"/app-dir/keystores/keystore.properties\"\nexport PUBLISH_KEY_FILE=$HOME\"/app-dir/keystores/publish_key.json\"\nexport STORE_FILE_LOCATION=$HOME\"/app-dir/app.jks\"\n\nfunction copyEnvVarsToProperties {\n\n    echo \"Gradle Properties should exist at $GRADLE_PROPERTIES\"\n    echo \"Keystore Properties should exist at $KEYSTORE_PROPERTIES\"\n\n    if [ ! -f \"$KEYSTORE_PROPERTIES\" ]\n    then\n        echo \"${KEYSTORE_PROPERTIES} does not exist...Creating file\"\n\n        touch ${KEYSTORE_PROPERTIES}\n\n        echo \"keyAlias=$KEY_ALIAS\" >> ${KEYSTORE_PROPERTIES}\n        echo \"keyPassword=$KEY_PASSWORD\" >> ${KEYSTORE_PROPERTIES}\n        echo \"storeFile=$STORE_FILE\" >> ${KEYSTORE_PROPERTIES}\n        echo \"storePassword=$STORE_PASSWORD\" >> ${KEYSTORE_PROPERTIES}\n    fi\n\n    if [ ! -f \"$GRADLE_PROPERTIES\" ]\n    then\n        echo \"${GRADLE_PROPERTIES} does not exist...Creating Properties file\"\n\n    echo \"API_BASE_URL=$API_BASE_URL\" >> ${GRADLE_PROPERTIES}\n    echo \"DEV_API_BASE_URL=$DEV_API_BASE_URL\" >> ${GRADLE_PROPERTIES}\n    echo \"API_KEY=$API_KEY\" >> ${GRADLE_PROPERTIES}\n    echo \"SERVICE_ACCOUNT_EMAIL=$SERVICE_ACCOUNT_EMAIL\" >> ${GRADLE_PROPERTIES}\n\n    fi\n\n    if [ ! -f \"$PUBLISH_KEY_FILE\" ]\n    then\n        echo \"${PUBLISH_KEY_FILE} does not exist...creating properties file\"\n\n        touch ${PUBLISH_KEY_FILE}\n\n        echo \"$PUBLISH_JSON_KEY\" >> ${PUBLISH_KEY_FILE}\n    fi\n}\n\n\n# download key store file from remote location\n# keystore URI will be the location uri for the *.jks file for signing application\nfunction downloadKeyStoreFile {\n    # use curl to download a keystore from $KEYSTORE_URI, if set,\n    # to the path/filename set in $KEYSTORE.\n    echo \"Looking for $STORE_FILE_LOCATION ...\"\n\n    if [ ! -f ${STORE_FILE_LOCATION} ] ; then\n        echo \"Keystore file is missing, performing download\"\n        # we're using curl instead of wget because it will not\n        # expose the sensitive uri in the build logs:\n        curl -L -o ${STORE_FILE} ${KEY_STORE_URI}\n    else\n            echo \"Keystore uri not set.  .APK artifact will not be signed.\"\n    fi\n}\n\n# updates the version code based on the current branch\nfunction updateVersionCodeAndTrack(){\n    versionCode=$(git rev-list --first-parent --count origin/${CIRCLE_BRANCH})\n    versionName=$(git describe --dirty)\n\n#    if [\"${versionName}\" == \"fatal: No names found, cannot describe anything.\"]; then\n#        major=$(expr ${CIRCLE_BUILD_NUM} - ${CIRCLE_PREVIOUS_BUILD_NUM})\n#        versionName=${major}.0.0\n#    fi\n\n    if [\"${versionName}\" == \"fatal: No names found, cannot describe anything.\"]; then\n        versionName=1.0.0\n    fi\n\n    if [ \"${CIRCLE_BRANCH}\" == \"develop\" ]; then\n        echo \"VERSION_NAME=${versionName}\" >> ${GRADLE_PROPERTIES}\n        echo \"VERSION_CODE=${versionCode}\" >> ${GRADLE_PROPERTIES}\n        echo \"RELEASE_TRACK=\\\"beta\\\"\" >> ${GRADLE_PROPERTIES}\n\n    elif [ \"${CIRCLE_BRANCH}\" == \"master\" ] ; then\n        echo \"VERSION_NAME=${versionName}\" >> ${GRADLE_PROPERTIES}\n        echo \"VERSION_CODE=${versionCode}\" >> ${GRADLE_PROPERTIES}\n        echo \"RELEASE_TRACK=\\\"production\\\"\" >> ${GRADLE_PROPERTIES}\n    fi\n}\n\n# execute functions\ncopyEnvVarsToProperties\ndownloadKeyStoreFile\nupdateVersionCodeAndTrack\n</code></pre>\n<blockquote>\n<p>A sample script for CircleCI to use in build and deployment circleci<em>env</em>setup.sh</p>\n</blockquote>\n<p>Now onto the part where magic happens! The <code>config.yml</code> file!</p>\n<p>CircleCI made version 2.0 of their build tool easy and intuitive to use, making creating a proper workflow easy. Here is a sample <code>config.yml</code> file with all the bells and whistles that allow for continuous integration and deployment of and Android application.</p>\n<pre><code class=\"language-yaml\">version: 2\njobs:\n       build:\n                working_directory: ~/appp-dir\n                docker:\n                        - image: circleci/android:api-26-alpha\n                environment:\n                        # Customize the JVM maximum heap limit\n                        _JAVA_OPTIONS: \"-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap\"\n                        JVM_OPTS: -Xmx3200m\n                        TERM: dumb\n\n                steps:\n                        # checkout onto repo\n                        - checkout\n\n                        # setup environment for downloading necessary assets to use for deployment\n                        - run:\n                                name: Setup environment\n                                command: ./scripts/circleci_env_setup.sh\n\n                        # Download and cache dependencies\n                        - restore_cache:\n                                key: App-{{ checksum \"build.gradle\" }}-{{ .Branch }}\n                                keys:\n                                      - app-{{ checksum \"app/build.gradle\" }}\n\n                        # download dependencies\n                        - run:\n                               name: Download dependencies\n                               command: ./gradlew androidDependencies\n\n                        - save_cache:\n                                key: App-{{ checksum \"build.gradle\" }}-{{ .Branch }}\n                                paths: ~/.gradle\n                                keys:\n                                      - app-{{ checksum \"app/build.gradle\" }}\n\n                        - persist_to_workspace:\n                                root: .\n                                paths: .\n\n       test:\n               docker:\n                       - image: circleci/android:api-26-alpha\n               working_directory: ~/moja-dir\n               steps:\n                       - attach_workspace:\n                              at: .\n\n                       - restore_cache:\n                              key: App-{{ checksum \"build.gradle\" }}-{{ .Branch }}\n                              keys:\n                                      - app-{{ checksum \"app/build.gradle\" }}\n\n                       - run:\n                               name: Run Tests\n                               command: ./gradlew test\n\n                       - store_test_results:\n                               path: ~/app-dir/app/build/test-results/\n\n                       - store_artifacts:\n                               path: ~/app-dir/app/build/reports/tests/\n                               destination: /app/reports/\n\n                       - persist_to_workspace:\n                               root: .\n                               paths: .\n\n       deployBeta:\n               docker:\n                       - image: circleci/android:api-26-alpha\n\n               working_directory: ~/app-dir\n               steps:\n                       - attach_workspace:\n                              at: .\n\n                       - restore_cache:\n                              key: App-{{ checksum \"build.gradle\" }}-{{ .Branch }}\n                              keys:\n                                      - app-{{ checksum \"app/build.gradle\" }}\n\n                       - run:\n                              name: Assemble APKs and distribute to Beta Testing\n                              command: ./scripts/circleci_beta_setup.sh\n\n                       - store_artifacts:\n                               path: ~/app-dir/app/build/outputs/apk/\n                               destination: /app/apks/\n\n                       - deploy:\n                               name: Deploy to Play Store\n                               command: ./gradlew :app:publishApkRelease\n\n       deployProd:\n               docker:\n                       - image: circleci/android:api-26-alpha\n\n               working_directory: ~/app-dir\n               steps:\n                       - attach_workspace:\n                              at: .\n\n                       - restore_cache:\n                              key: App-{{ checksum \"build.gradle\" }}-{{ .Branch }}\n                              keys:\n                                      - app-{{ checksum \"app/build.gradle\" }}\n\n                       - run:\n                               name: Create Apk(s)\n                               command: ./gradlew :app:assembleRelease\n\n                       - store_artifacts:\n                               path: ~/app-dir/app/build/outputs/apk/release/\n                               destination: /app/apks/\n\n                       - store_artifacts:\n                               path: ~/app-dir/app/build/outputs/mapping/\n                               destination: /app/mapping/\n\n                       - deploy:\n                               name: Deploy to Play Store\n                               command: ./gradlew :app:publishApkRelease\n\n# define work flows\nworkflows:\n        version: 2\n        build-test-distribute-deploy:\n                jobs:\n                        - build\n\n                        - test:\n                                requires:\n                                        - build\n\n                        # deploys to Beta\n                        - deployBeta:\n                                requires:\n                                        - test\n                                filters:\n                                        branches:\n                                                only:\n                                                        - staging\n                                                ignore:\n                                                        - /^dev-.*/\n                                                        - develop\n                                                        - master\n                                                        - /^feature-.*/\n                                                        - /^feature/.*/\n                                                        - /^bugfix-.*/\n                                                        - /^bugfix/.*/\n                                                        - /^hotfix/.*/\n\n                        # will only deploy if on master and release branches\n                        - deployProd:\n                                requires:\n                                        - test\n                                filters:\n                                        branches:\n                                                only:\n                                                        - master\n                                                ignore:\n                                                        - /^dev-.*/\n                                                        - develop\n                                                        - staging\n                                                        - /^feature-.*/\n                                                        - /^feature/.*/\n                                                        - /^bugfix-.*/\n                                                        - /^bugfix/.*/\n                                                        - /^hotfix/.*/\n</code></pre>\n<blockquote>\n<p><code>config.yml</code> file for building, tesing and deploying to PlayStore.</p>\n</blockquote>\n<p>That pretty much wraps it up for CI and CD with CircleCI for Android. Give it a try and automate the process, the only thing that you will need to do is:</p>\n<ul>\n<li>write tests</li>\n<li>write code to pass tests</li>\n<li>git add .</li>\n<li>git commit</li>\n<li>git push</li>\n<li>Deploy</li>\n<li>Pray (just kidding)</li>\n<li>No, really. Pray!</li>\n<li>Win</li>\n</ul>\n<p>Hope this is helpful, until next time Droids!</p>","frontmatter":{"title":"Continuous Integration and Deployment with Android, the right way.","subtitle":"Continuous Deployment in Android","date":"October, 21, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"cicd_android_feature.png","thumbnail":"cicd_android_thumb.jpg","teaser":"cicd_android_thumb.jpg","credit":null,"creditlink":null},"path":"/tech/ci-with-android","tags":["Android","kotlin","CI","Continuous Integration","Continuous Deployment"],"excerpt":"Continuous Integration has become an essential part of any software project in recent times. With how fast technology keeps changing and how quickly libraries and dependencies get re-written, it becomes essential for your application code to be maintained, tested and delivered to users quickly and efficiently. This will usually involve you re-writing some old code, testing your new feature and then deploying to users for them to enjoy your new feature in your application."}}},"pageContext":{"prev":{"html":"<p>Learning to code is never an easy endevour, especially in the world of technology, where there always seems to be something new that you must learn or know in order to keep up with the trends of the 21st century. It is such a fluid and ever changing world that you can find yourself lost in the pursuit of knowledge.</p>\n<p>Despite this, it is still a pursuit that keeps one growing and learning. These are the most important things when starting out on a journey to learn technology and dive into its depths. Sometimes the journey is full of twists and turns, long nights and early mornings, short weekends and long weekdays, even rough days and good ones, but overall, what makes me most happy is the ability to be able to create something that betters other people's lives. Makes them easier, makes them focus on what is most important in life instead of focusing on the menial tasks that we have the ability to automate.</p>\n<p>I remember when I wrote my first lines of code. I had just finished high school and had a lot of free time on my hands before joining campus (8 months). With this amount of time at one's disposal, it is easy to get lost in all that is happening around without proper planning. I enrolled for the usual classes everyone enrolled for after finishing high shool; Computer classes(Computer package classes, Driving classes, Accounting classes, etc.). I wanted to keep busy, so this gave me the chance to stay out of the house and not lose my mind. Of course all these classes only lasted 4 months, so the extra 4 months was spent attending bootcamps that span 3 weeks or less. It is during that time, that I discovered that one could actually create programs with code.</p>\n<p>The irony of it all was that my curiosity for technology was not inspired at all by attending computer classes, it was in fact inspired by a program that taught people how to type (mostly used by secretaries to train and improve their typing speed). I was curious as to how this simple program knew the keys I typed in and how it measured the speed at which I typed words. It was magic to me. I wanted to understand how it was built, I was <em>waay</em> beyond the why of it all (Improve people's typing speed), I wanted to know <strong>how</strong>.</p>\n<p>So, I dove into Google and typed in <em>how to build a computer program</em>, and waited for the search results to guide me to an answer. Of course, then, there were now sites like <a href=\"https://www.udemy.com/\">Udemy</a>, <a href=\"https://www.udacity.com\">Udacity</a>, <a href=\"http://www.codecademy.com\">Codecademy</a>, etc, so the search was even more difficult. I stumbed upon <a href=\"https://en.wikipedia.org/wiki/Visual_Basic\">Visual Basic</a> and I began downloading all the required tutorials I needed to understand <strong>how</strong> one builds a program, how to start, what you need, all the required tools that should be at your disposal and I just started.</p>\n<p>Fast forward 3 weeks later, after a lot of trial and error and the first program I built was a simple Trivia which was basically a bunch of <em>if else</em> statements that checked for your answer. I didn't care that it was horrible, looked bad or was slow, I just wanted to build something, to see it used and to understand what it took to build a program that did something and made someone's life better (in this case help you become better at trivia questions). It worked! My first ever program! Too bad there was no way of sharing it with the world (because I had no idea how to). So I explored further into how do people share what they create and how do other people then download and install these programs and that lead me to networking and how the internet works(for some reason also lead me to how viruses work, go figure).</p>\n<p>All this digging around for information made me realize how technology had the potential to change my life as well. I was learning, growing, hungry...for knowledge. I simply wanted to understand, I wanted to know the <strong>why</strong> of it all.</p>\n<p>Technology has had a major positive impact ever since. Being part of teams that build highly scalable applications has not only brought out the best in me, but has also shown me what I still need to learn and what I still need to do to get better.</p>\n<p>A couple of things that I have learned along the way:</p>\n<ol>\n<li><strong>Have zero tolerance for the victim mentality</strong>. I have learned to become deliberate about regularly upskiling myself through reading books, learning new skills, meeting and interacting with new people in different fields and industry. Of course, you will not learn everything all at once. There are times where you will fail and will fail hard, it is okay. It is part of the journey. Instead of complaining that it is difficult and hard to understant algorithms and data structures, design patterns and frameworks, take the time to deliberately want to learn and understand that patience is key in this journey.</li>\n<li><strong>Be very deliberate about where you are and understand the opportunity cost of where you are</strong>. Understand your true value including your weaknesses. Focus on up-scaling yourself. Realize that by choosing this, you have foregone other opportunities, that this is the journey you want to be on, this means that you need to make an effort to understand all that comes with it; beyond the code. This means understanding your user(who you are building for) and why you are building it.</li>\n<li><strong>Where you work has a major impact on your work-life harmony</strong>. If you work for a company that re-inforces you and you konow your work will create value, you will remain satisfied and extremely motivated that you hardly feel burn out. This is important especially in a tech field, where there is an ever changing need for how products serve customers, you need to be in a place that gives you the opportunity to balance your work and life in a way that does not sacrfice one for the other. This will leave you wanting and yearning more and will make you happier.</li>\n<li><strong>Realize that technologies are tools used to build products and they are not to be mistaken with the actual product</strong>. A lot of times, developers tend to argue and debate over what is the most popular tool/language to use out there and will tend to make this the most important thing when building an actual product. I understand that developers have their preferences and for good reasons (I included). However, what I have learnt is that treating these preferences as tools instead of an actual product helps you move much more quickly in the industry. Realize that tools are used based on the use-case. You would not use a hammer to cut down a tree, right? Or use a chainsaw sandpaper. Even though you like your hammers, you know you can't use them all the time. So, pick the best tool for the job. The sooner you realize this the faster you can learn and build better products. This will help you to become more diverse and help in exploring posibilities of even building your own tools.</li>\n</ol>","id":"effd9339-9e25-527f-9de7-e29bfd76b0db","timeToRead":5,"frontmatter":{"title":"Influence learning tech has had on my life and career","subtitle":"Learning technology and its impact on my life and career","excerpt":"Technology has been a part of my life for a very long time, not only making it better and easier, but also giving me an opportunity to learn new things. Being able to create, build and innovate using technology makes it have an even bigger impact on my life and career.","path":"/life/influence-tech-on-career","category":"life","date":"August 21, 2018","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"influence_learning_tech.jpg","thumbnail":null,"teaser":"influence_learning_tech.jpg","credit":"Unsplash","creditlink":"https://unsplash.com/@alesnesetril"},"tags":["Career","Technology","Life"],"published":true}},"next":{"html":"<p>It has been a while since my last blog post. And since my last blog post I set out on a journey to learn and grow in learning new technologies and understanding how they work. What really made my adventure exciting was when I discovered a little jewel called Kotlin.\nNow, I know it has become a hot topic with almost everyone talking about Kotlin, especially in the Android developer circles and community. Everyone is talking about the new kid on the block (despite the language not actually being that new).</p>\n<p>Its recent adoption into creation of mobile applications changes how Android applications are being created, introducing functional programming, extension functions and a huge amount in number of lines written, I can understand why people are ready to jump straight into Kotlin development.</p>\n<p>Personally, I am not a Java developer and I always had a bit of a struggle from time to time when it came to Java, especially the verbosity of the language. I appreciate the strictness of the language because it means you have to explicit about what you are trying to achieve and not expect the compiler to read your thoughts. This is quite handy when it comes to building robust applications that will <em>\"stand the test of time\"</em>. Kotlin strives to be less verbose and still perform just as well as Java in the JVM. The fact that it is 100% interroperable with Java means that it can be used side by side and your users will be none the wiser as there will be no difference in how the application performs.</p>\n<p>The reason I joined the <em>Kotlin bandwagon</em> was because I was hungering to learn something new and Kotlin happened to just land in my radar. Admittedly, I started learning Ruby before Kotlin and what caught my eye with Kotlin was how it brought aspects that I was already familiar with in Python, JavaScript, Java and a bit of Ruby. It made me happy when writing code for Android applications again, I did not cringe when I would think of the number of lines of code I had to write in Java to create an application.</p>\n<p>This is not to say that Java is going anywhere, it is still a fantastic language that many systems and organisations still use and will not be abandoned just because there is a new shiny toy that comes with all the fantastic features of a modern language.</p>\n<p>What really intrigued me with Kotlin was how I felt like I had more control and flexibility as to how I wrote code for Android. I have to say that I have not tried writing Kotlin code to be used for server side work or front end work (Kotlin can be compiled to JavaScript, read <a href=\"https://kotlinlang.org/docs/reference/js-overview.html\">here</a> for more), considering that that is what it was intended for in the very beginning, this is because I prefer doing that in Python(<a href=\"http://flask.pocoo.org/\">Flask</a>) and front end work in JavaScript(<a href=\"https://facebook.github.io/react/\">ReactJs</a> for that matter). Just because I love the seperation in my head.</p>\n<p>On to my point, there are subtle (or not so subtle) differences when it comes to Kotlin and Java, and there are too many to highlight here, so I shall highlight only those which I felt really helped me write much more concise, readable and extensible code for Android.</p>\n<h3>Extension functions</h3>\n<p>This for me is a huge win when it comes to writing Android applications in Kotlin. It not only reduces boilerplate code, but also greatly makes code much much more readable. I shall give a use-case:</p>\n<p>Say, you want to create a rotation animation for an image, which will be a progress spinner of sorts. To do this, you will need to do the following in Java.</p>\n<pre><code class=\"language-java\">ImageView progressImg = findViewById&#x3C;ImageView>(R.id.rotateImag)\nRotateAnimation rotateAnimation = RotateAnimation(0F, 360f, Animation.RELATIVE_TO_SELF,\n            0.5f, Animation.RELATIVE_TO_SELF, 0.5f)\nrotateAnimation.setInterpolator(new LinearInterpolator())\nrotateAnimation.setDuration(800)\nrotateAnimation.setRepeatCount(Animation.INFINITE)\nprogressImg.setAnimation(rotateAnimation)\n</code></pre>\n<blockquote>\n<p>Java implementation for a Rotation Animation</p>\n</blockquote>\n<pre><code class=\"language-kotlin\">fun View.createRotateAnimation(duration: Long) {\n    val rotateAnimation = RotateAnimation(0F, 360f, Animation.RELATIVE_TO_SELF,\n                0.5f, Animation.RELATIVE_TO_SELF, 0.5f)\n    rotateAnimation.interpolator = LinearInterpolator()\n    rotateAnimation.duration = duration\n    rotateAnimation.repeatCount = Animation.INFINITE\n    this.startAnimation(rotateAnimation)\n}\n</code></pre>\n<blockquote>\n<p>Kotlin implementation for creating a rotation animation on a View</p>\n</blockquote>\n<p>Now, it may not seem like much, but think about how many times you will have to create the rotation implementation in Java. You may end up creating a static method in a final class just to reduce the boilerplate code written.</p>\n<pre><code class=\"language-java\">final class AnimUtils{\n    public static RotateAnimation createRotationAnimation(){\n        RotateAnimation rotateAnimation = RotateAnimation(0F, 360f, Animation.RELATIVE_TO_SELF,\n                    0.5f, Animation.RELATIVE_TO_SELF, 0.5f);\n        rotateAnimation.setInterpolator(new LinearInterpolator());\n        rotateAnimation.setDuration(800);\n        rotateAnimation.setRepeatCount(Animation.INFINITE);\n        return rotateAnimation;\n    }\n}\n\n//... somewhere in your code\nprogressImg.setAnimation(AnimUtils.createRotationAnimation)\n</code></pre>\n<blockquote>\n<p>Now, this may not be an issue per-say, I mean you have created an easily accessible method to all classes that may need to use it.</p>\n</blockquote>\n<p>Now, how about Kotlin?\nThe fact that we can create extension functions, which in essence is just adding a function to a class that we do not own. In this case we are simply adding a rotation animation to the View class and this allows use to animate any View by simply calling this function as if it belongs to the Android SDK.</p>\n<p>A simple use case</p>\n<pre><code class=\"language-kotlin\">//... assuming you have already initialized your ImageView/ or view\nprogressImg.createRotateAnimation(800)\n</code></pre>\n<p>And that is all! Now with this you do not have to reference a class' static method in order to run a function. This allows more cleaner and clearer code and of course means you can add much more to the function if the need ever arose.</p>\n<h3>Data Classes</h3>\n<p>Now this for me is another big win. In Java, we usually need to create POJO(Plain Old Java Objects or Java Beans) to represent certain data items or objects in data structures of applications. Usually they could end up being 100s of lines of code involving <code>hashCodes()</code>, <code>toString()</code> and getter and setter methods. Say for example we want to create a data structure involving a Person object</p>\n<pre><code class=\"language-java\">class Person{\n    private String firstName;\n    private String lastName;\n    private int age;\n    private String gender;\n\n    public Person(String firstName, String lastName, int age, String gender){\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.age = age;\n        this.gender = gender;\n    }\n\n    public String getFirstName(){\n        return firstName;\n    }\n\n    public void setFirstName(String name){\n        this.firstName = name;\n    }\n\n    public String getLastName(){\n        return lastName;\n    }\n\n    public void setlastName(name){\n        this.lastName = name\n    }\n\n    public int getAge(){\n        return age;\n    }\n\n    public void setAge(age){\n        this.age = age;\n    }\n\n    public String getGender(){\n        return gender;\n    }\n\n    public void setGender(gender){\n        this.gender = gender;\n    }\n\n    // hashCodes and toString methods\n}\n</code></pre>\n<blockquote>\n<p>Person object in Java</p>\n</blockquote>\n<p>Now, the same in Kotlin is executed in 1 line of code</p>\n<pre><code class=\"language-kotlin\">data class Person(var firstName : String, var lastName : String, var age : Int, var gender : String)\n// the toString, errorCode, hashCode and even copy are autogenerated\n</code></pre>\n<blockquote>\n<p>Person object in Kotlin</p>\n</blockquote>\n<p>This not only reduces boiler plate code, but ensures that I concentrate on how this object will be used, instead of constantly thinking whether I correctly implemented a getter/setter method to the class or whether there is a <code>toString()</code> method implemented so I do not get an odd looking memory location hex String.</p>\n<h3>Named and Optional Arguments</h3>\n<p>Now this will be the final thing I shall write about in this post. Named arguments in functions are common in languages such as <code>Python</code>. This allows us to, for example refer to a specific argument for a given parameter instead of trying to mentally remember if position two takes a <code>Double</code> or a <code>Long</code> given that there are 5 parameters to pass in into the given function.</p>\n<p>I shall write a simple Kotlin function that allows optional arguments and which in turn will deal with named arguments. Say, you are writing a function that has 5 arguments of which 2 are optional(have default values)</p>\n<pre><code class=\"language-kotlin\">// calculates distance of object from another object given its coordinates and the speed in which it is moving\nfun calculateDistance(x : Int, y: Int, z: Int, speed: Double = 0.0, other : Any) : Int{\n    val dx = other.x - x\n    val dy = other.y - y\n    val dz = other.z - z\n    val ds = if(speed != 0.0) other.speed - speed else speed\n    // some awesome distance calculating algorithm\n\n    return distance\n}\n\n// usage, PositionElement is a simple class that randomly places the object on a plane\n// given its x, y and z co-ordinates and its speed\nval A = PositionElement(5, 6, 15, 8.5)\nval B = PositionElement(3, 8, 1, 19.5)\n\n// calculate the distance of A from B\ndistanceForAFromB = calculateDistance(x = A.x, y = A.y, z = A.z, speed = A.speed, other = B)\n\n// assuming that A has no speed\nval A = PositionElement(5, 6, 15, 0.0)\ndistanceForAFromB = calculateDistance(x = A.x, y = A.y, z = A.z, other = B)\n</code></pre>\n<p>As you can see above, the named arguments help in determining what parameter is being passed where in a function invocation and allows for easier calculation and making your code much much more readable and also of course allows you to not keep switching files to make sure the correct parameter is passed.</p>\n<h4>Conclusion</h4>\n<p>I am still on this Kotlin journey and I have to say that I am so far pleased with the fact I have been able to write much much more concise code as compare to before. There is so much more to Kotlin than meets the eye and I am so far please with the language and how it brings a sense of happiness when writing code in Kotlin.</p>","id":"775a977d-0892-50c5-b5df-3cf44ec7dcb8","timeToRead":7,"frontmatter":{"title":"My Journey in Kotlin thus far","subtitle":"Kotlin adventures","excerpt":"It has been a while since my last blog post. And since my last blog post I set out on a journey to learn and grow in learning new technologies and understanding how they work. What really made my adventure exciting was when I discovered a little jewel called Kotlin.","path":"/tech/kotlin-adventures","category":"tech","date":"September 10, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"kotlin_feature.png","thumbnail":"kotlin_thumb.jpg","teaser":"kotlin_thumb.jpg","credit":"Kotlinlang.org","creditlink":null},"tags":["Android","Java","language","kotlin"],"published":true}}}}}