{"componentChunkName":"component---src-templates-blogs-blog-post-jsx","path":"/tech/object-oriented-programming","result":{"data":{"markdownRemark":{"html":"<p>Object Oriented Programming, or as is popularly known in the programming realm OOP is a style of programming that is organized around objects rather than actions. It takes the view that what we really care about are the objects we want to manipulate rather than the logic required to manipulate them. It is a concept that has been widely adopted and is recommended for every software developer. It not only makes life easier for you as a developer but also aids other developers in collaborating easily with your project, as it is lighter as compared to precedural programming.</p>\n<p>There are a couple of definitions that I believe are important to understand before delving deeper into OOP. Definitions such as <em>object</em>, <em>classes</em>, <em>inheritance</em>, <em>interface</em> and <em>packages</em>.</p>\n<h2>Object</h2>\n<p>An <em>object</em> is a software bundle of related state and behaviour. They are often used to model real life objects you find in everyday life. They are key to understanding what OOP is all about. Objects are all around us, the trees, your radio, your phone, your pet dog (or cat). All these objects, despite their differences, have 2 things in common. They have <strong>state</strong> and <strong>behaviour</strong>. Your pet has state (name, color, breed) and behaviour (bark, run, wag tail). Your car also has state (current gear, current speed) and behaviour (changing gear, applying breaks, etc). Despite one being a living thing and the other a machine, they both share 2 important characteristics; the have state and behaviour. If you look keenly at these objects keenly, you will notice that they greatly vary in complexity and may find that some contain other objects. This is the center of Object Oriented Programming.</p>\n<p>Software objects are no different from the real world objects. They contain states (fields or variables in some programming languages) and behaviour (methods or functions in some programming languages). A software object stores its states in fields and shows its behaviour in methods.</p>\n<p><img src=\"https://docs.oracle.com/javase/tutorial/figures/java/concepts-object.gif\" alt=\"image\" title=\"Software Object Courtesy Of Java Documentation\"></p>\n<blockquote>\n<p>Data Encapsulation: Hiding internal state and requiring all interaction to be performed through an object's methods. Methods operate on an object's internal state and serve as the primary mechanism for object-to-object communication. This is a fundamental principle of object-oriented programming.</p>\n</blockquote>\n<p>Objects have a couple of advatages:</p>\n<ul>\n<li><em>Allows for code re-use</em>: If an object already exists due to it being created by another developer, you can easily plug it into your source code and use it.</li>\n<li><em>Modularity</em>: An objects source code can be written independently of the system, allowing it, once created, to be passed around inside the system.</li>\n<li><em>Objects allow information hiding</em>: By interacting with the objects methods, the internal process remain hidden.</li>\n<li><em>Plug and Play</em>: If a particular object is problematic to your code, you could simply remove it and use another. This allows you to debug your code easily.</li>\n</ul>\n<h2>Class</h2>\n<p>A class is a <em>blue print</em> from which all your objects are created. Take your car or bicycle for example. They are thousands of cars in existence, your car is one of them. Most contain the same nuts and bolts, engine capacity and gearbox. This means they were made from a similar blue print (a similar plan). Your car is said to be an <strong>instance</strong> of the class of objects known as cars. So, basically a car, is a group of related objects with similar states and behaviours.</p>\n<pre><code class=\"language-Java\">class Car {\n\n    int speed = 0;\n    int gear = 1;\n\n    void changeGear(int newValue) {\n         gear = newValue;\n    }\n\n    void speedUp(int increment) {\n         speed = speed + increment;\n    }\n\n    void applyBrakes(int decrement) {\n         speed = speed - decrement;\n    }\n\n    void printStates() {\n         System.out.println(\" speed:\" +\n             speed + \" gear:\" + gear);\n    }\n}\n</code></pre>\n<p>Above is a Car class that has the states and the behaviours of a car. The states are shown by the <code>int</code> variables speed and gear while the behaviours are shown by the <code>changeGear(int enwValue)</code>, <code>speedUp(int increment)</code>, <code>applyBrakes(int decrement)</code> and <code>printStates()</code> methods. These methods are how this class will interact with the <em>outside</em> world. For those of you familiar with Java programming, you may have noticed that this class lacks the main method. This is becase this is a blue print for all other car objects and not the main application.</p>\n<pre><code class=\"language-Java\">class CarDemo {\n    public static void main(String[] args) {\n\n        // Create two different Car objects\n        Car car1 = new Car();\n        Car car2 = new Car();\n\n        // Invoke methods on the newly created objects\n        car1.speedUp(15);\n        car1.changeGear(3);\n        car1.printStates();\n\n        car2.speedUp(10);\n        car2.changeGear(2);\n        car2.speedUp(10);\n        car2.changeGear(3);\n        car2.printStates();\n    }\n}\n</code></pre>\n<p>This is the main application that will test for newly created car objects. The output will be as below.</p>\n<pre><code class=\"language-Java\">speed:15 gear:3\nspeed:20 gear:3\n</code></pre>\n<p>As you can see the <code>car1</code> and <code>car2</code> objects have the same states and have the same behaviour. This is despite being owned by 2 different people, for example. They will move in the same manner and have the same states.</p>\n<h2>Concept of Inheritance</h2>\n<p>Inheritance, as the name suggests, is <em>inheriting</em> characeteriestics from the parent. Like a son having the same nose and hair as the father, or having the same eyes and lips as the mother. This is inheritance. The same applies to programming. The <code>Car</code> class created above is the <em>parent</em> and the <code>car1</code> and <code>car2</code> are the <em>children</em>. The objects inherit states and behaviours from the <code>Car</code> class. This is in lay man terms. The correct terms to use are <strong>superclass</strong> and <strong>subclass</strong>. The <code>Car</code> class is the <em>superclass</em> and the car objects are the <em>subclasses</em> and are thus able to inherit from the <code>Car</code> class behaviours such as <code>changeGear</code>.</p>\n<p>This does not mean that these are the only states and behaviours they could have. Take, the cars above. One could be a Mercedeze Benz and the other a Jeep Wrangler. They are both cars, but they are unique from each other. The Mercedeze Benz has 4 seats, while the Jeep has 2. The engine sizes are different and so are their top speeds and the terrain which they can handle. But, the bottom line, they are cars and <em>inherit</em> from the <code>Car</code> class. In Java, each class is alowed to have one superclass, while each superclass can have many subclasses.</p>\n<p>Below image shows the hierachy of bicycle class.</p>\n<p><img src=\"https://docs.oracle.com/javase/tutorial/figures/java/concepts-bikeHierarchy.gif\" alt=\"bicycle\" title=\"Bicycle Hierarchy\"></p>\n<p>To create a subclass in Java, simply <em>extend</em> the superclass and inherit its methods.</p>\n<pre><code class=\"language-Java\">class MercedezBenz extends Car{\n    //perform actions here\n    //new fields for the mercedez benz go here\n    //and inherited methods as well as specific ones to mercedez benz\n}\n</code></pre>\n<p>This gives MercedezBenz all the same fields and methods as Car class, yet allows its code to focus exclusively on the features that make it unique. Thus, differentiating it from the JeepWrangler class. This makes code for your subclasses neat and easy to read. Caution must be taken as to properly document state and behavior that each superclass defines.</p>\n<h2>Interface</h2>\n<p>Methods are the means in which objects interact with the world outside. Methods from the object <em>interface</em> with the world outside. The buttons on your phone, for example, act as interfaces between the cpu components and you. Allowing you to access the states and behaviour of the phone, states such as <em>off</em> and <em>on</em> or behaviour such as <em>calling</em> or <em>sending message</em>.</p>\n<p>An interface can be thought of as a group of related methods with empty bodies. If the Car class behaviour was to be described in an interface it would be as follows:</p>\n<pre><code class=\"language-Java\">interface CarBehaviour{\n\n    void changeGear(int newValue);\n\n    void speedUp(int increment);\n\n    void applyBrakes(int decrement);\n}\n</code></pre>\n<p>To implement the above interface with your class, you would have to <em>implement</em> the <code>CarBehaviour</code> interface like so</p>\n<pre><code class=\"language-Java\">class JeepWrangler implements CarBehaviour{\n    int speed = 0;\n    int gear = 1;\n\n    void changeGear(int newValue) {\n         gear = newValue;\n    }\n\n    void speedUp(int increment) {\n         speed = speed + increment;\n    }\n\n    void applyBrakes(int decrement) {\n         speed = speed - decrement;\n    }\n\n    void printStates() {\n         System.out.println(\"speed: \" +\n             speed + \" gear:\" + gear);\n    }\n}\n</code></pre>\n<blockquote>\n<p>Note that the compiler will require that methods <code>changeGear</code>, <code>speedUp</code>, and <code>applyBrakes</code> all be <em>implemented</em>. Compilation will fail if those methods are missing from this class.</p>\n</blockquote>\n<p>An interface allows a class to become more formal about its behavior. Interfaces form a sort of contract between the class and the outside world. This contract is enforced at build time by the compiler. If your class claims to implement an interface, all methods defined by that interface must appear in its source code before the class will successfully compile.</p>\n<h2>Different Languages Same Objects</h2>\n<p>Objects can be created in many ways, this mostly depends on the programming language used. In Java, for example,</p>\n<pre><code class=\"language-Java\">//className objectToCreate = new className();\nCar mercedezBenz = new Car();\n</code></pre>\n<p>The <code>new</code> word is a keyword, which means it is reserved in Java for specifically creating objects. Therefore it can not be used as a variable name.</p>\n<p>in JavaScript, creation of an object can be as follows:</p>\n<pre><code class=\"language-JavaScript\">function fnName1(value1,value2){\n    this.value1 = value1;\n    this.value2 = value2;\n    }\n//alternatively\nvar fnName2 = new Object{};\nfnName2.[\"value1\"] = value1;\nfnName2.value2 = value2;\n</code></pre>\n<blockquote>\n<p>The first part is creation of an object using a custom constructor, while the alternative is using an object constructor in which values can be added using either dot notation or bracket notation</p>\n</blockquote>\n<p>To access methods and instance variables, one uses the <strong>dot operator</strong> (.) to access a method or variable that lies in a newly created object.</p>\n<p>It is always good practice to <strong>encapsulate</strong> your class. This protects your code and prevents editing of your variables. Instead these fields of variables should be accessed through <em>getter</em> and <em>setter</em> methods.</p>\n<p>Take the example below:</p>\n<pre><code class=\"language-JavaScript\">class Car{\n    var engine,gasTank,gas,door;\n\n    function driveForward(howFar){}\n    function reverse(howFar){}\n    function stop(){}\n    function openDoor(){}\n\n    //getters and setters\n    function getGas(){\n        return gas;\n    }\n\n    function getGasTank(){\n        return gasTank;\n    }\n\n    function setGas(gas){\n        this.gas = gas;\n    }\n\n    function setGasTank(gasTank){\n        this.gasTank = gasTank;\n    }\n}\n</code></pre>\n<blockquote>\n<p>The above class has getters and setters. The fields <code>engine</code>, <code>gas</code>, <code>gasTank</code> and <code>door</code> can not be accessed outside this class without the getters and setters</p>\n</blockquote>\n<p>To access these fields you need to call the function such as <code>getGasTank()</code> which will return the value of field <code>gasTank</code>. This makes sure that your fields remain secure and can only be edited from inside the class and not outside.</p>\n<h2>Method Overload!</h2>\n<p>It is possible in OOP to create methods that accept any type of variable, such as double, integer,String and return the same intended result. This is known as <em>overloading of methods</em>. It makes it easy to use just one function name that accepts any variable type, but performs the same function. Like taking int two integers, such as 4 and 5 and returning the sum. Now, what if the user enters 4 and 5 as strings? The intended purpose is to still return the same result of 9 regardless of the variable type. This is where method overloading comes in handy.</p>\n<ul>\n<li>First create multiple methods with the same name</li>\n<li>Make sure that each created method has a different return type, number of arguments or type of arguments</li>\n</ul>\n<p>Languages such as <a href=\"www.w3schools.com/js\" title=\"More information on JavaScript\">JavaScript</a> do not allow overloading, because they do not assign variable types to variables when they are created. Languages such as <a href=\"https://en.wikipedia.org/wiki/Java_(programming_language)\" title=\"More info on Java\">Java</a> allow overloading.</p>\n<pre><code class=\"language-Java\">public int addNumbers(int a, int b){\n    return a+b;\n}\n\npublic String addNumbers(String a,String b){\n    int result = Integer.parseInt(a) + Integer.parseInt(b);\n    return String.valueOf(result);\n}\n</code></pre>\n<blockquote>\n<p>The above methods have the same name, but accept different types of arguments. The first one accepts 2 integers and returns their sum. The second one accepts 2 strings, converts them to integers and sums them and returns the string literal of the integer.</p>\n</blockquote>\n<p>The above functions perform the same function, but accept and return different variable types. This is an example of overloading methods.</p>\n<h2>Conclusion</h2>\n<p>There is so much more to OOP, these are just some of the basics. These basics will get you started to creating software that uses and utilizes the power of OOP. It will make writing code that much easier.\nIn conclusion, Objective of Object Oriented Programming si to make creation of software easy and fluid.</p>","frontmatter":{"title":"Objective of Object Oriented Programming.","subtitle":"Objected oriented programming","date":"June, 02, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"object-oriented-programming.png","thumbnail":"object-oriented-programming.png","teaser":"object-oriented-programming.png","credit":null,"creditlink":null},"path":"/tech/object-oriented-programming","tags":["OOP","Objects"],"excerpt":"Object Oriented Programming, or as is popularly known in the programming realm OOP is a style of programming that is organized around objects rather than actions."}}},"pageContext":{"prev":{"html":"<p>For a program to be said to be object oriented, some principles have to be followed. These principles are crucial to enable the said program to be effective in order to be able to meet the needs the program was designed for.\nThe four principles are:</p>\n<ul>\n<li>Encapsulation</li>\n<li>Abstraction</li>\n<li>Inheritance</li>\n<li>Polymorphism</li>\n</ul>\n<h2>Encapsulation</h2>\n<p>This is the hiding of data implementation by restricting access to <em>setters</em> and <em>getters</em> Getters are accessor methods that allows the <em>state</em> of an object to be retrieved, while setters are mutator methods that allows on objects state to be modified. This enables the original data (variables or fields) to be protected as they are not directly modified, rather they are accessed through these methods. This enables one to make changes to a class without the worry that they are going to break other code that is using and calling the same class for information. Here is a brief example:</p>\n<pre><code class=\"language-Java\">public class Person{\n  private String fName;\n  private String lName;\n  private String email;\n\n  //Constructor\n  public Person(String fName,String lName,String email){\n    this.fName = fName;\n    this.lName = lName;\n    this.email = email.\n  }\n\n  //Getter and setter methods for each field\n  public String getFname{\n    return fName;\n  }\n\n  public void setfName(String fName){\n    this.fName = fName;\n  }\n\n  public String getLname{\n    return lName;\n  }\n\n  public void setlName(String lName){\n    this.lName = lName;\n  }\n\n  public String getEmail{\n    return email;\n  }\n\n  public void setEmail(String email){\n    this.email = email;\n  }\n}\n</code></pre>\n<blockquote>\n<p>Above is a Person class that contains the persons first name(<code>fName</code>), last name(<code>lName</code>) and email(<code>email</code>)</p>\n</blockquote>\n<p>This Person class fields <code>fName</code>, <code>lName</code> and <code>email</code> are hidden from outside and can not be accessed directly. However, they can be accessed through getter and setter methods, i.e. <code>getFname</code>, <code>getLname</code>, <code>getEmail</code>, <code>setFname</code>, <code>setLname</code> and <code>setEmail</code>.</p>\n<pre><code class=\"language-Java\">import Person\npublic class Main{\n  public static void main(String args[]){\n    //creates a new Person object\n    Person john = new Person(\"John\",\"Hancock\",\"john@example.com\");\n    System.out.println(john.fName); //will return an error, as this field can not be directly accessed\n    System.out.println(john.getFname());//will return John\n  }\n}\n</code></pre>\n<blockquote>\n<p>Above is a simple demonstration of encapsulation. <code>john</code> object is created using a custom constructor, which initializes the fields (<code>fName</code>,<code>lName</code> and <code>email</code>). the <code>getFname</code> is used to access the first name John.</p>\n</blockquote>\n<h2>Abstraction</h2>\n<p>Abstract means a concept or an Idea which is not associated with any particular instance. Using abstract class/interface we express the intent of the class rather than the actual implementation. In a way, one class should not know the inner details of another in order to use it, just knowing the interfaces should be good enough. Abstraction denotes a model, a view, or some other focused representation for an actual item.</p>\n<p>When we think about it every noun in the language is a category. When we say \"a bird\", we are not referring to a specific bird, but to the category that contains all the birds in the world, and describe them. So when I say \"a bird\" most people have a general idea of what I mean, what information they will have about each individual object that will be in this category and what kind of action it could do.</p>\n<pre><code class=\"language-Java\">public class Bird{\n  private String name;\n  private float height;\n  private float weight;\n  private boolean fly;\n\n  //constructor\n  public Bird(String name,float height, float weight, boolean fly){\n    this.name = name;\n    this.height = height;\n    this.weight = weight\n    this.fly = fly;\n  }\n\n  //getters and setters\n  public String getName(){\n    return name;\n  }\n\n  public void setName(String name){\n    this.name = name;\n  }\n\n  public float getHeight(){\n    return height;\n  }\n\n  public void setHeight(float height){\n    this.height = height;\n  }\n\n  public float getWeight(){\n    return weight;\n  }\n\n  public void setWeight(float weight){\n    this.weight = weight;\n  }\n\n  public boolean getFly(){\n    return fly;\n  }\n\n  public void setFly(boolean fly){\n    this.fly = fly;\n  }\n\n  public boolean canFly(){\n    //code to determine if the bird can fly and returns a boolean value\n  }\n\n  public boolean canChirp(){\n    //code to determine if the bird can chirp and returns a boolean value\n  }\n}\n</code></pre>\n<blockquote>\n<p>Above is a simple class that has the states(fields) of a bird class.</p>\n</blockquote>\n<p>This is an example of an abstract type of what a bird object is to us outside of the software world. The abstract bird is defined by the operations that can be performed on it, and the information we can get from it and give to it.</p>\n<h2>Inheritance</h2>\n<p>This is the ability of a new class to be created, from an existing class by <em>extending</em> it. The parent class is referred to as the <strong>superclass</strong> or <strong>base class</strong> or <strong>parent class</strong> or <strong>ancestor class</strong>. The <em>superclass</em> is the class that defines all the properties and methods of the subclasses. Objects can relate to eachother with either a <strong>has a</strong>, <strong>uses a</strong> or an <strong>is a</strong> relationship. <em>Is a</em> is the inheritance way of object relationship. A proper example is a vehicle class. All cars are vehicles, but they do not have the same properties and behaviours. They all inherit from the vehicle class, but there are features that are not common in all, which makes every vehicle object unique from the other. A truck is not the same from a sedan and a motorbike is not the same as a trailer, despite the fact that they are all vehicles. Let us look at an example:</p>\n<pre><code class=\"language-Java\">public class Vehicle{\n  private String name;\n  private String model;\n  private int engineSize;\n  private int wheels;\n  private int doors;\n  pritave int seats;\n  int speed = 0;\n  int gear = 1;\n\n  //constructor\n  public Vehicle(String name, String model,int engineSize,int wheels,int doors,int seats){\n    this.name = name;\n    this.model = model;\n    this.engineSize = engineSize;\n    this.wheels = wheels;\n    this.doors = doors;\n    this.seats = seats;\n  }\n\n  //getters and setters\n  public String getName(){\n    return name;\n  }\n\n  public void setName(String name){\n    this.name = name;\n  }\n\n    public String getName(){\n    return name;\n  }\n\n  public void setName(String name){\n    this.name = name;\n  }\n\n  public String getModel(){\n    return model;\n  }\n\n  public void setModel(String model){\n    this.model = model;\n  }\n\n  public int getEngineSize(){\n    return engineSize;\n  }\n\n  public void setEngine(String engineSize){\n    this.engineSize = engineSize;\n  }\n\n  public String getWheels(){\n    return wheels;\n  }\n\n  public void setWheels(String wheels){\n    this.wheels = wheels;\n  }\n\n  public String getDoors(){\n    return doors;\n  }\n\n  public void setSeats(String seats){\n    this.seats = seats;\n  }\n\n  //behaviours of a typical Vehicle object\n  public void changeGear(int newValue) {\n         gear = newValue;\n  }\n\n  public void speedUp(int increment) {\n         speed = speed + increment;\n  }\n\n  public void applyBrakes(int decrement) {\n       speed = speed - decrement;\n  }\n\n  pulic void printStates() {\n   System.out.println(\" speed:\" + speed + \" gear:\" + gear);\n  }\n}\n</code></pre>\n<blockquote>\n<p><code>Vehicle</code> class that describes all the properties of a vehicle object. This is the superclass</p>\n</blockquote>\n<p>The class above can be extended as shown below</p>\n<pre><code class=\"language-Java\">public class Truck extends Vehicle{\n  //perform actions here specific to a Truck object\n}\n\npublic class MotorBike extends Vehicle{\n  //perform actions specific to a MotorBike Object\n}\n</code></pre>\n<blockquote>\n<p><code>Truck</code> class gets all the properties of the <code>Vehicle</code> class</p>\n</blockquote>\n<p>Importance of inheritance:</p>\n<ul>\n<li>Reuse of code</li>\n<li>Prevention of new bugs</li>\n<li>Reducing code size</li>\n<li>Code readability</li>\n</ul>\n<h2>Polymorphism</h2>\n<p>It means one name many forms. Polymorphism manifests itself by having multiple methods all with the same name, but slightly different functionality. It is further of two types:</p>\n<ul>\n<li><em>Static (or compile-time) polymorphism</em> is achieved using method overloading</li>\n<li><em>Dynamic(or runtime) polymorphism</em> using method overriding.</li>\n</ul>\n<h3>Static polymorphism (or compile-time)</h3>\n<p>A method having same name can have multiple implementations, depending upon the argument(s) passed to it. For example, there can be three methods called add(int x, int y), add(float x, float y) and add(String x,String y). The compiler decides at compile time which method will be called by looking at the signature of the called method.</p>\n<pre><code class=\"language-Java\">public class StaticPoly{\n  public static void main(String[] args){\n    int xInt = 5;\n    int yInt =4;\n    String xStr = \"5\";\n    String yStr = \"4\";\n    float xFloat = 5.0;\n    float yFloat = 4.0;\n\n    System.out.println(add(xInt, yInt)); //output 9\n    System.out.println(add(xFloat, yFloat)); // output 9.0\n    System.out.println(and add(xStr,yStr)); //output \"9\"\n  }\n\n  public static int add(int x, int y){\n    return x+y;\n  }\n  public static float add(float x, float y){\n    return x+y;\n  }\n  public static String add(String x,String y){\n    int result = Integer.parseInt(x) + Integer.parseInt(y);\n    return String.valueOf(result);\n  }\n}\n</code></pre>\n<blockquote>\n<p>Demonstration of static polymorphism or method overloading</p>\n</blockquote>\n<h3>Dynamic polymorphism</h3>\n<p>A subclass may override a superclass method for more specific behaviour. The decision of which method to call is made at runtime. The calling code may declare the object to be of parent type. At runtime, depending upon the actual type of the object, the correct method will be invoked. An example may be of open() method for superclass Document. The subclasses doc and xls both override open() method. But it may not be known beforehand which document will be opened. At runtime, depending upon the object on which open() is called, the correct Document object's open() method will be invoked.</p>\n<p>Method overriding allows a subclass to override a specific implementation of a method that is already provided by one of its super-classes.</p>\n<pre><code class=\"language-Java\">public class Complex\n{\n    private int real;\n    public int Real\n    private int imaginary;\n\n    public Complex(int real, int imaginary){\n        this.real = real;\n        this.imaginary = imaginary;\n    }\n    public int getReal(){\n      return real;\n    }\n\n    public int getImaginary(){\n      return imaginary;\n    }\n\n    public static Complex operator +(Complex c1, Complex c2){\n        return new Complex(c1.Real + c2.Real, c1.Imaginary + c2.Imaginary);\n    }\n\n    public override string ToString(){\n        return (String.Format(\"{0} + {1}i\", real, imaginary));\n    }\n}\n</code></pre>\n<blockquote>\n<p>This class has one overridden method named ToString, which overrides the default implementation of the standard ToString method to support the correct string conversion of a complex number.</p>\n</blockquote>\n<pre><code class=\"language-Java\">public class DyanamicPoly{\n  public static void main(String[] args){\n  Complex num1 = new Complex(5, 7);\n  Complex num2 = new Complex(3, 8);\n\n  // Add two Complex numbers using the overloaded plus operator\n  Complex sum = num1 + num2;\n\n  // Print the numbers and the sum using the overriden ToString method\n  System.out.println(\"({0}) + ({1}) = {2}\", num1, num2, sum);\n  }\n}\n</code></pre>\n<h1>Conclusion</h1>\n<p>A good objecto oriented software follows these principles to the letter. These principles make your code easier to read, understand and also are effective when it comes to debugging and upgrading. They also make your code smaller, as you end up writing less code.</p>","id":"54d943e7-ff13-5439-ae6c-7b6bee4f5f5a","timeToRead":7,"frontmatter":{"title":"The 4 Principles of OOP","subtitle":"Principles governing OOP","excerpt":"For a program to be said to be object oriented, some principles have to be followed. These principles are crucial to enable the said program to be effective in order to be able to meet the needs the program was designed for.","path":"/tech/principles-of-oop","category":"tech","date":"June 03, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"principles-of-oop.jpg","thumbnail":"principles-of-oop.jpg","teaser":"principles-of-oop.jpg","credit":null,"creditlink":null},"tags":["oop","oop principles","objects","encapsulation","abstraction","interfaces","polymorphism"],"published":true}},"next":null}}}