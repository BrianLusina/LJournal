{"componentChunkName":"component---src-templates-blogs-blog-post-jsx","path":"/tech/vigenere-cipher","result":{"data":{"markdownRemark":{"html":"<p>The Vigenere cipher is likely the the most secure ciphers out there. It builds on the principle of the Caesar cipher yet provides a decent way to avoid the easy to solve shift problems. The basic gist of this cipher is we have both a message and a key. The key can be any length, but you must repeat the key for the length of our message to get this to work. This can be seen here:</p>\n<pre><code class=\"language-plain\">alpha = ABCDEFGHIJKLMNOPQRSTUVWXYZ\nmessage  = IAMTHEWALRUS\nkey  = HELLOHELLOHE\n</code></pre>\n<p>Our key is actually \"HELLO\", but we expanded it to the length of our message giving us the repeated nature we see. Once we have these defined, we go character by character performing a pseudo-Caesar cipher.</p>\n<pre><code class=\"language-plain\">m1 = I = 9\nk1 = H = 8\n9 + 8 = 17 % 26 = 17 = Q\nc1 = Q\n</code></pre>\n<p>Looking at this, we see that the first character of our message is \"I\" which is the ninth letter in the alphabet. We then look at the first character of the key which is \"H\" or the eighth letter in the alphabet. We add those two numbers and modulo 26 giving us 17 which points to the seventeenth letter in the alphabet: \"Q\". We now know that the first letter of our ciphertext is \"Q\".</p>\n<p>We then repeat this method for each character in our message until we have the ciphertext. This can be better shown as the algorithm:</p>\n<p>Let m be our message and k be our key:\nE(m) = ((m1 + k1) % 26, (m2 + k2) % 26, ..., (mi + ki) % 26)\nD(m) = ((c1 - k1) % 26, (c2 - k2) % 26, ..., (ci - ki) % 26)\nThis is much like the Caesar cipher except instead of defining a fixed rotation, we allow our key's character index to be the rotation. As you can see, this is why the Vigenere cipher can be considered a string of Caesar ciphers. Pretty cool when you actually see it.</p>\n<p>So how do we attack this then?</p>\n<p>Well, the problem with this cipher is the fact that the key repeats itself. When you have a repeating key, it's common to see patterns in the ciphertext that completely match each other. By recognizing those patterns, you can determine the block size of the key and from there you simply do a Caesar brute force shift on each block until the plaintext appears.</p>\n<p>On relatively short messages, this is harder to crack (as with any short ciphertext) but if encrypting a uniformly distributed text then you can really start to pick up on these things.</p>\n<p>Now let's code this up in Python and see how how we can automate this:</p>\n<pre><code class=\"language-python\">from itertools import cycle\n\nALPHA = 'abcdefghijklmnopqrstuvwxyz'\n\n\ndef encrypt(key, plaintext):\n    \"\"\"Encrypt the string and return the ciphertext\"\"\"\n    pairs = zip(plaintext, cycle(key))\n    result = ''\n\n    for pair in pairs:\n        total = reduce(lambda x, y: ALPHA.index(x) + ALPHA.index(y), pair)\n        result += ALPHA[total % 26]\n\n    return result.lower()\n\n\ndef decrypt(key, ciphertext):\n    \"\"\"Decrypt the string and return the plaintext\"\"\"\n    pairs = zip(ciphertext, cycle(key))\n    result = ''\n\n    for pair in pairs:\n        total = reduce(lambda x, y: ALPHA.index(x) - ALPHA.index(y), pair)\n        result += ALPHA[total % 26]\n\n    return result\n\n\ndef show_result(plaintext, key):\n    \"\"\"Generate a resulting cipher with elements shown\"\"\"\n    encrypted = encrypt(key, plaintext)\n    decrypted = decrypt(key, encrypted)\n\n    print 'Key: %s' % key\n    print 'Plaintext: %s' % plaintext\n    print 'Encrytped: %s' % encrypted\n    print 'Decrytped: %s' % decrypted\n</code></pre>\n<h2>Step One</h2>\n<p>Import the <code>cycle()</code> function from the <code>itertools</code> library.</p>\n<p>Define our alphabet in order to get character indexes correctly, this can be done with the <code>string</code> module in Python, which enables us to get all the letters in the alphabet we need. This avoids the issue of forgetting a letter in case you hardcode the alphabet.</p>\n<p>The function <code>encrypt(key, plaintext)</code> takes in a key and a plain text, I build a tuple with the <code>zip()</code> function which is a terminating function. Which means it will stop as soon as the shorter string is exhausted.</p>\n<p>An example</p>\n<pre><code class=\"language-python\"># in\nlist(zip(string.ascii_lowercase, string.ascii_uppercase))\n\n# out\n[('a', 'A'), ('b', 'B'), ('c', 'C'), ('d', 'D'), ('e', 'E'), ('f', 'F'), ('g', 'G'), ('h', 'H'), ('i', 'I'), ('j', 'J'), ('k', 'K'), ('l', 'L'), ('m', 'M'), ('n', 'N'), ('o', 'O'), ('p', 'P'), ('q', 'Q'), ('r', 'R'), ('s', 'S'), ('t', 'T'), ('u', 'U'), ('v', 'V'), ('w', 'W'), ('x', 'X'), ('y', 'Y'), ('z', 'Z')]\n</code></pre>\n<p><code>cycle</code> is used to repeat the letters of the key for the entirety of the plaintext, note that this can repeat indefinately.</p>\n<p>Perform a loop in each of the pairs reducing them to a single value with <code>reduce</code> function from functools library. The <code>reduce</code> function takes in a function and an iterable object.</p>\n<p>The sum could be used here as well, but it would mean remembring that indexes of the letters and not the letters themselves are needed, or else we'll get a value error.</p>\n<p>Finally get the new letter after a modulo of 26 and append that to our resulting ciphertext string.</p>\n<h2>Step 2</h2>\n<p>Create the decipher function. This is fundamentally the same with the only difference being the fact that we subtract instead of adding the letters.</p>\n<h2>Step 3</h2>\n<p>Output these results. :)</p>\n<h2>Conclusion</h2>\n<p>In essence this is a Caeser's cipher with the only difference being the fact that we allow out key's character index to rotate instead of defining a fixed rotation. As you can see, this is why the Vigenere cipher can be considered a string of Caesar ciphers.</p>","frontmatter":{"title":"Vigenere Cipher","subtitle":"The Vigenere Cipher Broken down in Python","date":"September, 07, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"vigenere_cipher.jpg","thumbnail":"vigenere_cipher.jpg","teaser":"vigenere_cipher.jpg","credit":"MTU","creditlink":"www.cs.mtu.edu"},"path":"/tech/vigenere-cipher","tags":["algorithms","puzzles","ciphers"],"excerpt":"The Vigenere cipher is likely the the most secure ciphers out there. It builds on the principle of the Caesar cipher yet provides a decent way to avoid the easy to solve shift problems. The basic gist of this cipher is we have both a message and a key. The key can be any length, but you must repeat the key for the length of our message to get this to work"}}},"pageContext":{"prev":{"html":"<p>When creating Plain Old Java Objects (POJOs) in eith Android or Java, more specifically Java, the aim is to be able to <em>model</em> our data in a certain way. To enable easier addition to an Adapter or a database, even easier retrieval from a database using <strong>Jackson</strong> library (what Firebase uses to be able to store and retrieve data).</p>\n<p>It is best practice to model data in a specific way using POJO as it allows cleaner code and one also can be able to determine what exactly one object will contain. Say you are storing Employee data. An employee will obviously have data such as <em>name</em>, <em>phone</em> and <em>address</em>. These should be modelled to enable proper structure of each record we will be retrieving from an API (if creating for Android).</p>\n<p>Normally, typically, the model will look like this:</p>\n<pre><code class=\"language-java\">    public class Employee{\n        private String name;\n        private int phone;\n        private ArrayList&#x3C;String> address;\n\n        public Employee(String name, int phone, ArrayList&#x3C;String> address) {\n            this.name = name;\n            this.phone = phone;\n            this.address = address;\n        }\n\n        public ArrayList&#x3C;String> getAddress() {\n            if (!(address == null))\n                return address;\n            else\n                return new ArrayList&#x3C;String>();\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public String getAge() {\n            return age;\n        }\n    }\n</code></pre>\n<blockquote>\n<p>This is a typical POJO with <em>fields</em>, a <em>constructor</em> and <em>access methods</em>.</p>\n</blockquote>\n<p>In Android we know that we cannot just pass objects to activities. The objects must be either implements of <strong>Serializable</strong> or <strong>Parcelable</strong> interface to do this. This is where the problem with this class comes in. When trying to pass this object to any other activity it will pose a bit of a problem, of course there a work-arounds, but why stress yourself? KISS.</p>\n<h2>Enter Serializable and Parcelable</h2>\n<p>They both do what you expect them to do. They have similarities, but are not entirely the same.</p>\n<p><em>Serializable</em> is a standard <strong>Java</strong> interface. You simply mark a class Serializable by implementing the interface, and Java will automatically serialize it in certain situations.</p>\n<p><em>Parcelable</em> is an <strong>Android</strong> specific interface where you implement the serialization yourself. It was created to be far more efficient than Serializable, and to get around some problems with the default Java serialization scheme.</p>\n<h3>Serializable</h3>\n<p>As afformentioned serializable is a standard Java interface. You can just implement Serializable interface and add override methods.The problem with this approach is that <strong>reflection</strong> is used and it is a slow process. This method creates a lot of temporary objects and cause quite a bit of garbage collection. However, a serializable interface is easier to implement.</p>\n<pre><code class=\"language-java\">    public class Employee extends Serializable{\n        private String name;\n        private int phone;\n        private ArrayList&#x3C;String> address;\n\n        public Employee(String name, int phone, ArrayList&#x3C;String> address) {\n            super();\n            this.name = name;\n            this.phone = phone;\n            this.address = address;\n        }\n\n        public ArrayList&#x3C;String> getAddress() {\n            if (!(address == null))\n                return address;\n            else\n                return new ArrayList&#x3C;String>();\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public String getAge() {\n            return age;\n        }\n    }\n</code></pre>\n<blockquote>\n<p>Same implementation of Employee Object with the only differnce being its implementation. Notice the <code>super()</code> in the constructor.</p>\n</blockquote>\n<p>Say you have initialized Employee objects like so:</p>\n<pre><code class=\"language-java\">//Employee instance\nEmployee mEmployee = new Employee(\"name\",12345679,\"Address array here\");\n\n//Passing MyObjects instance via intent\nIntent mIntent = new Intent(FromActivity.this, ToActivity.class);\nmIntent.putExtra(\"UniqueKey\", mEmployee);\nstartActivity(mIntent);\n</code></pre>\n<blockquote>\n<p>This creates an instance of the Employee object, adds it to an intent and starts the next activity.</p>\n</blockquote>\n<p>In another class, we obtain the object.</p>\n<pre><code class=\"language-java\">Intent mIntent = getIntent();\nEmployee mEmployee = (Employee) mIntent.getSerializableExtra(\"UniqueKey\");\n</code></pre>\n<blockquote>\n<p>This obtains the object from the intent and casts it to Employee object.\nAllowing you to do as you please in the next activity with the obtain object.</p>\n</blockquote>\n<h3>Parcelable</h3>\n<p>Parcelable process is much faster than serializable. One of the reasons for this is that we are being explicit about the serialization process instead of using reflection to infer it. It also stands to reason that the code has been heavily optimized for this purpose.</p>\n<p>Using the same Employee class but implementing the Parcelable interface.</p>\n<pre><code class=\"language-java\">    import java.util.ArrayList;\n    import android.os.Parcel;\n    import android.os.Parcelable;\n\n    public class Employee extends Parcelable{\n        private String name;\n        private int phone;\n        private ArrayList&#x3C;String> address;\n\n        public Employee(String name, int phone, ArrayList&#x3C;String> address) {\n            this.name = name;\n            this.phone = phone;\n            this.address = address;\n        }\n\n        public Employee(Parcel source){\n            phone = source.readInt();\n            name = source.readString();\n            address = source.createStringArrayList();\n        }\n\n        @Override\n        public int describeContents() {\n            return 0;\n        }\n\n        @Override\n        public void writeToParcel(Parcel dest, int flags) {\n            dest.writeInt(phone);\n            dest.writeString(name);\n            dest.writeStringList(address);\n        }\n\n        public static final Creator&#x3C;Employee> CREATOR = new Creator&#x3C;Employee>() {\n\n        @Override\n        public Employee[] newArray(int size) {\n            return new Employee[size];\n        }\n\n        @Override\n        public Employee createFromParcel(Parcel source) {\n            return new Employee(source);\n        }\n        };\n\n        public ArrayList&#x3C;String> getAddress() {\n            if (!(address == null))\n                return address;\n            else\n                return new ArrayList&#x3C;String>();\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public String getAge() {\n            return age;\n        }\n    }\n</code></pre>\n<p>Using the same process of creating an instance of the <code>Employee</code> Object and passing it to an intent.</p>\n<pre><code class=\"language-java\">    Employee employee = new Employee(\"name\",\"age\",\"Address array here\");\n\n    //Passing MyOjects instance\n    Intent mIntent = new Intent(FromActivity.this, ToActivity.class);\n    mIntent.putExtra(\"UniqueKey\", employee);\n    startActivity(mIntent);\n\n    //Getting MyObjects instance in another activity\n    Intent mIntent = getIntent();\n    Employee workorder = (Employee) mIntent.getParcelable(\"UniqueKey\");\n\n    //You can pass Arraylist of Parceble obect as below\n    //Array of MyObjects\n    ArrayList&#x3C;Employee> mEmployees;\n\n    //Passing Employee instance\n    Intent mIntent = new Intent(FromActivity.this, ToActivity.class);\n    mIntent.putParcelableArrayListExtra(\"UniqueKey\", mEmployees);\n    startActivity(mIntent);\n\n    // in another activity\n    //Getting Employee instance\n    Intent mIntent = getIntent();\n    ArrayList&#x3C;Employee> mEmployees = mIntent.getParcelableArrayList(\"UniqueKey\");\n</code></pre>\n<h2>In Conclusion</h2>\n<ol>\n<li>Parcelable is faster than serializable interface</li>\n<li>Parcelable interface takes more time for implemetation compared to serializable interface</li>\n<li>serializable interface is easier to implement</li>\n<li>serializable interface create a lot of temporary objects and cause quite a bit of garbage collection</li>\n<li>Parcelable array can be pass via Intent in android</li>\n</ol>\n<p>These are just some of the differences between the two interfaces and of course there is not standard way, however it is always good to have the option of switching between the two.</p>","id":"d1782561-832c-5915-aa3b-797fd8370f7a","timeToRead":5,"frontmatter":{"title":"Serializable and Parcelable","subtitle":"Difference between Serializable Java interface and Android Parcelable interface","excerpt":"When creating Plain Old Java Objects (POJOs) in eith Android or Java, more specifically Java, the aim is to be able to _model_ our data in a certain way. To enable easier addition to an Adapter or a database, even easier retrieval from a database using **Jackson** library (what Firebase uses to be able to store and retrieve data).","path":"/tech/serializable-parcelable","category":"tech","date":"September 24, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"parcelable_vs_serializable.jpg","thumbnail":"parcelable_vs_serializable.jpg","teaser":"parcelable_vs_serializable.jpg","credit":null,"creditlink":null},"tags":["Android","Serializable","Parcelable"],"published":true}},"next":{"html":"<p>NumPy is <em>Numerical Python</em> in full. A very powerful library for performing, well you guessed it, vector arithmetic. For those who shall continue on with Data Science using Python, I suggest you have a look at the NumPy package. It is a very powerful tool that will most definitely make your life that much simpler.</p>\n<p>A basic example of the use of NumPy</p>\n<pre><code class=\"language-python\">from numpy import array\n\nbaseball = [12, 46, 489, 46, 5, 312, 31, 2, 3, 12, 31, 3, 13, 1, 31, 3, 13, 13, 1, 31, 313, 1, 31, 189, 4, 4, 31, 564,\n            9, 19, 416, 49, 498, 4984, 1984]\n\nprint(type(array(baseball)))\n&#x3C;class 'numpy.ndarray'>\n\nprint(type(baseball))\n&#x3C;class 'list'>\n</code></pre>\n<blockquote>\n<p>The 2 types are not similar, but almost the same operations can be performed on them.</p>\n</blockquote>\n<h2>Performing simple operations</h2>\n<p>Say for example you get the heights of each football player in England. You call the Barclay's Premier League and since you are a major fan and a major stakeholder in Barclays(They don't just send this data to everyone, I tried), they send you the data of 1000 players' heights as a list. Sadly, they are all in inches and you do not use inches, but rather meters. You could use a <code>for loop</code> converting each to meters and multiplying by 0.0254. This will work, but it will take quite a while to execute.</p>\n<pre><code class=\"language-python\">heights = [78,45,70,80,75,84,76,84,71,72,73,84,75,88,79,...]\nheights_m = [x * 0.0254 for x in heights]\nprint(heights_m)\n</code></pre>\n<blockquote>\n<p>This uses a list comprehension to obtain a new list of the newly converted heights to meters.</p>\n</blockquote>\n<p>NumPy on the other hand makes this process very simple and efficient. You will not have to use a for loop to perform such an operation.</p>\n<pre><code class=\"language-python\">from numpy import array\nheights = [78,45,70,80,75,84,76,84,71,72,73,84,75,88,79,...]\n\nheights_m = array(heights) * 0.0254\nprint(m)\n</code></pre>\n<blockquote>\n<p>The output will be the same. NumPy array function simply took in the list of heights and multiplied each to 0.0254. No loop used.</p>\n</blockquote>\n<p>The same could apply for weights. Say we now get weight data from the BPL. Unfortunately, again, they send data in pounds. We don't use pounds, instead we decide to use <em>kilograms</em>. we could do the same for loop above instead replace the <code>heights</code> with weights and instead use <code>0.453592</code> to perform the conversion. Alternatively, you guessed it, we could use <code>array</code> function from numpy to perform the operation such that it becomes <code>array(weights) * 0.453592</code> which makes our life that much easier.</p>\n<p>Maybe you will say. 'So what, the results are the same, so why use NumPy?'. True, they are the same, so the used of NumPy seems a little too much.</p>\n<p>This is why.</p>\n<p>Say, now you want to calculate the <strong>Body Mass Index</strong> (BMI) of each player in the BPL, well anonymously, considering the BPL did not send names attached to the data. This would require you to perform a loop within a loop. This is because to calculate the BMI we use this formula:</p>\n<pre><code class=\"language-plain\">BMI = weight (in kilograms)\n       height (in meters)^2\n</code></pre>\n<p>Now, imagine performing a for loop in the two lists we now have <code>weights_kg</code> and <code>heights_m</code>. If you were to use standart Python this would be the most probable way to perform the operation:</p>\n<pre><code class=\"language-python\">bmi = []\nm = list(zip(weights_kg, heights_m))\nfor x, y in m:\n    bmi.append(x/y**2)\n\nprint(bmi)\n</code></pre>\n<blockquote>\n<p><code>zip</code> function creats an iterator that aggregates elements from each of the iterables.</p>\n</blockquote>\n<p>With NumPy you can easily do the same with fewer lines and with less of a headache:</p>\n<pre><code class=\"language-python\">bmi = weights_m / heights_m **2\nprint(bmi)\n</code></pre>\n<blockquote>\n<p>This is after the weights and heights lists have been passed as arguments to the <code>array</code> function of the NumPy module.</p>\n</blockquote>\n<p>The results are the same, but it is more intuitive with NumPy, you can not perform the same operation with standard Python. So doint this : <code>bmi = weights_m / heights_m **2</code> without passing the <code>weights_m</code> and <code>heights_kg</code> as arguments in NumPy's array function will cause an error. Go ahead and try that :).</p>\n<h2>Subsetting</h2>\n<p>Lists in Python can be <em>subsetted</em>, if that is a word at all. By subsetting a Python list this is what I mean:</p>\n<pre><code class=\"language-python\">x = [4 , 9 , 6, 3, 1]\nx[1]\nimport numpy as np\ny = np.array(x)\ny[1]\n</code></pre>\n<blockquote>\n<p>This is subsetting using squre brackets, this applies to both NumPy and standard Python lists</p>\n</blockquote>\n<p>But NumPy has something special about subsetting that the standard Python lists do not have.\nFor Numpy specifically, you can also use boolean Numpy arrays:</p>\n<pre><code class=\"language-python\">high = y > 5\ny[high]\n</code></pre>\n<p>Now, to put it all together:</p>\n<pre><code class=\"language-python\"># height and weight are available as a regular lists\n\n# Import numpy\nimport numpy as np\n\n# Calculate the BMI: bmi\nnp_height_m = np.array(height) * 0.0254\nnp_weight_kg = np.array(weight) * 0.453592\nbmi = np_weight_kg / np_height_m ** 2\n\n# Create the light array\nlight = np.array(bmi) &#x3C; 21\n\n# Print out light\nprint(light)\n\n# Print out BMIs of all baseball players whose BMI is below 21\nprint(bmi[light])\n</code></pre>\n<p>Numpy is great to do vector arithmetic. If you compare its functionality with regular Python lists, however, some things have changed.</p>\n<p>First of all, Numpy arrays cannot contain elements with different types. If you try to build such a list, some of the elments' types are changed to end up with a homogenous list. This is known as type coercion.</p>\n<p>Second, the typical arithmetic operators, such as +, -, * and / have a different meaning for regular Python lists and Numpy arrays.</p>\n<p>Have a look at this line of code:</p>\n<pre><code class=\"language-python\">>>>np.array([True, 1, 2]) + np.array([3, 4, False])\narray([4, 5, 2])\n</code></pre>\n<p>Python lists and Numpy arrays sometimes behave differently. Luckily, there are still certainties in this world. For example, subsetting (using the square bracket notation on lists or arrays) works exactly the same. To see this for yourself, try the following lines of code in the IPython Shell:</p>\n<pre><code class=\"language-python\">x = [\"a\", \"b\", \"c\"]\nx[1]\n\nnp_x = np.array(x)\nnp_x[1]\n# height and weight are available as a regular lists\n\n# Import numpy\nimport numpy as np\n\n# Store weight and height lists as numpy arrays\nnp_weight = np.array(weight)\nnp_height = np.array(height)\n\n# Print out the weight at index 50\nprint(np_weight[50])\n\n# Print out sub-array of np_height: index 100 up to and including index 11077\nprint(np_height[100:111])\n</code></pre>\n<h2>Conclusion</h2>\n<p>Of course there is more to the NumPy module that I have not covered, this was and is to cite that the NumPy array and the Python Lists are the same but you can perform certain operations on NumPy arrays that you can not perform on Python lists. NumPy is a powerful library to uses especially if you will become a data scientist of use if for <strong>Big Data</strong>.</p>","id":"8d3c99f8-70ac-5fb9-b281-8b1d1e53a96f","timeToRead":5,"frontmatter":{"title":"NumPy","subtitle":"NumPy Arrays and Python Lists","excerpt":"NumPy is _Numerical Python_ in full. A very powerful library for performing, well you guessed it, vector arithmetic. For those who shall continue on with Data Science using Python, I suggest you have a look at the NumPy package. It is a very powerful tool that will most definitely make your life that much simpler.","path":"/tech/numpy","category":"tech","date":"September 03, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"numpy.jpg","thumbnail":"numpy.jpg","teaser":"numpy.jpg","credit":"NumPy","creditlink":"http://www.numpy.org/"},"tags":["Python","Numpy","data"],"published":true}}}}}