{"componentChunkName":"component---src-templates-blogs-blog-post-jsx","path":"/tech/bottom-up-algorithms","result":{"data":{"markdownRemark":{"html":"<p>Going bottom-up is a way to avoid recursion, saving the memory cost that recursion incurs when it builds up the call stack.</p>\n<p>Put simply, a bottom-up algorithm \"starts from the beginning,\" while a recursive algorithm often \"starts from the end and works backwards.\"</p>\n<p>For example, if we wanted to multiply all the numbers in the range 1...n1...n, we could use this cute, top-down, recursive one-liner:</p>\n<pre><code class=\"language-python\">def product_1_to_n(n):\n    # we assume n >= 1\n    return n * product_1_to_n(n-1) if n > 1 else 1\n</code></pre>\n<p>This approach has a problem: it builds up a call stack of size O(n)O(n), which makes our total memory cost O(n)O(n). This makes it vulnerable to a stack overflow error, where the call stack gets too big and runs out of space.</p>\n<p>To avoid this, we can instead go bottom-up:</p>\n<pre><code class=\"language-python\">def product_1_to_n(n):\n    # we assume n >= 1\n\n    result = 1\n    for num in range(1, n+1):\n        result *= num\n\n    return result\n</code></pre>\n<p>This approach uses O(1)O(1) space (O(n)O(n) time).</p>\n<blockquote>\n<p>Some compilers and interpreters will do what's called tail call optimization (TCO), where it can optimize some recursive functions to avoid building up a tall call stack. Python and Java decidedly do not use TCO. Some Ruby implementations do, but most don't. Some C implementations do, and the JavaScript spec recently allowed TCO. Scheme is one of the few languages that guarantee TCO in all implementations. In general, best not to assume your compiler/interpreter will do this work for you.</p>\n</blockquote>\n<p>Going bottom-up is a common strategy for dynamic programming problems, which are problems where the solution is composed of solutions to the same problem with smaller inputs (as with the fibonacci problem, above). The other common strategy for dynamic programming problems is memoization.</p>","frontmatter":{"title":"Bottom up algorithms","subtitle":"A short description on bottom up algorithms","date":"May, 18, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":null,"thumbnail":"bottom-up.png","teaser":"bottom-up.png","credit":null,"creditlink":null},"path":"/tech/bottom-up-algorithms","tags":["data-structures","algorithms"],"excerpt":"Going bottom-up is a way to avoid recursion, saving the memory cost that recursion incurs when it builds up the call stack."}}},"pageContext":{"prev":{"html":"<p>It has been a while since my last blog post. And since my last blog post I set out on a journey to learn and grow in learning new technologies and understanding how they work. What really made my adventure exciting was when I discovered a little jewel called Kotlin.\nNow, I know it has become a hot topic with almost everyone talking about Kotlin, especially in the Android developer circles and community. Everyone is talking about the new kid on the block (despite the language not actually being that new).</p>\n<p>Its recent adoption into creation of mobile applications changes how Android applications are being created, introducing functional programming, extension functions and a huge amount in number of lines written, I can understand why people are ready to jump straight into Kotlin development.</p>\n<p>Personally, I am not a Java developer and I always had a bit of a struggle from time to time when it came to Java, especially the verbosity of the language. I appreciate the strictness of the language because it means you have to explicit about what you are trying to achieve and not expect the compiler to read your thoughts. This is quite handy when it comes to building robust applications that will <em>\"stand the test of time\"</em>. Kotlin strives to be less verbose and still perform just as well as Java in the JVM. The fact that it is 100% interroperable with Java means that it can be used side by side and your users will be none the wiser as there will be no difference in how the application performs.</p>\n<p>The reason I joined the <em>Kotlin bandwagon</em> was because I was hungering to learn something new and Kotlin happened to just land in my radar. Admittedly, I started learning Ruby before Kotlin and what caught my eye with Kotlin was how it brought aspects that I was already familiar with in Python, JavaScript, Java and a bit of Ruby. It made me happy when writing code for Android applications again, I did not cringe when I would think of the number of lines of code I had to write in Java to create an application.</p>\n<p>This is not to say that Java is going anywhere, it is still a fantastic language that many systems and organisations still use and will not be abandoned just because there is a new shiny toy that comes with all the fantastic features of a modern language.</p>\n<p>What really intrigued me with Kotlin was how I felt like I had more control and flexibility as to how I wrote code for Android. I have to say that I have not tried writing Kotlin code to be used for server side work or front end work (Kotlin can be compiled to JavaScript, read <a href=\"https://kotlinlang.org/docs/reference/js-overview.html\">here</a> for more), considering that that is what it was intended for in the very beginning, this is because I prefer doing that in Python(<a href=\"http://flask.pocoo.org/\">Flask</a>) and front end work in JavaScript(<a href=\"https://facebook.github.io/react/\">ReactJs</a> for that matter). Just because I love the seperation in my head.</p>\n<p>On to my point, there are subtle (or not so subtle) differences when it comes to Kotlin and Java, and there are too many to highlight here, so I shall highlight only those which I felt really helped me write much more concise, readable and extensible code for Android.</p>\n<h3>Extension functions</h3>\n<p>This for me is a huge win when it comes to writing Android applications in Kotlin. It not only reduces boilerplate code, but also greatly makes code much much more readable. I shall give a use-case:</p>\n<p>Say, you want to create a rotation animation for an image, which will be a progress spinner of sorts. To do this, you will need to do the following in Java.</p>\n<pre><code class=\"language-java\">ImageView progressImg = findViewById&#x3C;ImageView>(R.id.rotateImag)\nRotateAnimation rotateAnimation = RotateAnimation(0F, 360f, Animation.RELATIVE_TO_SELF,\n            0.5f, Animation.RELATIVE_TO_SELF, 0.5f)\nrotateAnimation.setInterpolator(new LinearInterpolator())\nrotateAnimation.setDuration(800)\nrotateAnimation.setRepeatCount(Animation.INFINITE)\nprogressImg.setAnimation(rotateAnimation)\n</code></pre>\n<blockquote>\n<p>Java implementation for a Rotation Animation</p>\n</blockquote>\n<pre><code class=\"language-kotlin\">fun View.createRotateAnimation(duration: Long) {\n    val rotateAnimation = RotateAnimation(0F, 360f, Animation.RELATIVE_TO_SELF,\n                0.5f, Animation.RELATIVE_TO_SELF, 0.5f)\n    rotateAnimation.interpolator = LinearInterpolator()\n    rotateAnimation.duration = duration\n    rotateAnimation.repeatCount = Animation.INFINITE\n    this.startAnimation(rotateAnimation)\n}\n</code></pre>\n<blockquote>\n<p>Kotlin implementation for creating a rotation animation on a View</p>\n</blockquote>\n<p>Now, it may not seem like much, but think about how many times you will have to create the rotation implementation in Java. You may end up creating a static method in a final class just to reduce the boilerplate code written.</p>\n<pre><code class=\"language-java\">final class AnimUtils{\n    public static RotateAnimation createRotationAnimation(){\n        RotateAnimation rotateAnimation = RotateAnimation(0F, 360f, Animation.RELATIVE_TO_SELF,\n                    0.5f, Animation.RELATIVE_TO_SELF, 0.5f);\n        rotateAnimation.setInterpolator(new LinearInterpolator());\n        rotateAnimation.setDuration(800);\n        rotateAnimation.setRepeatCount(Animation.INFINITE);\n        return rotateAnimation;\n    }\n}\n\n//... somewhere in your code\nprogressImg.setAnimation(AnimUtils.createRotationAnimation)\n</code></pre>\n<blockquote>\n<p>Now, this may not be an issue per-say, I mean you have created an easily accessible method to all classes that may need to use it.</p>\n</blockquote>\n<p>Now, how about Kotlin?\nThe fact that we can create extension functions, which in essence is just adding a function to a class that we do not own. In this case we are simply adding a rotation animation to the View class and this allows use to animate any View by simply calling this function as if it belongs to the Android SDK.</p>\n<p>A simple use case</p>\n<pre><code class=\"language-kotlin\">//... assuming you have already initialized your ImageView/ or view\nprogressImg.createRotateAnimation(800)\n</code></pre>\n<p>And that is all! Now with this you do not have to reference a class' static method in order to run a function. This allows more cleaner and clearer code and of course means you can add much more to the function if the need ever arose.</p>\n<h3>Data Classes</h3>\n<p>Now this for me is another big win. In Java, we usually need to create POJO(Plain Old Java Objects or Java Beans) to represent certain data items or objects in data structures of applications. Usually they could end up being 100s of lines of code involving <code>hashCodes()</code>, <code>toString()</code> and getter and setter methods. Say for example we want to create a data structure involving a Person object</p>\n<pre><code class=\"language-java\">class Person{\n    private String firstName;\n    private String lastName;\n    private int age;\n    private String gender;\n\n    public Person(String firstName, String lastName, int age, String gender){\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.age = age;\n        this.gender = gender;\n    }\n\n    public String getFirstName(){\n        return firstName;\n    }\n\n    public void setFirstName(String name){\n        this.firstName = name;\n    }\n\n    public String getLastName(){\n        return lastName;\n    }\n\n    public void setlastName(name){\n        this.lastName = name\n    }\n\n    public int getAge(){\n        return age;\n    }\n\n    public void setAge(age){\n        this.age = age;\n    }\n\n    public String getGender(){\n        return gender;\n    }\n\n    public void setGender(gender){\n        this.gender = gender;\n    }\n\n    // hashCodes and toString methods\n}\n</code></pre>\n<blockquote>\n<p>Person object in Java</p>\n</blockquote>\n<p>Now, the same in Kotlin is executed in 1 line of code</p>\n<pre><code class=\"language-kotlin\">data class Person(var firstName : String, var lastName : String, var age : Int, var gender : String)\n// the toString, errorCode, hashCode and even copy are autogenerated\n</code></pre>\n<blockquote>\n<p>Person object in Kotlin</p>\n</blockquote>\n<p>This not only reduces boiler plate code, but ensures that I concentrate on how this object will be used, instead of constantly thinking whether I correctly implemented a getter/setter method to the class or whether there is a <code>toString()</code> method implemented so I do not get an odd looking memory location hex String.</p>\n<h3>Named and Optional Arguments</h3>\n<p>Now this will be the final thing I shall write about in this post. Named arguments in functions are common in languages such as <code>Python</code>. This allows us to, for example refer to a specific argument for a given parameter instead of trying to mentally remember if position two takes a <code>Double</code> or a <code>Long</code> given that there are 5 parameters to pass in into the given function.</p>\n<p>I shall write a simple Kotlin function that allows optional arguments and which in turn will deal with named arguments. Say, you are writing a function that has 5 arguments of which 2 are optional(have default values)</p>\n<pre><code class=\"language-kotlin\">// calculates distance of object from another object given its coordinates and the speed in which it is moving\nfun calculateDistance(x : Int, y: Int, z: Int, speed: Double = 0.0, other : Any) : Int{\n    val dx = other.x - x\n    val dy = other.y - y\n    val dz = other.z - z\n    val ds = if(speed != 0.0) other.speed - speed else speed\n    // some awesome distance calculating algorithm\n\n    return distance\n}\n\n// usage, PositionElement is a simple class that randomly places the object on a plane\n// given its x, y and z co-ordinates and its speed\nval A = PositionElement(5, 6, 15, 8.5)\nval B = PositionElement(3, 8, 1, 19.5)\n\n// calculate the distance of A from B\ndistanceForAFromB = calculateDistance(x = A.x, y = A.y, z = A.z, speed = A.speed, other = B)\n\n// assuming that A has no speed\nval A = PositionElement(5, 6, 15, 0.0)\ndistanceForAFromB = calculateDistance(x = A.x, y = A.y, z = A.z, other = B)\n</code></pre>\n<p>As you can see above, the named arguments help in determining what parameter is being passed where in a function invocation and allows for easier calculation and making your code much much more readable and also of course allows you to not keep switching files to make sure the correct parameter is passed.</p>\n<h4>Conclusion</h4>\n<p>I am still on this Kotlin journey and I have to say that I am so far pleased with the fact I have been able to write much much more concise code as compare to before. There is so much more to Kotlin than meets the eye and I am so far please with the language and how it brings a sense of happiness when writing code in Kotlin.</p>","id":"775a977d-0892-50c5-b5df-3cf44ec7dcb8","timeToRead":7,"frontmatter":{"title":"My Journey in Kotlin thus far","subtitle":"Kotlin adventures","excerpt":"It has been a while since my last blog post. And since my last blog post I set out on a journey to learn and grow in learning new technologies and understanding how they work. What really made my adventure exciting was when I discovered a little jewel called Kotlin.","path":"/tech/kotlin-adventures","category":"tech","date":"September 10, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"kotlin_feature.png","thumbnail":"kotlin_thumb.jpg","teaser":"kotlin_thumb.jpg","credit":"Kotlinlang.org","creditlink":null},"tags":["Android","Java","language","kotlin"],"published":true}},"next":{"html":"<p>A binary tree is a tree where every node has two or fewer children. The children are usually called left and right.</p>\n<pre><code class=\"language-python\">class BinaryTreeNode(object):\n\n    def __init__(self, value):\n        self.value = value\n        self.left  = None\n        self.right = None\n</code></pre>\n<p>This lets us build a structure like this:</p>\n<p><img src=\"https://www.interviewcake.com/images/svgs/binary_tree__depth_5.svg?bust=145\"></p>\n<blockquote>\n<p>A tree represented by cirlces connected with lines.</p>\n</blockquote>\n<p>The root node is on top, and connects to 2 children below it. Each of those children connect to 2 children below them, which all connect to their own 2 children, which all connect to their own 2 children.</p>\n<p>That particular example is special because every level of the tree is completely full. There are no \"gaps.\" We call this kind of tree \"perfect.\"</p>\n<p>Binary trees have a few interesting properties when they're perfect:</p>\n<ol>\n<li><strong>Property 1: the number of total nodes on each \"level\" doubles as we move down the tree.</strong></li>\n</ol>\n<p><img src=\"https://www.interviewcake.com/images/svgs/binary_tree__depth_5_with_number_of_nodes_labelled.svg?bust=145\"></p>\n<p>A binary tree with 5 rows of nodes. The root node is on top, and every node has 2 children in the row below. Each row is labelled with the number of nodes in the row, which doubles from the top down: 1, 2, 4, 8, 16.</p>\n<ol start=\"2\">\n<li><strong>Property 2: the number of nodes on the last level is equal to the sum of the number of nodes on all other levels (plus 1).</strong></li>\n</ol>\n<p>In other words, about half of our nodes are on the last level.</p>\n<p>Let's call the number of nodes <strong>n</strong>, and the height of the tree <strong>h</strong>. <strong>h</strong> can also be thought of as the \"number of levels.\"</p>\n<p>If we had <em>h</em>, how could we calculate <em>n</em>?</p>\n<p>Let's just add up the number of nodes on each level! How many nodes are on each level?</p>\n<p>If we zero-index the levels, the number of nodes on the <em>x<sup>th</sup></em> level is exactly 2<sup>x</sup></p>\n<ol>\n<li>Level 0: 2<sup>0</sup> nodes,</li>\n<li>Level 1: 2<sup>1</sup> nodes,</li>\n<li>Level 2: 2<sup>2</sup> nodes,</li>\n<li>Level 3: 2<sup>3</sup> nodes,</li>\n<li>etc</li>\n</ol>\n<p>So our total number of nodes is:</p>\n<p>n = 2<sup>0</sup> + 2<sup>1</sup> + 2<sup>2</sup> + 2<sup>3</sup> + ... + 2<sup>{h-1}</sup></p>\n<blockquote>\n<p>Why only up to 2<sup>{h-1}</sup>? Notice that we started counting our levels at 0. So if we have h levels in total, the last level is actually the \"h-1\"-th level. That means the number of nodes on the last level is 2<sup>{h-1}</sup>.</p>\n</blockquote>\n<p>But we can simplify. <em>Property 2</em> tells us that the number of nodes on the last level is (1 more than) half of the total number of nodes, so we can just take the number of nodes on the last level, multiply it by 2, and subtract 1 to get the number of nodes overall. We know the number of nodes on the last level is 2<sup>h-1</sup>, So:</p>\n<pre>\nn = 2<sup>h-1</sup> * 2 - 1\n\nn = 2<sup>h-1</sup> * 2 - 1\n\nn = 2<sup>h-1</sup> * 2^1 - 1\n\nn = 2<sup>h-1+1</sup>- 1\n\nn = 2<sup>h</sup> - 1\n</pre>\n<p>So that's how we can go from h to n. What about the other direction?</p>\n<p>We need to bring the h down from the exponent. That's what logs are for!</p>\n<p>First, some quick review. log<sub>10</sub>(100) simply means, <strong>What power must you raise 10 to in order to get 100?</strong>. Which is 2, because 10<sup>2</sup> = 100</p>\n<p>We can use logs in algebra to bring variables down from exponents by exploiting the fact that we can simplify log<sub>10</sub>(10<sup>2</sup>)</p>\n<p>What power must we raise 10 to in order to get 10<sup>2</sup>? That's easy—it's 2.</p>\n<p>So in this case we can take the log<sub>2</sub> of both sides:</p>\n<pre>\nn = 2<sup>h</sup> - 1\nn + 1 = 2<sup>h</sup>\nlog<sub>2</sub>((n+1)) = log<sub>2</sub>(2<sup>h</sup>)\nlog<sub>2</sub>(n+1) = h\n</pre>\n<p>So that's the relationship between height and total nodes in a perfect binary tree.</p>","id":"7bf34539-e836-56e6-a479-b697b669319d","timeToRead":3,"frontmatter":{"title":"Binary Trees Heights","subtitle":"Relationship between a binary tree's height and its number of nodes","excerpt":"A binary tree is a tree where every node has two or fewer children. The children are usually called left and right.","path":"/tech/binary-tree-heights","category":"tech","date":"May 17, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":null,"thumbnail":"binary_tree_depth.svg","teaser":"binary_tree_depth.svg","credit":null,"creditlink":null},"tags":["data-structures","binary-tree"],"published":true}}}}}