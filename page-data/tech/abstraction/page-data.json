{"componentChunkName":"component---src-templates-blogs-blog-post-jsx","path":"/tech/abstraction","result":{"data":{"markdownRemark":{"html":"<p>Abstraction is one of the principles of Object Oriented Programming where a programmer hides/reduces information of an object and only reveals the relevant information at the time. It works alongside <em>inheritance</em> and <em>encapsulation</em>. This is done in order to reduce complexity and ensure efficiency.</p>\n<p>In the process of abstraction, the programmer tries to ensure that the entity is named in a manner that will make sense and that it will have all the relevant aspects included and none of the extraneous ones.</p>\n<p>A practical example is a car. Not many people are concerned with the inner workings of a motor vehicle, save for mechanics, engineers and car enthusiasts. A car is an object that has certail states and behaviours. It has states such as <em>black</em> paint, <em>engine size</em> and <em>number of doors</em> etc. The behaviours are <em>accelerate</em>, <em>decelerate</em> and <em>stop</em>, just to mention a few. Now, for the driver to intaract with the car, they have to do so through the steering wheel, the gears and the peddles. These are the <strong>interfaces</strong>.</p>\n<p>These are what act as a go-between the driver and the internal components of the car. This is where abstraction steps in. The driver does not particularly know what is going on in the engine when they accelerate and when they stop. All they get to interact with are the steering wheel, pedals and various gauges on the car dashboard. Abstraction basically gives them this relevant information as it is what is needed at the time of driving. All the driver needs to know at all times when they are driving are the fuel gauge, the speed they are on and car temperature. They do not need to know about how the car measures heat every second or how it gauges how much petrol is left in the tank or even how it calculates the current speed. This information is hidden in the internal components of the car (<em>encapsulation</em>) and is queried (say, you take your car apart and study it) only when need be. So at all times only relevant information is displayed(<em>abstraction</em>).</p>\n<p>This, as you can see, reduces the complexity when driving said car and allows the driver to only intaract with what they need to interact with at the time of driving.</p>","frontmatter":{"title":"A Practical example of Abstraction","subtitle":"A more practical approach to abstraction in OOP","date":"July, 11, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"abstraction.jpg","thumbnail":"abstraction.jpg","teaser":"abstraction.jpg","credit":null,"creditlink":null},"path":"/tech/abstraction","tags":["encapsulation","objects","object oriented programming","abstraction"],"excerpt":"Abstraction in the real world."}}},"pageContext":{"prev":{"html":"<p>Algorithms are set to achieve a certain outcome. Sorting algoritms follow numerical order and usually has random access to an array. This means that it can access random indexes of an array to perform a sort.</p>\n<h1>Bubble Sort</h1>\n<p>Convinient for small data sets. Consider an array of elements such that:\nint[] arr = new int[]{14,33,27,10,33,19,42,44};\nThe array is not sorted. To sort this array, we compare 2 values at a time.\nSteps:</p>\n<ul>\n<li>compare 14 and 33, since 14 is less than 33, it remains in place</li>\n<li>next we compare 33 and 27, 27 is less than 33, hence we have to swap postions such that;\n<code>arr[1]</code> = 33 takes the place of <code>arr[2]</code> and vice versa.\nThe array now becomes:\n{14,27,33,10,33,19,48,44}</li>\n<li>The next comparison is now between 33 and 10. 10 is less than 33, so we swap positions as before.</li>\n<li>The process continues until all the elements in the array follow natural ordering.</li>\n</ul>\n<p>This is obviously convenient for small data sets as we are comparing 2 elements at a time. If the array was of length 50, it would take much longer to complete and would be inefficient. This is not what an ideal algorithm should achieve.</p>\n<pre><code class=\"language-java\">    /**\n     * @implNote\n     * set flag to true to begin first pass, initialize the step variable, create the temp variable\n     * within while loop, set the flag to false awaiting first pass\n     * record the steps taken in a variable called steps\n     * holds the temp value for the current element in array\n     * assign the current position of the array to the next element\n     * assign the next position of the array to the temp value\n     * set the flag to true to allow continuing of loop, record the steps taken\n     * @param toSort array to perform the bubble sort\n     * @return toSort the sorted array\n     * */\n    public static int[] bubbly(int[] toSort){\n        boolean flag = true;\n        int steps = 0;\n        int temp;\n        while(flag){\n            flag = false;\n            for(int x = 0; x &#x3C; toSort.length-1;x++){\n                if(toSort[x] > toSort[x+1]){\n                    steps++;\n                    temp = toSort[x];\n                    toSort[x] = toSort[x+1];\n                    toSort[x+1] = temp;\n                    flag = true;\n                }\n\n            }\n        }\n        System.out.println(String.valueOf(steps)+ \" steps taken\");\n        return toSort;\n    }\n\n    public static void main(String[] args){\n        int[] arr = new int[]{18,29,1,100,17};\n        int[] arrTwo = new int[]{100,16,33,48,60,21,80};\n        /*Bubble sort Ascending*/\n        System.out.println(Arrays.toString(bubbly(arr)));\n        System.out.println(Arrays.toString(bubbly(arrTwo)));\n        /*5 steps taken\n        [1, 17, 18, 29, 100]\n        9 steps taken\n        [16, 21, 33, 48, 60, 80, 100]*/\n    }\n</code></pre>\n<blockquote>\n<p>Demonstration of a bubble sort algorithm, sorting elements in ascending order</p>\n</blockquote>\n<p>Code snippet right <a href=\"https://github.com/BrianLusina/Java-Playground/blob/master/Toy%20Problems/src/SortingAlgorithms/BubbleSortDemo.java\">here</a>.</p>\n<h1>Merge Sort</h1>\n<p>Uses the <em>divide and conquer rule</em> it divides a problem into smaller parts until it reaches the simplest form possible. Then it rejoins the divided elements in a sorted format until it is a full list again. This sorting algorithm is mostly used in arrays.</p>\n<p>Consider this example\n27 10 12 25 34 16 15 31\ndivide it into two parts\n27 10 12 25 34 16 15 31\ndivide each part into two parts\n27 10 12 25 34 16 15 31\ndivide each part into two parts\n27 10 12 25 34 16 15 31</p>\n<p>merge (cleverly-!) parts</p>\n<p>10 27 12 25 16 34 15 31\nmerge parts\n10 12 25 27 15 16 31 34\nmerge parts into one\n10 12 15 16 25 27 31 34</p>\n<h1>Insertion Sort</h1>","id":"48df5b4a-6bf5-576e-a6a1-8408714e9881","timeToRead":2,"frontmatter":{"title":"Sorting Algorithms","subtitle":"Brief overview of some sorting algorithms","excerpt":"Algorithms are set to achieve a certain outcome. Sorting algoritms follow numerical order and usually has random access to an array. This means that it can access random indexes of an array to perform a sort.","path":"/tech/sorting-algorithms","category":"tech","date":"July 12, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"sorting-algorithms.png","thumbnail":"sorting-algorithms.png","teaser":"sorting-algorithms.png","credit":null,"creditlink":null},"tags":["algorithms","sorting algorithms","array"],"published":true}},"next":{"html":"<p>This post is a demonstration of the difference between post increment and pre increment of variables in Java. Post increment is usually denoted as <code>x++</code>, where the x is the variable in question, usually an integer, double or float. While pre-increment is addition denoted as <code>++x</code>.</p>\n<h1>Pre-increment</h1>\n<p>As the terms suggests, <em>PRE-increment</em> is the addition of a particular value before it is used. It is normally used when you want to use the incremented value of that particular variable. When the program encounters a pre-increment it increases the value of that variable in the memory then loads the expression.</p>\n<p>A simple demonstration:</p>\n<pre><code class=\"language-java\">public class PostAndPre {\n    public static void main(String[] args){\n        int x = 0;\n        for(int i = 0; i &#x3C; 10; i++){\n            System.out.printf(\"%d\\n\", ++x);\n            /*Output:\n            1 2 3 4 5 6 7 8 9 10 */\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<p>Demo of pre-increment</p>\n</blockquote>\n<p>The above variable <code>x</code> is instantiated as 0. The program encounters the variable <code>x</code> and increases the value by 1 before output of the result.</p>\n<p>This is equivalent to:</p>\n<pre><code class=\"language-Java\">        x = x + 1;\n        int y = x;\n        System.out.printf(\"%d\", y);\n</code></pre>\n<h1>Post-increment</h1>\n<p>The <em>post increment</em> uses the variable before increasing it. So in the case of <code>x++</code>, the variable will be 0, and will be used as is before it will be increased. This loads the value of that variable in memory, increases the variable and then continues reading the expression.</p>\n<pre><code class=\"language-java\">        int l = 0;\n        for(int i = 0; i &#x3C; 10; i++){\n            System.out.printf(\"%d \\t\", l++);\n            //output 0  1   2   3   4   5   6   7   8   9\n        }\n</code></pre>\n<blockquote>\n<p>Demo of post increment</p>\n</blockquote>\n<p>The above variable <code>l</code> is instantiated as 0 and will be output as 0, before the variable is increased.</p>\n<p>Code snippet can be found <a href=\"https://github.com/BrianLusina/Java-Playground/blob/master/Toy%20Problems/src/PostAndPre/PostAndPre.java\">here</a>.</p>","id":"67a4682f-f64b-5fd2-93e5-0b4dad47ab91","timeToRead":1,"frontmatter":{"title":"Difference between Post increment and pre increment of a variable","subtitle":"x++ and ++x","excerpt":"This post is a demonstration of the difference between post increment and pre increment of variables in Java. Post increment is usually denoted as `x++`, where the x is the variable in question, usually an integer, double or float. While pre-increment is addition denoted as `++x`.","path":"/tech/postadd-preadd","category":"tech","date":"July 06, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":null,"thumbnail":null,"teaser":null,"credit":null,"creditlink":null},"tags":["Post-increment","pre-increment"],"published":true}}}}}