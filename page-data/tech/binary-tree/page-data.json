{"componentChunkName":"component---src-templates-blogs-blog-post-jsx","path":"/tech/binary-tree","result":{"data":{"markdownRemark":{"html":"<p>Binary trees are part of a data structure known as <code>Trees</code>, yeah, I know, the forefathers of computer science and software engineering were quite creative. They were quite observant. Trees, more or less, look like trees, like the literal trees in nature. Now, that we have the most basic and almost worst analogy out there, what are binary trees?</p>\n<p>I shall give a basic and brief introduction into <code>binary trees</code>, this will assume that you have knowledge on tree data structures. Even if you don't, you can still read on, they are all pretty much related, so the knowledge is transferable.</p>\n<p>A binary tree is a <code>tree</code> where every node has 2 or fewer children. The children are usually called <code>left</code> and <code>right</code>.\nA simple implementation in <code>Python</code>:</p>\n<pre><code class=\"language-python\">class BinaryTreeNode(object):\n    def __init__(self, value):\n        self.value = value\n         self.left = None\n         self.right = None\n</code></pre>\n<blockquote>\n<p>A class definition for a Binary Tree Node in Python</p>\n</blockquote>\n<p>In JavaScript:</p>\n<pre><code class=\"language-javascript\">function BinaryTreeNode(value) {\n  this.value = value\n  this.left = null\n  this.right = null\n}\n</code></pre>\n<blockquote>\n<p>An object definition in JavaScript</p>\n</blockquote>\n<p>In Java:</p>\n<pre><code class=\"language-java\">public class &#x3C;T> BinaryTreeNode{\n    public T value;\n    public BinaryTreeNode left;\n    public BinaryTreeNode right;\n\n    public BinaryTreeNode(T value){\n        this.value = value;\n    }\n}\n</code></pre>\n<blockquote>\n<p>Binary Tree node implementation of Binary Tree node in Java, this uses T to define objects.</p>\n</blockquote>\n<p>And finally in Ruby:</p>\n<pre><code class=\"language-ruby\">class BinaryTreeNode\n\n    attr_accessor :value, :left, :right\n\n    def initialize(value)\n        @value = value\n        @left  = nil\n        @right = nil\n    end\nend\n</code></pre>\n<p>Why these languages? Well, because I am familiar with them and also to show that it does not matter the language, the implementation of a data structure is usually the same.</p>\n<p><img src=\"https://www.interviewcake.com/images/svgs/binary_tree__depth_5.svg?bust=138\" alt=\"binary tree\"></p>\n<blockquote>\n<p>Binary tree data structure, you will notice, it pretty much looks like a tree.</p>\n</blockquote>\n<p>This particular example is special because every level of the tree is completely full. There are no \"gaps.\" We call this kind of tree \"perfect.\"</p>\n<p>Binary trees have a few interesting properties when they're perfect:</p>\n<ol>\n<li>The number of total nodes on <em>each</em> doubles as we move down the tree\n<img src=\"https://www.interviewcake.com/images/svgs/binary_tree__depth_5_with_number_of_nodes_labelled.svg?bust=138\" alt=\"perfectBinaryTree\"></li>\n<li>\n<p>The number of nodes on the last level is equal to the sum of all the nodes on other levels(plus 1)\nLet's call the number of nodes <code>n</code>, and the height of the tree <code>h</code>. <code>h</code> can also be thought of as the <em>number of levels</em>. If we had <code>h</code>, how could we calculate <code>n</code>?\nLet's just add up the number of nodes on each level! How many nodes are on each level?\nIf we zero-index the levels, the number of nodes on the <code>x</code>th level is exactly <code>2^x</code>!</p>\n<ul>\n<li>Level 0: 2^0 nodes</li>\n<li>Level 1: 2^1 nodes,</li>\n<li>Level 2: 2^2 nodes,</li>\n<li>Level 3: 2^3 nodes,</li>\n<li>etc</li>\n</ul>\n<p>So our total number of nodes is:\n$$n= 2^0 + 2^1 +2^2 +2^3 +...+2^{h−1}$$ > Why only up to 2^{h-1} ? Notice that we started counting our levels at 0. So if > we have h levels in total, the last level is actually the \"h−1\"-th level. > That means the number of nodes on the last level is 2^{h-1}.</p>\n<p>But we can simplify. Property 2 tells us that the number of nodes on the last level is (1 more than) half of the total number of nodes, so we can just take the number of nodes on the last level, multiply it by 2, and subtract 1 to get the number of nodes overall.\nWe know the number of nodes on the last level is 2^{h-1}, So:</p>\n<p>$$ n = 2^{h-1} * 2 - 1$$\n$$n = 2^{h−1}∗2^{1}−1$$\n$$n = 2^{h-1+1}- 1$$\n$$n = 2^{h} - 1$$</p>\n<p>So that's how we can go from <code>h</code> to <code>n</code>. What about the other direction?</p>\n<p>We need to bring the <code>h</code> down from the exponent. That's what logs are for!</p>\n<p>First, some quick review on Algebra. $$log<em>{10}(100)$$ simply means, \"What power must you raise 10 to in order to get 100?\". Which is 2, because $$10^2 = 100$$.\nWe can use logs in algebra to bring variables down from exponents by exploiting the fact that we can simplify $$log</em>{10}(10^2)$$. What power must we raise 10 to in order to get $$10^2$$?\nThat's easy — it's 2.</p>\n<p>So in this case we can take the $$log_{2}$$ of both sides:</p>\n<p>$$n = 2^{h} - 1$$\n$$n + 1 = 2^{h}$$\n$$log<em>{2}{((n+1))} = log</em>{2}{(2^{h})}$$\n$$log_{2}{(n+1)} = h$$</p>\n</li>\n</ol>\n<h3>Conclusion</h3>\n<p>So that's the relationship between height and total nodes in a perfect binary tree.\nI know it involved a bit of Math, which you did not want nor expect, however, this will make the programs you write faster and better and of course easier to maintain and debug.</p>\n<p>Let us plant more trees!</p>","frontmatter":{"title":"Perfect Binary Tree","subtitle":"A gentle introduction to perfect binary trees","date":"January, 26, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"binary_tree.png","thumbnail":"binary_tree.png","teaser":"binary_tree.png","credit":"Quora","creditlink":null},"path":"/tech/binary-tree","tags":["algorithms","data-structures","binary-tree"],"excerpt":"Binary trees are part of a data structure known as `Trees`, yeah, I know, the forefathers of computer science and software engineering were quite creative. They were quite observant. Trees, more or less, look like trees, like the literal trees in nature. Now, that we have the most basic and almost worst analogy out there, what are binary trees?"}}},"pageContext":{"prev":{"html":"<p>Configuring a Raspberry Pi is fun especially when you delve into IoT and start tinkering around with making machines talk to each other. This tool is perfect for such fun. It is even better when you can get it connected to the internet and perform even more functions such as make your coffee before you wake up or turn off your lights from wherever you are.</p>\n<p>Most of these functions may require an internet connection and this means that your Pi(I will start calling it Pi for short from now on, not to be confused with the Math constant), may have to be able to generate its own hotspot. This is limiting considering Pis do not essentially come with their own <strong>WiFi dongles</strong> and you will be required to buy your own or always have the Pi set up where there will always be an internet connection.</p>\n<p>For today, we shall configure a Pi to generate its own hotspot when it can not find any known hotspots in its vicinity and also have the added benefit of connecting to a hotspot when there is a known network.</p>\n<h3>Aim</h3>\n<p>Raspberry Pi searches for known router's (SSID)</p>\n<p>If the router is not found then it creates a hotspot so tablets, phones and computers can connect to the Raspberry Pi's WiFi hotspot, which is not routed to the internet but allows a connection via SSH, VNC etc.</p>\n<h3>Requirements</h3>\n<p>For this, all you will need:</p>\n<ul>\n<li>Raspberry Pi 3 or other Raspberry Pi set up with a WiFi dongle</li>\n<li>Internet connection</li>\n<li>WiFi connection set up on your router</li>\n</ul>\n<h3>Step 1</h3>\n<p>This step will mostly be for settin up tools we need for the Pi. To start off hostapd hotspot client and dnsmasq lightweight dns server need to be installed.</p>\n<p>Open a Terminal session in your Pi and update Raspbian with the latest updates by entering the commands:</p>\n<pre><code class=\"language-sh\">$ sudo apt-get update\n$ sudo apt-get upgrade\n</code></pre>\n<p>This will update the packages on the Rasberry Pi</p>\n<p>Now, install hostapd. Enter the command:</p>\n<pre><code class=\"language-sh\">$ sudo apt-get install hostapd\n</code></pre>\n<p>enter Y when prompted.</p>\n<p>Install dnsmasq with the command:</p>\n<pre><code class=\"language-sh\">sudo apt-get install dnsmasq\n</code></pre>\n<p>enter Y when prompted</p>\n<p>The installers will have set up the programme so they run when the pi is started. For this setup they only need to be started if the home router is not found. So automatic startup needs to be disabled. This is done with the following commands:</p>\n<pre><code class=\"language-sh\">sudo systemctl disable hostapd\n\nsudo systemctl disable dnsmasq\n</code></pre>\n<p>Now the hostspot configuration file can be setup. This contains the name of the WiFi signal you will need to connect to (SSID) and the security password.</p>\n<h4>Hostapd Configuration</h4>\n<p>Using a text editor edit the hostapd configuration file. This file won't exist at this stage so it will be blank.</p>\n<pre><code class=\"language-sh\">sudo nano /etc/hostapd/hostapd.conf\n</code></pre>\n<p>This will create the hostapd.conf</p>\n<p>enter or paste the settings:</p>\n<pre><code class=\"language-plain\">interface=wlan0\ndriver=nl80211\nssid=RPI3WiFi\nhw_mode=g\nchannel=6\nwmm_enabled=0\nmacaddr_acl=0\nauth_algs=1\nignore_broadcast_ssid=0\nwpa=2\nwpa_passphrase=1234567890\nwpa_key_mgmt=WPA-PSK\nwpa_pairwise=TKIP\nrsn_pairwise=CCMP\n</code></pre>\n<p>A brief breakdown of what the above means:</p>\n<ul>\n<li>interface will be wlan0</li>\n<li>driver nl80211 works with the Raspberry Pi 3 onboard WiFi but you will need to check that your wifi dongle is compatable and can use AP mode.</li>\n</ul>\n<p>For more information on wifi dongles check <a href=\"elinux.org/RPi_USB_Wi-Fi_Adapters\">here</a></p>\n<ul>\n<li>The SSID is the name of the WiFi signal broadcast from the RPi, which you will connect to with your Tablet or phones WiFi settings.</li>\n<li>channel can be set between 1 and 13. If you are having trouble connection because of to many wifi signals in your area are using channel 6 then try another channel.</li>\n<li>wpa_passphrase is the password you will need to enter when you first connect a device to your Raspberry Pi's hotspot. This should be at least 8 characters and a bit more difficult to guess than my example.</li>\n</ul>\n<p>To save the config file press ctrl &#x26; o and to exit nano press Ctrl &#x26; x</p>\n<p>Now the default file for hostapd needs to be updated to point to where the config file is stored.</p>\n<p>In terminal enter the command</p>\n<pre><code class=\"language-sh\">sudo nano /etc/default/hostapd\n</code></pre>\n<p>Change:</p>\n<pre><code class=\"language-plain\">#demon_conf=\"\"\n</code></pre>\n<p>to</p>\n<pre><code class=\"language-plain\">demon_conf=\"/etc/hostapd/hostapd.conf\"\n</code></pre>\n<p>And save.</p>\n<h4>dnsmasq configuration</h4>\n<p>Next dnsmasq need to be configured to allow the PI to act as a router and issue IP addresses.</p>\n<pre><code class=\"language-sh\">$ sudo nano /etc/dnsmasq.conf\n</code></pre>\n<p>Go to the bottom of the file and add the following lines</p>\n<pre><code class=\"language-plain\">#Pi3Hotspot Config\n#stop DNSmasq from using resolv.conf\nno-resolv\n#Interface to use\ninterface=wlan0\nbind-interfaces\ndhcp-range=192.168.40.5,192.168.40.100,255.255.255.0,12h\n</code></pre>\n<p>And then save (ctrl &#x26; o) and exit (ctrl &#x26; x)</p>\n<h3>Step 2</h3>\n<p>Now that <strong>hostapd</strong> and <strong>dnsmasq</strong> are configured we now need to make some changes to the interfaces file and then add a script that will detect if you are at home or not.</p>\n<p>Next we need to edit the interfaces file. There will be several entries already in the file. Look for references to <em>wlan0</em> and alter them as below. Any reference to <em>wpa</em>conf_ for wlan0 should be disabled by putting a # at the start of the line.</p>\n<p>Open the interfaces file with the command</p>\n<pre><code class=\"language-sh\">$ sudo nano /etc/network/interfaces\n</code></pre>\n<p>edit the following lines as below</p>\n<pre><code class=\"language-plain\">auto lo wlan0\niface lo inet loopback\n\nallow-hotplug wlan0\niface wlan0 inet manual\n# wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf\n</code></pre>\n<p>now save (ctrl &#x26; o) and exit (ctrl &#x26; x)</p>\n<p>Note: Due to the constants updates to Linux the Wifi login details have moved, if your home routers SSID and password was listed in this file then the hotspot will probably not get generated.</p>\n<p>You will need to put a # infront of each line</p>\n<pre><code class=\"language-plain\">#iface wlan0 inet dhcp\n#       wpa-ssid \"mySSID\"\n#       wpa-psk \"Router Pasword\"\n</code></pre>\n<p>These details need to be in the <strong>wpa_supplicant.conf</strong> file to work with this setup.</p>\n<p>Add your router details to the wpa_supplicant.conf file with</p>\n<pre><code class=\"language-sh\">$ sudo nano /etc/wpa_supplicant/wpa_supplicant.conf\n</code></pre>\n<p>and add the following commands to the bottom of the file.</p>\n<pre><code class=\"language-plain\">network={\n        ssid=\"mySSID\"\n        psk=\"Router Password\"\n        key_mgmt=WPA-PSK\n}\n</code></pre>\n<h3>Step 3</h3>\n<p>This is the final setup where we write the script that will start up when the RPi is first started. We will need to add the startup script to the <code>rc.local</code> file.</p>\n<p>This is an altered version of the \"Rpi Network conf Bootstrapper\" script by Lasse Christiansen</p>\n<p>This script will check what routers are available when the RPi is started in the order of <code>mySSID1</code>, <code>mySSID2</code> etc.\nThe first router found in the list will be connected to using existing configured WiFi settings. If none of the listed SSIDs are in range then a WiFi hotspot is created.</p>\n<pre><code class=\"language-sh\">$ sudo nano /etc/rc.local\n</code></pre>\n<p>Your rc.local file will look like this if it has not previously been edited.</p>\n<pre><code class=\"language-sh\">#!/bin/sh\n# rc.local\n# This script is executed at the end of each multiuser runlevel.\n# Make sure that the script will \"exit 0\" on success or any other\n# value on error.\n# In order to enable or disable this script just change the execution\n# bits.\n# By default this script does nothing.\n# Print the IP address\n_IP=$(hostname -I) || true\nif [ \"$_IP\" ]; then\nprintf \"My IP address is %s\\n\" \"$_IP\"\nFi\nexit 0\n</code></pre>\n<p>First of all change the top line from <code>#!/bin/sh</code> to <code>#!/bin/bash</code></p>\n<p>The line \"exit 0\" need to be at the bottom of the file so add the bootstrapper script between</p>\n<pre><code class=\"language-plain\">printf \"My IP address is %s\\n\" \"$_IP\"\nFi\n</code></pre>\n<p>and</p>\n<pre><code class=\"language-plain\">exit 0\n</code></pre>\n<p>The script to add is this:</p>\n<pre><code class=\"language-sh\">#Wifi config - if no prefered Wifi generate a hotspot\n#RPi Network Conf Bootstrapper\n\ncreateAdHocNetwork()\n{\n    echo \"Creating RPI Hotspot network\"\n    ifconfig wlan0 down\n    ifconfig wlan0 192.168.40.5 netmask 255.255.255.0 up\n    service dnsmasq start\n    service hostapd start\n    echo \" \"\n    echo \"Hotspot network created\"\n    echo \" \"\n}\n\necho \"=================================\"\necho \"RPi Network Conf Bootstrapper\"\necho \"=================================\"\necho \"Scanning for known WiFi networks\"\nssids=(mySSID1 mySSID2)\nconnected=false\nfor ssid in \"${ssids[@]}\"\ndo\n    echo \" \"\n    echo \"checking if ssid available:\" $ssid\n   echo \" \"\n    if iwlist wlan0 scan | grep $ssid > /dev/null\n    then\n        echo \"First WiFi in range has SSID:\" $ssid\n        echo \"Starting supplicant for WPA/WPA2\"\n        wpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf > /dev/null 2>&#x26;1\n        echo \"Obtaining IP from DHCP\"\n        if dhclient -1 wlan0\n        then\n            echo \"Connected to WiFi\"\n            connected=true\n            break\n        else\n            echo \"DHCP server did not respond with an IP lease (DHCPOFFER)\"\n            wpa_cli terminate\n            break\n        fi\n    else\n        echo \"Not in range, WiFi with SSID:\" $ssid\n    fi\ndone\n\nif ! $connected; then\n    createAdHocNetwork\nfi\n</code></pre>\n<p>bootstrapper script to start up RPi hotspot on boot</p>\n<p>And finally save (ctrl &#x26; o) and exit (ctrl &#x26; x)</p>\n<p>In the line ssids=(mySSID1 mySSID2) change mySSID1 to the SSID name of your home router,</p>\n<p>if you connect your Rpi to other routers then these can be added separated by a space.\nRemove mySSID2 if you only want to search for one router as this will speed up the startup process.</p>\n<p>You should now be able to reboot and if all has gone ok your Raspberry Pi will start and connect to your router as normal.</p>\n<p>The final <code>rc.local</code> file should look like this</p>\n<pre><code class=\"language-sh\">#!/bin/bash\n# rc.local\n# This script is executed at the end of each multiuser runlevel.\n# Make sure that the script will \"exit 0\" on success or any other\n# value on error.\n# In order to enable or disable this script just change the execution\n# bits.\n# By default this script does nothing.\n# Print the IP address\n_IP=$(hostname -I) || true\nif [ \"$_IP\" ]; then\nprintf \"My IP address is %s\\n\" \"$_IP\"\nFi\n\n#Wifi config - if no prefered Wifi generate a hotspot\n#RPi Network Conf Bootstrapper\n\ncreateAdHocNetwork()\n{\n    echo \"Creating RPI Hotspot network\"\n    ifconfig wlan0 down\n    ifconfig wlan0 10.0.0.5 netmask 255.255.255.0 up\n    service dnsmasq start\n    service hostapd start\n    echo \" \"\n    echo \"Hotspot network created\"\n    echo \" \"\n}\n\necho \"=================================\"\necho \"RPi Network Conf Bootstrapper\"\necho \"=================================\"\necho \"Scanning for known WiFi networks\"\nssids=(mySSID1 mySSID2)\nconnected=false\nfor ssid in \"${ssids[@]}\"\ndo\n    echo \" \"\n    echo \"checking if ssid available:\" $ssid\n   echo \" \"\n    if iwlist wlan0 scan | grep $ssid > /dev/null\n    then\n        echo \"First WiFi in range has SSID:\" $ssid\n        echo \"Starting supplicant for WPA/WPA2\"\n        wpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf > /dev/null 2>&#x26;1\n        echo \"Obtaining IP from DHCP\"\n        if dhclient -1 wlan0\n        then\n            echo \"Connected to WiFi\"\n            connected=true\n            break\n        else\n            echo \"DHCP server did not respond with an IP lease (DHCPOFFER)\"\n            wpa_cli terminate\n            break\n        fi\n    else\n        echo \"Not in range, WiFi with SSID:\" $ssid\n    fi\ndone\n\nif ! $connected; then\n    createAdHocNetwork\nfi\n\nexit 0\n</code></pre>\n<p>final rc.local file</p>\n<h3>Conclusion</h3>\n<p>If all has gone well you should still be able to connect the Pi to your home router when it boots up. In case you want to check whether the setup works if there is not hotspot around. You can switch off your router and reboot your Raspberry Pi and watch at startup as the above <code>rc.local</code> script runs as it searches for a hotspot and since there will not be one it will generate its own hotspot and you should be able to connect to it with either your mobile, laptop, tablet etc.</p>\n<p>Furthermore, you can open an ssh connection to the Pi using this command</p>\n<pre><code class=\"language-sh\">$ ssh pi@192.168.40.5\n</code></pre>\n<p>This will prompt you for a password. This password will be for the Raspberry Pi</p>\n<p>That is about it! You should now have a hotspot on your Raspberry Pi. Although it is important to note that this hotspot connection will not have any internet connection and thus you can't connect to the web with it, however any other device can connect to it via an ssh connection.</p>","id":"c8d90461-936d-5ecd-bb59-d500e7b6b210","timeToRead":9,"frontmatter":{"title":"Raspberry Pi Hotspot configuration","subtitle":"A small demo of configuring a hotspot for your Raspberry Pi","excerpt":"Configuring a Raspberry Pi is fun especially when you delve into IoT and start tinkering around with making machines talk to each other. This tool is perfect for such fun. It is even better when you can get it connected to the internet and perform even more functions such as make your coffee before you wake up or turn off your lights from wherever you are.","path":"/tech/raspberry-pi-hotspot","category":"tech","date":"March 19, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":null,"thumbnail":"raspberrypi.png","teaser":"raspberrypi.png","credit":null,"creditlink":null},"tags":["iot","raspberry-pi","wifi"],"published":true}},"next":{"html":"<p>The <strong>Ruin Theory</strong> or <em>surplus process</em> or <em>risk process</em> defines when a company is most likely to go bankrupt given a constant flow of income and random outflow of cash. This is used in most businesses to determine for how long the company can be expected to be in operation before their wallet does not allow them to continue.</p>\n<p>Of course this is all probability and does not give an exact date or exact metrics as to when or high likely this will occur. However, it does help a company properly assess where they are currently and where they should avoid given current circumstances are unfavorable.</p>\n<p>Let us assume that a business starts with an initial capital amount. All businesses have constant income from sell of services or goods, or in the case of insurance companies from premium income. Additionally, these same businesses have cash outflow, which oftentimes is random and can not be accurately predicted. These cash outflows are random in both timing and amount and thus a company ought to be careful and ensure that their initial capital does not fall below 0 or is less than the cash outflow at any given time or they will face what is known as <strong>ruin</strong>(bankruptcy).</p>\n<p>As you can imagine, this involves a lot of mathematical calculation and often graphs to properly access when the company may experience ruin. Since the cash inflow is constant and can be determined, what is left to determine is the time and amount of cash outflow. Once these two random variables are determined, then the whole process is more visible and can be properly drawn on paper.</p>\n<p>This process can be outlined by the graph below:</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/en/thumb/6/6b/Samplepathcompoundpoisson.JPG/350px-Samplepathcompoundpoisson.JPG\" alt=\"ruin process\"></p>\n<blockquote>\n<p>From our good friends Wikipedia</p>\n</blockquote>\n<p>Of course it looks a bit intimidating but a breakdown is coming right up. Before that though, we can see from this picture that there are 2 sides to the graph, the part below the X-axis is obviously bad, as it means the company is bankrupt. The vertical drops in the graph are the cash outflows and are dotted as we can not properly determine when they will occur. The diagonal lines are the cash inflow and those can be properly determined.\nThe graph does no start at coordinate <code>0,0</code> as this is the initial reserve or capital the company starts with.</p>","id":"47734391-8e85-591c-a5b0-40b42c7303e4","timeToRead":2,"frontmatter":{"title":"The Risk Process","subtitle":"A small breakdown of the risk process","excerpt":"A small breakdown of the risk process","path":"/finance/risk-process","category":"finance","date":"January 18, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"ruintheory.JPG","thumbnail":null,"teaser":"ruintheory.JPG","credit":"Wikipedia","creditlink":"https://en.wikipedia.org/wiki/Ruin_theory"},"tags":["Actuarial","Insurance","Money","business"],"published":true}}}}}