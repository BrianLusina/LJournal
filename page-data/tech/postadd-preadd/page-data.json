{"componentChunkName":"component---src-templates-blogs-blog-post-jsx","path":"/tech/postadd-preadd","result":{"data":{"markdownRemark":{"html":"<p>This post is a demonstration of the difference between post increment and pre increment of variables in Java. Post increment is usually denoted as <code>x++</code>, where the x is the variable in question, usually an integer, double or float. While pre-increment is addition denoted as <code>++x</code>.</p>\n<h1>Pre-increment</h1>\n<p>As the terms suggests, <em>PRE-increment</em> is the addition of a particular value before it is used. It is normally used when you want to use the incremented value of that particular variable. When the program encounters a pre-increment it increases the value of that variable in the memory then loads the expression.</p>\n<p>A simple demonstration:</p>\n<pre><code class=\"language-java\">public class PostAndPre {\n    public static void main(String[] args){\n        int x = 0;\n        for(int i = 0; i &#x3C; 10; i++){\n            System.out.printf(\"%d\\n\", ++x);\n            /*Output:\n            1 2 3 4 5 6 7 8 9 10 */\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<p>Demo of pre-increment</p>\n</blockquote>\n<p>The above variable <code>x</code> is instantiated as 0. The program encounters the variable <code>x</code> and increases the value by 1 before output of the result.</p>\n<p>This is equivalent to:</p>\n<pre><code class=\"language-Java\">        x = x + 1;\n        int y = x;\n        System.out.printf(\"%d\", y);\n</code></pre>\n<h1>Post-increment</h1>\n<p>The <em>post increment</em> uses the variable before increasing it. So in the case of <code>x++</code>, the variable will be 0, and will be used as is before it will be increased. This loads the value of that variable in memory, increases the variable and then continues reading the expression.</p>\n<pre><code class=\"language-java\">        int l = 0;\n        for(int i = 0; i &#x3C; 10; i++){\n            System.out.printf(\"%d \\t\", l++);\n            //output 0  1   2   3   4   5   6   7   8   9\n        }\n</code></pre>\n<blockquote>\n<p>Demo of post increment</p>\n</blockquote>\n<p>The above variable <code>l</code> is instantiated as 0 and will be output as 0, before the variable is increased.</p>\n<p>Code snippet can be found <a href=\"https://github.com/BrianLusina/Java-Playground/blob/master/Toy%20Problems/src/PostAndPre/PostAndPre.java\">here</a>.</p>","frontmatter":{"title":"Difference between Post increment and pre increment of a variable","subtitle":"x++ and ++x","date":"July, 06, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":null,"thumbnail":null,"teaser":null,"credit":null,"creditlink":null},"path":"/tech/postadd-preadd","tags":["Post-increment","pre-increment"],"excerpt":"This post is a demonstration of the difference between post increment and pre increment of variables in Java. Post increment is usually denoted as `x++`, where the x is the variable in question, usually an integer, double or float. While pre-increment is addition denoted as `++x`."}}},"pageContext":{"prev":{"html":"<p>Abstraction is one of the principles of Object Oriented Programming where a programmer hides/reduces information of an object and only reveals the relevant information at the time. It works alongside <em>inheritance</em> and <em>encapsulation</em>. This is done in order to reduce complexity and ensure efficiency.</p>\n<p>In the process of abstraction, the programmer tries to ensure that the entity is named in a manner that will make sense and that it will have all the relevant aspects included and none of the extraneous ones.</p>\n<p>A practical example is a car. Not many people are concerned with the inner workings of a motor vehicle, save for mechanics, engineers and car enthusiasts. A car is an object that has certail states and behaviours. It has states such as <em>black</em> paint, <em>engine size</em> and <em>number of doors</em> etc. The behaviours are <em>accelerate</em>, <em>decelerate</em> and <em>stop</em>, just to mention a few. Now, for the driver to intaract with the car, they have to do so through the steering wheel, the gears and the peddles. These are the <strong>interfaces</strong>.</p>\n<p>These are what act as a go-between the driver and the internal components of the car. This is where abstraction steps in. The driver does not particularly know what is going on in the engine when they accelerate and when they stop. All they get to interact with are the steering wheel, pedals and various gauges on the car dashboard. Abstraction basically gives them this relevant information as it is what is needed at the time of driving. All the driver needs to know at all times when they are driving are the fuel gauge, the speed they are on and car temperature. They do not need to know about how the car measures heat every second or how it gauges how much petrol is left in the tank or even how it calculates the current speed. This information is hidden in the internal components of the car (<em>encapsulation</em>) and is queried (say, you take your car apart and study it) only when need be. So at all times only relevant information is displayed(<em>abstraction</em>).</p>\n<p>This, as you can see, reduces the complexity when driving said car and allows the driver to only intaract with what they need to interact with at the time of driving.</p>","id":"1606581a-36ff-54f6-af72-59bed280fe9d","timeToRead":2,"frontmatter":{"title":"A Practical example of Abstraction","subtitle":"A more practical approach to abstraction in OOP","excerpt":"Abstraction in the real world.","path":"/tech/abstraction","category":"tech","date":"July 11, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"abstraction.jpg","thumbnail":"abstraction.jpg","teaser":"abstraction.jpg","credit":null,"creditlink":null},"tags":["encapsulation","objects","object oriented programming","abstraction"],"published":true}},"next":{"html":"<p>This topic will simply <em>extend</em> from the <a href=\"https://brianlusina.github.io/Object-Oriented-Programming/\">Objective of OOP</a> and <a href=\"https://brianlusina.github.io/Principles-Of-Oop/\">4 principles of OOP</a> and will majorly focus only on accessors and modifiers, i.e. <em>getters</em> and <em>setters</em>.</p>\n<p>Accessors are methods used in Object Oriented Programming to enable <em>access</em> to a class fields which may be private. In most cases it is advisable to make these fields private and allow allow access to them from the accessors and modifier methods. The accessor methods, or <em>getter</em> methods as they are most commonly known as, are only used to <strong>access</strong> or <em>get</em> the fields/states of a particular object. Modifiers or <em>setters</em> allow the modification or <em>setting</em> of the fields of a particular object.</p>\n<p>These are used in encapsulation and allow data hiding which makes code more secure and also reduces the amount of code written, which is what every developer seeks, to make code cleaner, smaller, but still maintain the overall functionality and readability.</p>\n<p>A simple example of a Car class will be used. A Car is a super class of every car type in the world. This Car class will contain all the fields/states and behaviours/methods of all the car types in the world.</p>\n<p>This is the code for writing a super class Car in Java:</p>\n<pre><code class=\"language-Java\">public class Car {\n    private int wheels;\n    private int engineCapacity;\n    private int seats;\n    private String name;\n\n    /**Constructor for the Car class*/\n    public Car(int wheels, int engineCapacity, int seats, String name){\n        this.wheels = wheels;\n        this.engineCapacity = engineCapacity;\n        this.seats = seats;\n        this.name = name;\n    }\n\n    /**ACCESSORS AND MODIFIERS getters and setters*/\n\n    /*get and set wheels*/\n    public int getWheels(){\n        return wheels;\n    }\n\n    public void setWheels(int wheels){\n        this.wheels = wheels;\n    }\n\n    /*set and get the engine capacity*/\n    public int getEngineCapacity(){\n        return engineCapacity;\n    }\n\n    public void setEngineCapacity(int engineCapacity){\n        this.engineCapacity = engineCapacity;\n    }\n\n    /*getters and setters for the seats*/\n    public int getSeats(){\n        return seats;\n    }\n\n    public void setSeats(int seats){\n        this.seats = seats;\n    }\n\n    /*get and set the name*/\n    public String getName(){\n        return name;\n    }\n\n    public void setName(String name){\n        this.name = name;\n    }\n\n}\n</code></pre>\n<blockquote>\n<p>This is a car class with a constructor to define its objects on creation the getters and setters have been defined to allow the object's fields or states to be modified by the instance.</p>\n</blockquote>\n<p>The usual convention for writing getters is by writing the word <strong>get</strong> and followed by the name of the field to access. So, in this case, to acces the <code>seats</code> field, the function created is <code>getSeats()</code>. This getter <strong>MUST</strong> return the data type of the same field it wants to access. So, in the case of seats, it must return and <code>int</code> data type as the <code>seats</code> variable is an integer type.\nIt is important to note that getter methods do not take any arguments.</p>\n<p>Setters are a bit different. To create a setter function, the same method as declaring a get method is applied. Use of the word <strong>set</strong> followed by the name of the variable. An example would be <code>setName</code>. This naming follows the camel casing convention for naming variables. The setter methods <strong>DO NOT</strong> return any value and thus the <em>void</em> is used, which means: <em>does not return any value</em>. This does not return a particular value as it's job is to set a particular value. In this case, <code>setName(String name)</code> takes in a String argument and modifies the current name field (or re-assigns the name variable) with the input in the <code>setName</code> method. The setter methods must take arguments as they are, after all, supposed to modify the current field to a new state.</p>\n<p>All this is made possible because the variables have been declared <code>private</code>. This restricts access, therefore the need for use of getters and setters.</p>\n<h2>Sample usage of accessors and modifiers</h2>\n<p>Below is a sample usage of getters and setters from the Car's class defined above:</p>\n<pre><code class=\"language-Java\">public class CarTest {\n    public static void main(String[] args){\n        Car merc = new Car(4, 3500, 5, \"Mercedez Benz\");\n        Car toyota = new Car(4, 1200, 5, \"Allion\");\n\n        /*The getters allows the private variables to be accessed from the constructor*/\n        System.out.printf(\"This is a %s with %d wheels, %d seats and an engine capacity of\n        %d CC \\n\", toyota.getName(), toyota.getWheels(), toyota.getSeats(),toyota.getEngineCapacity());\n\n//output is This is a Allion with 4 wheels, 5 seats and an engine capacity of 1200\n\n        System.out.printf(\"This is a %s with %d wheels, %d seats and an engine capacity of\n        %d CC \\n\", merc.getName(), merc.getWheels(), merc.getSeats(),merc.getEngineCapacity());\n        //output is This is a Mercedez Benz with 4 wheels, 5 seats and an engine capacity of 3500 CC\n\n        /*the setters modify the states or fields of the object*/\n        merc.setName(\"Mercedes SLS\");\n        merc.setEngineCapacity(4500);\n        merc.setWheels(4);\n        merc.setSeats(2);\n\n        /*these have been modified from the previous states to the current states as described below*/\n        System.out.printf(\"This is a %s with %d wheels, %d seats and an engine capacity of\n        %d CC \\n\", merc.getName(), merc.getWheels(), merc.getSeats(),merc.getEngineCapacity());\n        //output is This is a Mercedes SLS with 4 wheels, 2 seats and an engine capacity of 4500 CC\n\n        //below lines modify the toyota object\n        toyota.setName(\"Toyota Celica\");\n        toyota.setEngineCapacity(2500);\n        toyota.setWheels(4);\n        toyota.setSeats(2);\n\n        /*these have been modified from the previous states to the current states as described below*/\n        System.out.printf(\"This is a %s with %d wheels, %d seats and an engine capacity of %d CC\", toyota.getName(), toyota.getWheels(), toyota.getSeats(),toyota.getEngineCapacity());\n        //output is: This is a Toyota Celica with 4 wheels, 2 seats and an engine capacity of 2500 CC\n\n    }\n}\n</code></pre>\n<p>The <code>merc</code> and <code>toyota</code> objects are instances of the Car class, thus they inherit all the characteristics(fields and methods of the parent class) of Car class. This allows them access to the variables such as <code>seats</code>, <code>engineCapacity</code> and <code>name</code>, just ot mention a few. Note, however, that these variables can only be accessed from the getters and setters</p>\n<p>The getters allow access to the various fields that have been set in the constructor. a method such as <code>merc.getName()</code> returns <em>Mercedez Benz</em>, while <code>toyota.getName()</code> returns <em>Allion</em>. These are the fields set in the constructor. using <code>merc.name</code> will return an error.</p>\n<p>To rename these fields the setters have been used. A method call such as <code>merc.setEngineCapacity(4500)</code> will change the <code>engineCapacity</code> from 3500 to 4500. This is modifying. The same applies to <code>toyota.setSeats(2)</code>.</p>\n<p>This is a basic example and is mostly used to restrict access to a class' states and behaviour to the outside world thus increasing security of the code used.</p>\n<p>Sample code can be found here <a href=\"https://github.com/BrianLusina/Java-Playground/blob/master/Toy%20Problems/src/DataStructures/OOP/Car.java\">Car Class</a> and <a href=\"https://github.com/BrianLusina/Java-Playground/blob/master/Toy%20Problems/src/DataStructures/OOP/CarTest.java\">CarTest class</a>.</p>","id":"2edc2bc2-0b58-5865-8006-2eea1a7933ef","timeToRead":5,"frontmatter":{"title":"Accessors and Modifiers","subtitle":"subtle introduction to getters and setters","excerpt":null,"path":"/tech/access-modifiers","category":"tech","date":"July 05, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":null,"thumbnail":null,"teaser":null,"credit":null,"creditlink":null},"tags":["OOP","getters and setters","accessors","modifiers"],"published":true}}}}}