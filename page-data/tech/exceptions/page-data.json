{"componentChunkName":"component---src-templates-blogs-blog-post-jsx","path":"/tech/exceptions","result":{"data":{"markdownRemark":{"html":"<p>No one likes errors, especially when they occur frequently and unchecked. As developers we constantly check for errors and not that the program is running as expected, but rather it is handling the errors as it should. There is not perfect program that will never encounter errors, the best programs are the ones that handle <strong>exceptions</strong> really well and keep the user happy and oblivous of the errors being handled. It is important that errors are handled appropriately and also that they give the user a meaningful message. Unfortunately, you never know that kind of errors you may encounter in your program. Some are caused by the code you write, others by external factors that your program has nothing to do with, like a poor internet connection or hardware malfunction. In both cases, your program should be able to handle these exceptions and keep running or exit, whichever suits you need at the time.</p>\n<p>Of course, before delving deeper into the exceptions, we should all be on the same page as to what exceptions are.</p>\n<p><strong>Exceptions</strong> as defined by Java Documentation is an event, which occurs during the execution of a program, that disrupts the normal flow of the program's instructions. This disruption of the normal flow of the program should be handled with care and enable the user to keep interacting with the program despite this interruption, otherwise you will have poor ratings, no one wants that.</p>\n<p>I will not delve into details about how a program determines an error and normal flow of a program. I will dive immediately into which type of exceptions we should look out for.</p>\n<ol>\n<li>\n<p>Checked Exception</p>\n<p>Say, you are creating a program that requires user input, such as their name, phone number, email and such, for validation purposes. Maybe you need these inputs for authorization or for sign up to your platform. It is possible that the user will provide an invalid email address and as such you will need to validate these parameters before passing them to a function or class that will handle the authentication. Normally, if you are developing for Android it will be easy to validate this field in the XML layout, but what if you are checking with a server and you have to fetch a response in order to proceed. If the response returns <em>Null</em> then you need to be able to handle such a response.</p>\n<p>A well-written program will catch this exception and notify the user of the mistake, possibly prompting for a correct email address if the email does not exist in the system's database.</p>\n</li>\n<li>\n<p>Error</p>\n<p>These are the kind of errors that will occur that are outside the application's scope of handling. These kind of errors may involve poor internet connection on the part of the user or maybe they are experiencing hardware failure. The application can not anticipate that it will happen as it may occur randomly. However, it should be able to catch this exception and notify the user of the failure to execute the program. In the example above, maybe in the middle of execution of request to ther server, after having validate the user credentials, the internet connection is abruptly cut and the user is not properly authenticated with the system, it is at this point that the application should notify the user of the problem, catch this expection and try again at a late time. It may make sense in some instances to print a stacktrace and exit the program.</p>\n</li>\n<li>\n<p>Runtime Exception</p>\n<p>These are exceptional conditions that are internal to the application, and that the application usually cannot anticipate or recover from. These type of errors are usually because of an improper use of an API or a logic error. If we use the abov example still, if a logic error causes <code>null</code> to be passed instead of a <code>username</code> then the method handling authentication will throw a <strong>NullPointerException</strong>. Now normally it may make sense to catch this exception and notify the user, but it makes even more sense to eliminate this bug completely and not pass null to the method or constructor of a class.</p>\n</li>\n</ol>\n<p>Now, you may have noticed something similar about the last two types of exceptions. Errors and runtime exceptions are collectively known as <strong>unchecked exceptions</strong> and this is because they do not need to be <em>caught</em> as much as the 1st type. This is normally because they could be caused by external factors that the app can not manage and it will reduce complexity and make more sense for the application to terminate and inform the user of the same. In other instances like in the third example about the logic error, it makes more sense to not pass in null to a constructor or method.</p>\n<p>Either way, it is important to give your user the best possible experience with your program and thus keep the user notified of any errors that may occur and thus give them the best experience.</p>","frontmatter":{"title":"Exception Handling and why you should care.","subtitle":"Try and catch that exception, keeping your user happy","date":"October, 26, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"exceptions-vs-errors.png","thumbnail":"exceptions-vs-errors.png","teaser":"exceptions-vs-errors.png","credit":"http://rypress.com","creditlink":"http://rypress.com/tutorials/objective-c/exceptions"},"path":"/tech/exceptions","tags":["exceptions","error-handling"],"excerpt":"No one likes errors, especially when they occur frequently and unchecked. As developers we constantly check for errors and not that the program is running as expected, but rather it is handling the errors as it should. There is not perfect program that will never encounter errors, the best programs are the ones that handle **exceptions** really well and keep the user happy and oblivous of the errors being handled"}}},"pageContext":{"prev":{"html":"<p>Abstraction and interfaces are common words that most programmers will come across when desigining systems and platforms. They are very useful concepts that any programmer who knows about Object Oriented Programming (OOP) should grasp and know like the back of their hand. They not only make code readable and testable, but also make your life a hell of a lot easier.</p>\n<p>Alright,let us get to it, so, I shall write about abstraction and interface in the Java programming language. However these very concepts can be applied to any OOP language out there.</p>\n<h2>Abstract classes</h2>\n<p>These are classes that contain one or more abstract methods. An abstract method is one that is declared but contains no implementation (without braces and followed by a semi-colon).</p>\n<pre><code class=\"language-java\">abstract void drive(double speed);\n</code></pre>\n<p>If a class contains abstract methods then the class <strong>must</strong> be declared abstract. When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class. However, if it does not, then the subclass must also be declared abstract.</p>\n<pre><code class=\"language-java\">abstract class Car{\n\n    abstract void changeGear(int number);\n}\n</code></pre>\n<p>Take for example we are modelling animals, we may start the hierachy with a base class of <em>Animal</em>. Animals are capable of several things, flying, running, swimming, crawling. They are also capable of sleeping, eating, dreaming. In this regard, the many types of animals have similar characteristics, like eating and sleeping. So the common operations performed by animals, but in a different way is a good candidate for abstraction which will force the subclasses (or child classes) to provide their own implementation. Let us take the following example.</p>\n<pre><code class=\"language-java\">    abstract class Animal {\n\n        /**Types of food the animals eat*/\n        public abstract void eat(String food);\n\n        /**How long the anima will sleep*/\n        public void sleep(int hours){\n            try{\n                // 1000 milliseconds * 60 seconds * 60 minutes * hours\n                Thread.sleep(1000 * 60 *60 *hours);\n            }catch (InterruptedException ie){\n                ie.printStackTrace();\n            }\n        }\n\n        /**The sound the animals make*/\n        public abstract void makeNoise();\n    }\n</code></pre>\n<p>The <strong>abstract</strong> keyword is used in both the class and the method to declare that the class and the method are abstract. Any class that subclasses <code>Animal</code> must implement the <code>makeNoise</code> and the <code>eat</code> functions.</p>\n<pre><code class=\"language-java\">    public class Cat extends Animal{\n        @Override\n        public void eat(String food) {\n            System.out.println(\"Cats eat \" + food);\n        }\n\n        @Override\n        public void makeNoise() {\n            System.out.println(\"Cats meow a lot\");\n        }\n    }\n</code></pre>\n<p>Alternatively we could declare Animal as an interface instead of using an abstract class, and have the Cat implement the interface. You could - but you'd also need to implement the sleep method. By using abstract classes, you can inherit the implementation of other (non-abstract) methods. You can't do that with interfaces - an interface cannot provide any method implementations.</p>\n<h2>Abstract classes and Interfaces</h2>\n<p>Now, that we have a basic understanding of abstraction, we shal compare that to interfaces. What is the difference? They are similar in a way, but are obviously not the same. You <strong>can't</strong> instantiate an abstract class and they may contain a mix of methods containing a mix of methods declared with or without an implementation. With abstract classes, you can declare fields that are not static and final, and define public, protected, and private concrete methods. With interfaces on the other hand, all fields are automatically public, static, and final, and all methods that you declare or define (as default methods) are public. In addition, you can extend only one class, whether or not it is abstract, whereas you can implement any number of interfaces (basics of OOP).</p>\n<h2>Instances to use Abstract classes and Interfaces.</h2>\n<p>Abstract classes are best used in such scenarios:</p>\n<ul>\n<li>You want to share code among several closely related classes.</li>\n<li>You expect that classes that extend your abstract class have many common methods or fields, or require access modifiers other than public (such as protected and private).</li>\n<li>You want to declare non-static or non-final fields. This enables you to define methods that can access and modify the state of the object to which they belong.</li>\n</ul>\n<p>Interfaces on the other hand are best used in such scenarios:</p>\n<ul>\n<li>You expect that unrelated classes would implement your interface.</li>\n<li>You want to specify the behavior of a particular data type, but not concerned about who implements its behavior.</li>\n<li>You want to take advantage of multiple inheritance of type.</li>\n</ul>\n<p>These obviously are not the only scenarios, they are just but examples. A real practical example of Abstraction is found <a href=\"https://github.com/BrianLusina/Java-Playground/tree/master/AbstractionInterfaces/MotorVehicles\">here</a>.</p>","id":"65bbf04c-f57d-5914-83d7-79a1e45597a9","timeToRead":3,"frontmatter":{"title":"Abstraction and interfaces","subtitle":"When to use abstraction and when to use interfaces","excerpt":"Abstraction and interfaces are common words that most programmers will come across when desigining systems and platforms. They are very useful concepts that any programmer who knows about Object Oriented Programming (OOP) should grasp and know like the back of their hand. They not only make code readable and testable, but also make your life a hell of a lot easier.","path":"/tech/abstraction-and-interfaces","category":"tech","date":"October 28, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"abstract_class_interfaces.png","thumbnail":"abstract_class_interfaces.png","teaser":"abstract_class_interfaces.png","credit":"Agile Code","creditlink":"http://agile-code.com"},"tags":["abstraction","interfaces","oop"],"published":true}},"next":{"html":"<p>JavaScript is one of the most powerful languages in the current era and it is quickly gaining ground. What makes it powerful is its dynamic nature and ability to manipulate the DOM. This manipulation is at the heart of the modern, interactive web. Unfortunately, it is also a lot slower than most JavaScript operations.</p>\n<p>This is made worse by the fact that most JavaScript frameworks update the DOM much more than they have to.</p>\n<p>As an example, let's say that you have a list that contains ten items. You check off the first item. Most JavaScript frameworks would rebuild the entire list. That's ten times more work than necessary! Only one item changed, but the remaining nine get rebuilt exactly how they were before.</p>\n<p>Rebuilding a list is no big deal to a web browser, but modern websites can use huge amounts of DOM manipulation. Inefficient updating has become a serious problem. This could prove slow for the user and thus grant bad User experience, making it seem as if the website is slow.</p>\n<p>To address this problem, the people at React popularized something called the virtual DOM.</p>\n<h2>Virtual DOM</h2>\n<p>For every DOM object, there is a corresponding \"virtual DOM object.\" This is a representation of a DOM object, like a lightweight copy.</p>\n<p>This has the same properties as a real DOM object, but it lacks the power to directly change what's on the screen.</p>\n<p>Manipulating the DOM is slow, but manipulating the virtual DOM is much faster, because nothing gets drawn onscreen. Think of manipulating the virtual DOM as editing a blueprint, as opposed to moving rooms in an actual house.</p>\n<p>When you render a JSX element, every single virtual DOM object gets updated.</p>\n<p>This sounds incredibly inefficient, but the cost is insignificant because the virtual DOM can update so quickly because nothing is drawn onscreen.</p>\n<p>Once the virtual DOM has updated, then React compares the virtual DOM with a virtual DOM snapshot that was taken right before the update.</p>\n<p>By comparing the new virtual DOM with a pre-update version, React figures out exactly which virtual DOM objects have changed. This process is called <strong>diffing.</strong></p>\n<p>Once React knows which virtual DOM objects have changed, then React updates those objects, and only those objects, on the real DOM. In our example from earlier, React would be smart enough to rebuild your one checked-off list-item, and leave the rest of your list alone.</p>\n<p>This makes a big difference! React can update only the necessary parts of the DOM. React's reputation for performance comes largely from this innovation.</p>\n<p>In summary, here's what happens when you try to update the DOM in React:</p>\n<ol>\n<li>The entire virtual DOM gets updated.</li>\n<li>The virtual DOM gets compared to what it looked like before you updated it.</li>\n<li>React figures out which objects have changed.</li>\n<li>The changed objects, and the changed objects only, get updated on the real DOM</li>\n<li>Changes on the real DOM cause the screen to change.</li>\n</ol>","id":"da7d7200-350b-54d9-899e-2626c6dd06c6","timeToRead":2,"frontmatter":{"title":"The Virtual DOM with React","subtitle":"virtual DOM manipulation with ReactJS","excerpt":"JavaScript is one of the most powerful languages in the current era and it is quickly gaining ground. What makes it powerful is its dynamic nature and ability to manipulate the DOM. This manipulation is at the heart of the modern, interactive web. Unfortunately, it is also a lot slower than most JavaScript operations.","path":"/tech/virtualdom","category":"tech","date":"October 09, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"virtualdom.png","thumbnail":"virtualdom.png","teaser":"virtualdom.png","credit":"Slides.com","creditlink":"http://slides.com/brandonkonkle/exploring-virtual-dom/"},"tags":["virtualdom","reactjs","javascript"],"published":true}}}}}