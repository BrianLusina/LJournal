{"componentChunkName":"component---src-templates-page-page-jsx","path":"/page/5","result":{"pageContext":{"posts":[{"html":"<p>No one likes errors, especially when they occur frequently and unchecked. As developers we constantly check for errors and not that the program is running as expected, but rather it is handling the errors as it should. There is not perfect program that will never encounter errors, the best programs are the ones that handle <strong>exceptions</strong> really well and keep the user happy and oblivous of the errors being handled. It is important that errors are handled appropriately and also that they give the user a meaningful message. Unfortunately, you never know that kind of errors you may encounter in your program. Some are caused by the code you write, others by external factors that your program has nothing to do with, like a poor internet connection or hardware malfunction. In both cases, your program should be able to handle these exceptions and keep running or exit, whichever suits you need at the time.</p>\n<p>Of course, before delving deeper into the exceptions, we should all be on the same page as to what exceptions are.</p>\n<p><strong>Exceptions</strong> as defined by Java Documentation is an event, which occurs during the execution of a program, that disrupts the normal flow of the program's instructions. This disruption of the normal flow of the program should be handled with care and enable the user to keep interacting with the program despite this interruption, otherwise you will have poor ratings, no one wants that.</p>\n<p>I will not delve into details about how a program determines an error and normal flow of a program. I will dive immediately into which type of exceptions we should look out for.</p>\n<ol>\n<li>\n<p>Checked Exception</p>\n<p>Say, you are creating a program that requires user input, such as their name, phone number, email and such, for validation purposes. Maybe you need these inputs for authorization or for sign up to your platform. It is possible that the user will provide an invalid email address and as such you will need to validate these parameters before passing them to a function or class that will handle the authentication. Normally, if you are developing for Android it will be easy to validate this field in the XML layout, but what if you are checking with a server and you have to fetch a response in order to proceed. If the response returns <em>Null</em> then you need to be able to handle such a response.</p>\n<p>A well-written program will catch this exception and notify the user of the mistake, possibly prompting for a correct email address if the email does not exist in the system's database.</p>\n</li>\n<li>\n<p>Error</p>\n<p>These are the kind of errors that will occur that are outside the application's scope of handling. These kind of errors may involve poor internet connection on the part of the user or maybe they are experiencing hardware failure. The application can not anticipate that it will happen as it may occur randomly. However, it should be able to catch this exception and notify the user of the failure to execute the program. In the example above, maybe in the middle of execution of request to ther server, after having validate the user credentials, the internet connection is abruptly cut and the user is not properly authenticated with the system, it is at this point that the application should notify the user of the problem, catch this expection and try again at a late time. It may make sense in some instances to print a stacktrace and exit the program.</p>\n</li>\n<li>\n<p>Runtime Exception</p>\n<p>These are exceptional conditions that are internal to the application, and that the application usually cannot anticipate or recover from. These type of errors are usually because of an improper use of an API or a logic error. If we use the abov example still, if a logic error causes <code>null</code> to be passed instead of a <code>username</code> then the method handling authentication will throw a <strong>NullPointerException</strong>. Now normally it may make sense to catch this exception and notify the user, but it makes even more sense to eliminate this bug completely and not pass null to the method or constructor of a class.</p>\n</li>\n</ol>\n<p>Now, you may have noticed something similar about the last two types of exceptions. Errors and runtime exceptions are collectively known as <strong>unchecked exceptions</strong> and this is because they do not need to be <em>caught</em> as much as the 1st type. This is normally because they could be caused by external factors that the app can not manage and it will reduce complexity and make more sense for the application to terminate and inform the user of the same. In other instances like in the third example about the logic error, it makes more sense to not pass in null to a constructor or method.</p>\n<p>Either way, it is important to give your user the best possible experience with your program and thus keep the user notified of any errors that may occur and thus give them the best experience.</p>","id":"19d640e0-9b50-5692-88e1-9f0410ad4fcb","timeToRead":3,"frontmatter":{"title":"Exception Handling and why you should care.","subtitle":"Try and catch that exception, keeping your user happy","excerpt":"No one likes errors, especially when they occur frequently and unchecked. As developers we constantly check for errors and not that the program is running as expected, but rather it is handling the errors as it should. There is not perfect program that will never encounter errors, the best programs are the ones that handle **exceptions** really well and keep the user happy and oblivous of the errors being handled","path":"/tech/exceptions","category":"tech","date":"October 26, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"exceptions-vs-errors.png","thumbnail":"exceptions-vs-errors.png","teaser":"exceptions-vs-errors.png","credit":"http://rypress.com","creditlink":"http://rypress.com/tutorials/objective-c/exceptions"},"tags":["exceptions","error-handling"],"published":true}},{"html":"<p>JavaScript is one of the most powerful languages in the current era and it is quickly gaining ground. What makes it powerful is its dynamic nature and ability to manipulate the DOM. This manipulation is at the heart of the modern, interactive web. Unfortunately, it is also a lot slower than most JavaScript operations.</p>\n<p>This is made worse by the fact that most JavaScript frameworks update the DOM much more than they have to.</p>\n<p>As an example, let's say that you have a list that contains ten items. You check off the first item. Most JavaScript frameworks would rebuild the entire list. That's ten times more work than necessary! Only one item changed, but the remaining nine get rebuilt exactly how they were before.</p>\n<p>Rebuilding a list is no big deal to a web browser, but modern websites can use huge amounts of DOM manipulation. Inefficient updating has become a serious problem. This could prove slow for the user and thus grant bad User experience, making it seem as if the website is slow.</p>\n<p>To address this problem, the people at React popularized something called the virtual DOM.</p>\n<h2>Virtual DOM</h2>\n<p>For every DOM object, there is a corresponding \"virtual DOM object.\" This is a representation of a DOM object, like a lightweight copy.</p>\n<p>This has the same properties as a real DOM object, but it lacks the power to directly change what's on the screen.</p>\n<p>Manipulating the DOM is slow, but manipulating the virtual DOM is much faster, because nothing gets drawn onscreen. Think of manipulating the virtual DOM as editing a blueprint, as opposed to moving rooms in an actual house.</p>\n<p>When you render a JSX element, every single virtual DOM object gets updated.</p>\n<p>This sounds incredibly inefficient, but the cost is insignificant because the virtual DOM can update so quickly because nothing is drawn onscreen.</p>\n<p>Once the virtual DOM has updated, then React compares the virtual DOM with a virtual DOM snapshot that was taken right before the update.</p>\n<p>By comparing the new virtual DOM with a pre-update version, React figures out exactly which virtual DOM objects have changed. This process is called <strong>diffing.</strong></p>\n<p>Once React knows which virtual DOM objects have changed, then React updates those objects, and only those objects, on the real DOM. In our example from earlier, React would be smart enough to rebuild your one checked-off list-item, and leave the rest of your list alone.</p>\n<p>This makes a big difference! React can update only the necessary parts of the DOM. React's reputation for performance comes largely from this innovation.</p>\n<p>In summary, here's what happens when you try to update the DOM in React:</p>\n<ol>\n<li>The entire virtual DOM gets updated.</li>\n<li>The virtual DOM gets compared to what it looked like before you updated it.</li>\n<li>React figures out which objects have changed.</li>\n<li>The changed objects, and the changed objects only, get updated on the real DOM</li>\n<li>Changes on the real DOM cause the screen to change.</li>\n</ol>","id":"da7d7200-350b-54d9-899e-2626c6dd06c6","timeToRead":2,"frontmatter":{"title":"The Virtual DOM with React","subtitle":"virtual DOM manipulation with ReactJS","excerpt":"JavaScript is one of the most powerful languages in the current era and it is quickly gaining ground. What makes it powerful is its dynamic nature and ability to manipulate the DOM. This manipulation is at the heart of the modern, interactive web. Unfortunately, it is also a lot slower than most JavaScript operations.","path":"/tech/virtualdom","category":"tech","date":"October 09, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"virtualdom.png","thumbnail":"virtualdom.png","teaser":"virtualdom.png","credit":"Slides.com","creditlink":"http://slides.com/brandonkonkle/exploring-virtual-dom/"},"tags":["virtualdom","reactjs","javascript"],"published":true}},{"html":"<p>Gone are the days of clear definitions of responsibility, at least in terms of technology and developing software. These are not the times when companies and businesses have clearly defined roles for their employees such that everyone is only closed to the skill set that they deem to be the most proficient in. These are the times when one role for an employee is never going to be enough, or rather is never going to be the case, especially not with how the world is evolving.</p>\n<p>No more are the days where web developers, designers, application programmers and database administrators stick to one predefined role each sitting in their own little area worrying about only their little part of the puzzle with clear definitions of responsibility. This venerable model heralded the age of web and app development, but it also contained the seeds of its own destruction, creating a world of silos, isolated and closed knowledge – a world of “not my problem”.</p>\n<p>As these complex systems have matured the effort, and the risks, to change a product have become significant and difficult to achieve. As this era, and the solutions built around it, draws to an end, something new awaits.</p>\n<p>The web developer jobs of today, the trendsetters and game changers, do not push bottlenecks through waterfalls. From tech startup to large-scale enterprise, the skills to succeed and adapt require a different mindset.\nThe modern developer requires clear methodologies to work with, a supportive organisational culture and tools that automate the simple tasks. This cultural change does not just apply to software developers – business leaders drive this change and provide the tools for their organisation to thrive.</p>\n<p>To achieve this way of working you need a more rounded IT professional, or what the industry refers to as a 'T-shaped developer'. A T-shaped developer has one or more deep skill-sets of knowledge complemented with broad generalist knowledge across an entire solution.\nSometime known as full-stack developers, these rounded individuals are the most in-demand devs – in a modern world that wants staff who can do front end, can make middleware sing and utilise the terminal on their chosen operating system like a ninja, and knows how to test.</p>\n<p>This sounds like the perfect developer. I mean they can build anything with anything that solves anything and passes any test. Sounds like coding 'god'. However unreal this sounds this is becoming the new norm as the world of tech continually evolves demanding more and more developers to up their game and improve their knowledge base.</p>\n<p>Why these developers are called T-Shaped is becase the vertical line of the T represents the depth of expertise in a field while the horizontal line represents the breadth of knowledge.</p>\n<p>In as much as this may sound like being an expert in a particular programming language and knowing a ton of others as well, it actually may have different meanings to others.</p>\n<p>It could be a developer who has a specialty (backend, frontend, or a particular technology stack) but is comfortable doing a wide range of development work, product management and design thinking. A backend developer needs to know how their work interacts with a front-end developer's. Additionally, they need to empathize with designers and end users. Often certain kinds of skills are grouped together and people who are really truly good in a specific niche need to understand how their niche effects things holistically.</p>\n<p>This does sound like one heck of a developer to have on your team. The job would be done well as they would be able to picth in on every aspect of the product being built. However, there is a case against hiring a T-Shaped developer. Some managers would not do this.</p>\n<p>The argument.</p>\n<p>You don’t want a team of T-shaped developers for two reasons.</p>\n<ol>\n<li>They lack creativity. If there is one deep expert on each topic, they have nobody to bounce ideas off and nobody to pull them back on track if they fixate on a bad design.</li>\n<li>Communication bottlenecks. The deep expert on each topic has to simplify his communication to his teammates to an extent that he cannot properly articulate his reasoning.</li>\n</ol>\n<p>The solution offered is to hire V-shaped developers as they have a peak competency at the tip of the V but have adequate skills in a number of adjacent areas ensuring that there is one expert and a least one sufficiently knowledgeable team member in every area.</p>\n<p>Despite these two reasons (and possibly more), there are companies that have grown rapidly due to T-Shaped developers. Some even don’t focus on finding someone who is an expert in a particular subject (an iOS or Android developer for example) but rather a full-stack developer that can be successful in contributing to a project end to end. This allows creation of small product teams with high responsibility and the flexibility to remain technologically agnostic. It also tends to naturally let the developer grow in different areas while still maintaining certain expertise.</p>\n<p>This may be one of the main reasons that the T-shaped developer will be the new norm and standard. After all, aren't programming languages, frameworks and technologies here to create solutions? It will not matter whether you solve a problem in one language and someone solves it using some framework and creates a new business with some other new piece of technology. It is even better if you can do all three, or rather be able to have a wide knowledge base that lets you cut across and learn.</p>","id":"399df0bd-b79b-5e5a-954d-2cd937b2efca","timeToRead":4,"frontmatter":{"title":"T-Shaped Developers, the new norm","subtitle":"The T-shaped developers, A new species of developers","excerpt":"Gone are the days of clear definitions of responsibility, at least in terms of technology and developing software. These are not the times when companies and businesses have clearly defined roles for their employees such that everyone is only closed to the skill set that they deem to be the most proficient in. These are the times when one role for an employee is never going to be enough, or rather is never going to be the case, especially not with how the world is evolving","path":"/tech/t-shaped-dev","category":"tech","date":"September 28, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"t-shaped.jpg","thumbnail":"t-shaped.jpg","teaser":"t-shaped.jpg","credit":null,"creditlink":null},"tags":["software","development","tech"],"published":true}},{"html":"<p>Android component is simply a piece of code that has a well defined life cycle. e.g. Activity, Reciever, Service. The core building blocks or fundamental components of Android are:</p>\n<ol>\n<li>Receivers</li>\n<li>Activities</li>\n<li>Views</li>\n<li>Intents</li>\n<li>Services</li>\n<li>Content Providers</li>\n<li>Fragments</li>\n<li>AndroidManifest.xml</li>\n</ol>\n<h2>Activity</h2>\n<p>This is simply a class that represents a single screen. They dictate the UI and handle user interaction to the smart phone screen.</p>\n<h2>Services</h2>\n<p>Background process that can run for a long time. They are of 2 types:</p>\n<ul>\n<li><strong>Local service</strong>: accessed from within the application.</li>\n<li>**Remote service **: accessed remotely from other applications running on the same device.</li>\n</ul>\n<p>A service might play music in the background while the user is in a different application, or it might fetch data over the network without blocking user interaction with an activity. A service is implemented as a subclass of <code>Service</code> class.</p>\n<h2>Broadcast Recievers</h2>\n<p>They handle communication between Android OS and applications. They simply respond to broadcast messages from other applications or from the system. For example, apps can initiate broadcasts to let other applications know that some data has been downloaded to the device and is available for them to use, so this is broadcast receiver which will intercept this communication and will initiate appropriate action.</p>\n<p>A broadcast receiver is implemented as a subclass of <code>BroadcastReceiver</code> class and each message is broadcaster as an <code>Intent</code> object.</p>\n<pre><code class=\"language-java\">    public class MyReciever extends BroadcastReceiver{\n        public void onReceive(context,intent){\n\n        }\n    }\n</code></pre>\n<h2>Content Provider</h2>\n<p>Content Providers provide content to applications by encapsulating data and provide it to applications through a single ContentResolver interface.\nThey are required if you need to share data between multiple applications, e.g. contacts data is used by multile applications and mist be stored in a content provider.</p>\n<h2>View</h2>\n<p>A view is the UI element such as button, lable, Text field, Image.</p>\n<h2>Intent</h2>\n<p>Used to invoke components. It is mainly used to:</p>\n<ul>\n<li>Start a service</li>\n<li>Launch an activity</li>\n<li>Display a web page</li>\n<li>Display a list of contacts</li>\n<li>Broadcast a message</li>\n<li>Dial a phone</li>\n</ul>\n<p>Basically they are messages wiring components together.</p>\n<h2>Fragment</h2>\n<p>These are like part of an Activity. An activity can display one or more fragments on the screen at the same time.</p>\n<h2>AndroidManifest.xml</h2>\n<p>Contains information about activites, content providers, permissions. It is the configuration file for the application.</p>\n<h2>Resources</h2>\n<p>External elements such as strings, constants and drawable pictures.</p>","id":"a6836208-9627-5e83-a886-07b5410227ab","timeToRead":2,"frontmatter":{"title":"Android Building Blocks","subtitle":"Android components and building Blocks","excerpt":"Android component is simply a piece of code that has a well defined life cycle. e.g. Activity, Reciever, Service. The core building blocks or fundamental components of Android","path":"/tech/building-blocks-android","category":"tech","date":"September 25, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"android-core-building-blocks.png","thumbnail":"android-core-building-blocks.png","teaser":"android-core-building-blocks.png","credit":null,"creditlink":null},"tags":["Android","Serializable","Parcelable"],"published":true}},{"html":"<p>When creating Plain Old Java Objects (POJOs) in eith Android or Java, more specifically Java, the aim is to be able to <em>model</em> our data in a certain way. To enable easier addition to an Adapter or a database, even easier retrieval from a database using <strong>Jackson</strong> library (what Firebase uses to be able to store and retrieve data).</p>\n<p>It is best practice to model data in a specific way using POJO as it allows cleaner code and one also can be able to determine what exactly one object will contain. Say you are storing Employee data. An employee will obviously have data such as <em>name</em>, <em>phone</em> and <em>address</em>. These should be modelled to enable proper structure of each record we will be retrieving from an API (if creating for Android).</p>\n<p>Normally, typically, the model will look like this:</p>\n<pre><code class=\"language-java\">    public class Employee{\n        private String name;\n        private int phone;\n        private ArrayList&#x3C;String> address;\n\n        public Employee(String name, int phone, ArrayList&#x3C;String> address) {\n            this.name = name;\n            this.phone = phone;\n            this.address = address;\n        }\n\n        public ArrayList&#x3C;String> getAddress() {\n            if (!(address == null))\n                return address;\n            else\n                return new ArrayList&#x3C;String>();\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public String getAge() {\n            return age;\n        }\n    }\n</code></pre>\n<blockquote>\n<p>This is a typical POJO with <em>fields</em>, a <em>constructor</em> and <em>access methods</em>.</p>\n</blockquote>\n<p>In Android we know that we cannot just pass objects to activities. The objects must be either implements of <strong>Serializable</strong> or <strong>Parcelable</strong> interface to do this. This is where the problem with this class comes in. When trying to pass this object to any other activity it will pose a bit of a problem, of course there a work-arounds, but why stress yourself? KISS.</p>\n<h2>Enter Serializable and Parcelable</h2>\n<p>They both do what you expect them to do. They have similarities, but are not entirely the same.</p>\n<p><em>Serializable</em> is a standard <strong>Java</strong> interface. You simply mark a class Serializable by implementing the interface, and Java will automatically serialize it in certain situations.</p>\n<p><em>Parcelable</em> is an <strong>Android</strong> specific interface where you implement the serialization yourself. It was created to be far more efficient than Serializable, and to get around some problems with the default Java serialization scheme.</p>\n<h3>Serializable</h3>\n<p>As afformentioned serializable is a standard Java interface. You can just implement Serializable interface and add override methods.The problem with this approach is that <strong>reflection</strong> is used and it is a slow process. This method creates a lot of temporary objects and cause quite a bit of garbage collection. However, a serializable interface is easier to implement.</p>\n<pre><code class=\"language-java\">    public class Employee extends Serializable{\n        private String name;\n        private int phone;\n        private ArrayList&#x3C;String> address;\n\n        public Employee(String name, int phone, ArrayList&#x3C;String> address) {\n            super();\n            this.name = name;\n            this.phone = phone;\n            this.address = address;\n        }\n\n        public ArrayList&#x3C;String> getAddress() {\n            if (!(address == null))\n                return address;\n            else\n                return new ArrayList&#x3C;String>();\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public String getAge() {\n            return age;\n        }\n    }\n</code></pre>\n<blockquote>\n<p>Same implementation of Employee Object with the only differnce being its implementation. Notice the <code>super()</code> in the constructor.</p>\n</blockquote>\n<p>Say you have initialized Employee objects like so:</p>\n<pre><code class=\"language-java\">//Employee instance\nEmployee mEmployee = new Employee(\"name\",12345679,\"Address array here\");\n\n//Passing MyObjects instance via intent\nIntent mIntent = new Intent(FromActivity.this, ToActivity.class);\nmIntent.putExtra(\"UniqueKey\", mEmployee);\nstartActivity(mIntent);\n</code></pre>\n<blockquote>\n<p>This creates an instance of the Employee object, adds it to an intent and starts the next activity.</p>\n</blockquote>\n<p>In another class, we obtain the object.</p>\n<pre><code class=\"language-java\">Intent mIntent = getIntent();\nEmployee mEmployee = (Employee) mIntent.getSerializableExtra(\"UniqueKey\");\n</code></pre>\n<blockquote>\n<p>This obtains the object from the intent and casts it to Employee object.\nAllowing you to do as you please in the next activity with the obtain object.</p>\n</blockquote>\n<h3>Parcelable</h3>\n<p>Parcelable process is much faster than serializable. One of the reasons for this is that we are being explicit about the serialization process instead of using reflection to infer it. It also stands to reason that the code has been heavily optimized for this purpose.</p>\n<p>Using the same Employee class but implementing the Parcelable interface.</p>\n<pre><code class=\"language-java\">    import java.util.ArrayList;\n    import android.os.Parcel;\n    import android.os.Parcelable;\n\n    public class Employee extends Parcelable{\n        private String name;\n        private int phone;\n        private ArrayList&#x3C;String> address;\n\n        public Employee(String name, int phone, ArrayList&#x3C;String> address) {\n            this.name = name;\n            this.phone = phone;\n            this.address = address;\n        }\n\n        public Employee(Parcel source){\n            phone = source.readInt();\n            name = source.readString();\n            address = source.createStringArrayList();\n        }\n\n        @Override\n        public int describeContents() {\n            return 0;\n        }\n\n        @Override\n        public void writeToParcel(Parcel dest, int flags) {\n            dest.writeInt(phone);\n            dest.writeString(name);\n            dest.writeStringList(address);\n        }\n\n        public static final Creator&#x3C;Employee> CREATOR = new Creator&#x3C;Employee>() {\n\n        @Override\n        public Employee[] newArray(int size) {\n            return new Employee[size];\n        }\n\n        @Override\n        public Employee createFromParcel(Parcel source) {\n            return new Employee(source);\n        }\n        };\n\n        public ArrayList&#x3C;String> getAddress() {\n            if (!(address == null))\n                return address;\n            else\n                return new ArrayList&#x3C;String>();\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public String getAge() {\n            return age;\n        }\n    }\n</code></pre>\n<p>Using the same process of creating an instance of the <code>Employee</code> Object and passing it to an intent.</p>\n<pre><code class=\"language-java\">    Employee employee = new Employee(\"name\",\"age\",\"Address array here\");\n\n    //Passing MyOjects instance\n    Intent mIntent = new Intent(FromActivity.this, ToActivity.class);\n    mIntent.putExtra(\"UniqueKey\", employee);\n    startActivity(mIntent);\n\n    //Getting MyObjects instance in another activity\n    Intent mIntent = getIntent();\n    Employee workorder = (Employee) mIntent.getParcelable(\"UniqueKey\");\n\n    //You can pass Arraylist of Parceble obect as below\n    //Array of MyObjects\n    ArrayList&#x3C;Employee> mEmployees;\n\n    //Passing Employee instance\n    Intent mIntent = new Intent(FromActivity.this, ToActivity.class);\n    mIntent.putParcelableArrayListExtra(\"UniqueKey\", mEmployees);\n    startActivity(mIntent);\n\n    // in another activity\n    //Getting Employee instance\n    Intent mIntent = getIntent();\n    ArrayList&#x3C;Employee> mEmployees = mIntent.getParcelableArrayList(\"UniqueKey\");\n</code></pre>\n<h2>In Conclusion</h2>\n<ol>\n<li>Parcelable is faster than serializable interface</li>\n<li>Parcelable interface takes more time for implemetation compared to serializable interface</li>\n<li>serializable interface is easier to implement</li>\n<li>serializable interface create a lot of temporary objects and cause quite a bit of garbage collection</li>\n<li>Parcelable array can be pass via Intent in android</li>\n</ol>\n<p>These are just some of the differences between the two interfaces and of course there is not standard way, however it is always good to have the option of switching between the two.</p>","id":"d1782561-832c-5915-aa3b-797fd8370f7a","timeToRead":5,"frontmatter":{"title":"Serializable and Parcelable","subtitle":"Difference between Serializable Java interface and Android Parcelable interface","excerpt":"When creating Plain Old Java Objects (POJOs) in eith Android or Java, more specifically Java, the aim is to be able to _model_ our data in a certain way. To enable easier addition to an Adapter or a database, even easier retrieval from a database using **Jackson** library (what Firebase uses to be able to store and retrieve data).","path":"/tech/serializable-parcelable","category":"tech","date":"September 24, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"parcelable_vs_serializable.jpg","thumbnail":"parcelable_vs_serializable.jpg","teaser":"parcelable_vs_serializable.jpg","credit":null,"creditlink":null},"tags":["Android","Serializable","Parcelable"],"published":true}}],"page":5,"pagesSum":9,"prevPath":"/page/4","nextPath":"/page/6"}}}