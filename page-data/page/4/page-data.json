{"componentChunkName":"component---src-templates-page-page-jsx","path":"/page/4","result":{"pageContext":{"posts":[{"html":"<p>Binary trees are part of a data structure known as <code>Trees</code>, yeah, I know, the forefathers of computer science and software engineering were quite creative. They were quite observant. Trees, more or less, look like trees, like the literal trees in nature. Now, that we have the most basic and almost worst analogy out there, what are binary trees?</p>\n<p>I shall give a basic and brief introduction into <code>binary trees</code>, this will assume that you have knowledge on tree data structures. Even if you don't, you can still read on, they are all pretty much related, so the knowledge is transferable.</p>\n<p>A binary tree is a <code>tree</code> where every node has 2 or fewer children. The children are usually called <code>left</code> and <code>right</code>.\nA simple implementation in <code>Python</code>:</p>\n<pre><code class=\"language-python\">class BinaryTreeNode(object):\n    def __init__(self, value):\n        self.value = value\n         self.left = None\n         self.right = None\n</code></pre>\n<blockquote>\n<p>A class definition for a Binary Tree Node in Python</p>\n</blockquote>\n<p>In JavaScript:</p>\n<pre><code class=\"language-javascript\">function BinaryTreeNode(value) {\n  this.value = value\n  this.left = null\n  this.right = null\n}\n</code></pre>\n<blockquote>\n<p>An object definition in JavaScript</p>\n</blockquote>\n<p>In Java:</p>\n<pre><code class=\"language-java\">public class &#x3C;T> BinaryTreeNode{\n    public T value;\n    public BinaryTreeNode left;\n    public BinaryTreeNode right;\n\n    public BinaryTreeNode(T value){\n        this.value = value;\n    }\n}\n</code></pre>\n<blockquote>\n<p>Binary Tree node implementation of Binary Tree node in Java, this uses T to define objects.</p>\n</blockquote>\n<p>And finally in Ruby:</p>\n<pre><code class=\"language-ruby\">class BinaryTreeNode\n\n    attr_accessor :value, :left, :right\n\n    def initialize(value)\n        @value = value\n        @left  = nil\n        @right = nil\n    end\nend\n</code></pre>\n<p>Why these languages? Well, because I am familiar with them and also to show that it does not matter the language, the implementation of a data structure is usually the same.</p>\n<p><img src=\"https://www.interviewcake.com/images/svgs/binary_tree__depth_5.svg?bust=138\" alt=\"binary tree\"></p>\n<blockquote>\n<p>Binary tree data structure, you will notice, it pretty much looks like a tree.</p>\n</blockquote>\n<p>This particular example is special because every level of the tree is completely full. There are no \"gaps.\" We call this kind of tree \"perfect.\"</p>\n<p>Binary trees have a few interesting properties when they're perfect:</p>\n<ol>\n<li>The number of total nodes on <em>each</em> doubles as we move down the tree\n<img src=\"https://www.interviewcake.com/images/svgs/binary_tree__depth_5_with_number_of_nodes_labelled.svg?bust=138\" alt=\"perfectBinaryTree\"></li>\n<li>\n<p>The number of nodes on the last level is equal to the sum of all the nodes on other levels(plus 1)\nLet's call the number of nodes <code>n</code>, and the height of the tree <code>h</code>. <code>h</code> can also be thought of as the <em>number of levels</em>. If we had <code>h</code>, how could we calculate <code>n</code>?\nLet's just add up the number of nodes on each level! How many nodes are on each level?\nIf we zero-index the levels, the number of nodes on the <code>x</code>th level is exactly <code>2^x</code>!</p>\n<ul>\n<li>Level 0: 2^0 nodes</li>\n<li>Level 1: 2^1 nodes,</li>\n<li>Level 2: 2^2 nodes,</li>\n<li>Level 3: 2^3 nodes,</li>\n<li>etc</li>\n</ul>\n<p>So our total number of nodes is:\n$$n= 2^0 + 2^1 +2^2 +2^3 +...+2^{h−1}$$ > Why only up to 2^{h-1} ? Notice that we started counting our levels at 0. So if > we have h levels in total, the last level is actually the \"h−1\"-th level. > That means the number of nodes on the last level is 2^{h-1}.</p>\n<p>But we can simplify. Property 2 tells us that the number of nodes on the last level is (1 more than) half of the total number of nodes, so we can just take the number of nodes on the last level, multiply it by 2, and subtract 1 to get the number of nodes overall.\nWe know the number of nodes on the last level is 2^{h-1}, So:</p>\n<p>$$ n = 2^{h-1} * 2 - 1$$\n$$n = 2^{h−1}∗2^{1}−1$$\n$$n = 2^{h-1+1}- 1$$\n$$n = 2^{h} - 1$$</p>\n<p>So that's how we can go from <code>h</code> to <code>n</code>. What about the other direction?</p>\n<p>We need to bring the <code>h</code> down from the exponent. That's what logs are for!</p>\n<p>First, some quick review on Algebra. $$log<em>{10}(100)$$ simply means, \"What power must you raise 10 to in order to get 100?\". Which is 2, because $$10^2 = 100$$.\nWe can use logs in algebra to bring variables down from exponents by exploiting the fact that we can simplify $$log</em>{10}(10^2)$$. What power must we raise 10 to in order to get $$10^2$$?\nThat's easy — it's 2.</p>\n<p>So in this case we can take the $$log_{2}$$ of both sides:</p>\n<p>$$n = 2^{h} - 1$$\n$$n + 1 = 2^{h}$$\n$$log<em>{2}{((n+1))} = log</em>{2}{(2^{h})}$$\n$$log_{2}{(n+1)} = h$$</p>\n</li>\n</ol>\n<h3>Conclusion</h3>\n<p>So that's the relationship between height and total nodes in a perfect binary tree.\nI know it involved a bit of Math, which you did not want nor expect, however, this will make the programs you write faster and better and of course easier to maintain and debug.</p>\n<p>Let us plant more trees!</p>","id":"0a0147ca-7a5d-56ed-a4bb-33f6de4c79d3","timeToRead":4,"frontmatter":{"title":"Perfect Binary Tree","subtitle":"A gentle introduction to perfect binary trees","excerpt":"Binary trees are part of a data structure known as `Trees`, yeah, I know, the forefathers of computer science and software engineering were quite creative. They were quite observant. Trees, more or less, look like trees, like the literal trees in nature. Now, that we have the most basic and almost worst analogy out there, what are binary trees?","path":"/tech/binary-tree","category":"tech","date":"January 26, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"binary_tree.png","thumbnail":"binary_tree.png","teaser":"binary_tree.png","credit":"Quora","creditlink":null},"tags":["algorithms","data-structures","binary-tree"],"published":true}},{"html":"<p>The <strong>Ruin Theory</strong> or <em>surplus process</em> or <em>risk process</em> defines when a company is most likely to go bankrupt given a constant flow of income and random outflow of cash. This is used in most businesses to determine for how long the company can be expected to be in operation before their wallet does not allow them to continue.</p>\n<p>Of course this is all probability and does not give an exact date or exact metrics as to when or high likely this will occur. However, it does help a company properly assess where they are currently and where they should avoid given current circumstances are unfavorable.</p>\n<p>Let us assume that a business starts with an initial capital amount. All businesses have constant income from sell of services or goods, or in the case of insurance companies from premium income. Additionally, these same businesses have cash outflow, which oftentimes is random and can not be accurately predicted. These cash outflows are random in both timing and amount and thus a company ought to be careful and ensure that their initial capital does not fall below 0 or is less than the cash outflow at any given time or they will face what is known as <strong>ruin</strong>(bankruptcy).</p>\n<p>As you can imagine, this involves a lot of mathematical calculation and often graphs to properly access when the company may experience ruin. Since the cash inflow is constant and can be determined, what is left to determine is the time and amount of cash outflow. Once these two random variables are determined, then the whole process is more visible and can be properly drawn on paper.</p>\n<p>This process can be outlined by the graph below:</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/en/thumb/6/6b/Samplepathcompoundpoisson.JPG/350px-Samplepathcompoundpoisson.JPG\" alt=\"ruin process\"></p>\n<blockquote>\n<p>From our good friends Wikipedia</p>\n</blockquote>\n<p>Of course it looks a bit intimidating but a breakdown is coming right up. Before that though, we can see from this picture that there are 2 sides to the graph, the part below the X-axis is obviously bad, as it means the company is bankrupt. The vertical drops in the graph are the cash outflows and are dotted as we can not properly determine when they will occur. The diagonal lines are the cash inflow and those can be properly determined.\nThe graph does no start at coordinate <code>0,0</code> as this is the initial reserve or capital the company starts with.</p>","id":"47734391-8e85-591c-a5b0-40b42c7303e4","timeToRead":2,"frontmatter":{"title":"The Risk Process","subtitle":"A small breakdown of the risk process","excerpt":"A small breakdown of the risk process","path":"/finance/risk-process","category":"finance","date":"January 18, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"ruintheory.JPG","thumbnail":null,"teaser":"ruintheory.JPG","credit":"Wikipedia","creditlink":"https://en.wikipedia.org/wiki/Ruin_theory"},"tags":["Actuarial","Insurance","Money","business"],"published":true}},{"html":"<p>Following what I wrote about last <a href=\"https://brianlusina.github.io//money/non-life-actuarial-problems/\">time</a>(feel free to check it out), I will follow up with that and mention briefly the problems General insurance companies usually face when it comes to retaining risk especially when dealing with a portfolio.</p>\n<p>The factors are(for those who are rebels and just will not read my previous article :D), <em>capital a company has</em>, <em>risk willingness</em> and <em>profit margin</em>. These are the 3 main factors that determine what a company retains when it is faced with insuring a risk.</p>\n<p>Retention of a company will be high if these 3 factors are high. This is usually governed by this formula:</p>\n<p>$$Retention=(capital _ risk willingness _ profit margin)/unbalancness$$</p>\n<p>And it is from this funny looking formula that we are able to determine the 5 main types of problems:</p>\n<h3>1. Rating</h3>\n<p>This is faced in premium calculation and is usually characterized by the formula:</p>\n<p>$$Profit margin = (Retention _ unbalanceness) / (capital _ risk willingness)$$</p>\n<h3>2. Assessing Reserves</h3>\n<p>Characterized as <strong>contingency reserves</strong> or <strong>risk capital</strong> or <strong>catastrophe funds</strong>, this is determined by this formula:</p>\n<p>$$Capital = (Retention _ Unbalanceness) / (Profit Margin _ Risk)$$</p>\n<p>So as the name suggests, these are funds that are accessed when the company needs is in crisis.</p>\n<h3>3. Underwriting limit</h3>\n<p>This determines what amount of risk they should retain. Which is essentially the original formula:</p>\n<p>$$Retention=(capital _ risk willingness _ profit margin)/unbalancness$$</p>\n<h3>4. Risk Behavior</h3>\n<p>Companies' entrepreneurial attitude towards risk can be categorized as their behavior towards risk. This formula can be used to determine or measure how conservative or not a company ought to be given its current circumstances.</p>\n<p>$$Risk Willingness = (Retention _ Unbalanceness) / (Profit margin _ Capital)$$</p>\n<h3>5. Maximum tolerable risk load</h3>\n<p>A company may be able to bear on its gross account a certain amount of risk given its rate level, retention and financial strength as well as its behavior towards risk.</p>\n<p>$$Unbalanceness = (Capital _ Risk willingness _ Profit margin) / retention$$</p>\n<h2>Conclusion</h2>\n<p>As you will notice the 5 main problems are derived from the very same basic formula:</p>\n<p>$$Retention=(capital _ risk willingness _ profit margin)/unbalancness$$</p>\n<p>Most companies go by this formula, especially insurance companies. This is often used when governing how much they should retain on their account when they are faced with insuring a certain portfolio of risks.</p>","id":"963669af-139f-5a2d-b278-072660c150d2","timeToRead":2,"frontmatter":{"title":"5 Main types of Non-life insurance problems","subtitle":"Determining factors of capital retention in general insurance","excerpt":"Determining factors of capital retention in general insurance","path":"/finance/types-of-problems-in-non-life","category":"finance","date":"January 17, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"capital-retention-insurance.jpg","thumbnail":null,"teaser":"capital-retention-insurance.jpg","credit":"Shine.com","creditlink":"http://info.shine.com/article/talent-retention-is-a-big-challenge-for-insurance-firms/8814.html"},"tags":["Actuarial","Insurance","Money","business"],"published":true}},{"html":"<p>The title may not be as intuitive or as smart as it should be, but I assure that the title is the least of concerns. This may be a very common topic when it comes to the insurance sector, but, hey, why not shed some more light on it anyway.</p>\n<p>Insurance is very critical to business and in order for these businesses to keep operating despite calamities, they need insurance to ensure that no matter what happens they can keep their doors open.</p>\n<p>But, this is on the side of businesses and that is entirely different, today I shall shed some light on the fundamental problems of <em>Non life insurance</em> on Insurance companies. Call it flipping the coin and viewing it from the other side.</p>\n<p>This is a high-level view of what I am talking about.</p>\n<p>Actuaries deal with all kinds of mathematical and statistical problems in insurance. Insurance companies accept risks (potential claims) from their clients against a certain price called the premium. If a risk or a portfolio of risks is too large for a company, it will pass parts of it to one or several companies (its <em>re-insurance</em>) and remain with a part of it (its <em>retention</em>). If a risk is very large, some re-insurers pass parts of the acceptances to other companies so that the original risk or portfolio is covered by an entire network of insurers and re-insurance arrangements between a number of companies each of them carrying the retention they deem appropriate. Therefore, the amount of a company retains depend on a lot of things:</p>\n<h3>Capital of a company</h3>\n<p>This is obviously a big deal. A company with a large capital base can afford to retain more on its account than a company with a smaller capital base.</p>\n<h3>Management risk willingness</h3>\n<p>This all depends on the management and their risk appetite. The only question to ask here is <em>is the management willing to take risks?</em>. And this usually leads to, <em>if so, how much?</em>. A manager with a smaller risk appetite will not take as much risk as his/her counterpart. Thus we expect the former to retain less on the company account.</p>\n<h3>Profitability of the company</h3>\n<p>How profitable will be company be in undertaking a risk? We all know that the most basic of any company goal is to make a profit. It's usually hidden under the many missions and visions it share with the public. Internally, the company's main goal is to make a profit.\nThe <em>underwriter</em> needs to set appropriate premiums and assess whether the portfolio will produce a profit given unusual claims are not reported.</p>\n<p>These are just some of the basics and I will ensure to highlight more in days to come.\nIn the meantime, digest this information and comment if you like.</p>\n<p>Cheers!</p>","id":"40dd5656-280a-5675-9a2e-8ed41c308cb8","timeToRead":2,"frontmatter":{"title":"Non Life Insurance Problems in Life","subtitle":"Problems in Non-Life Insurance","excerpt":"Problems in Non-Life Insurance","path":"/finance/non-life-actuarial-problems","category":"finance","date":"January 16, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"nonlife-insurance-problems.jpg","thumbnail":null,"teaser":"nonlife-insurance-problems.jpg","credit":"Life Marketers","creditlink":"http://www.lifemarketers.com/life-insurance-general-agency/non-med-life-insurance"},"tags":["Actuarial","Insurance","Money","business"],"published":true}},{"html":"<p>Abstraction and interfaces are common words that most programmers will come across when desigining systems and platforms. They are very useful concepts that any programmer who knows about Object Oriented Programming (OOP) should grasp and know like the back of their hand. They not only make code readable and testable, but also make your life a hell of a lot easier.</p>\n<p>Alright,let us get to it, so, I shall write about abstraction and interface in the Java programming language. However these very concepts can be applied to any OOP language out there.</p>\n<h2>Abstract classes</h2>\n<p>These are classes that contain one or more abstract methods. An abstract method is one that is declared but contains no implementation (without braces and followed by a semi-colon).</p>\n<pre><code class=\"language-java\">abstract void drive(double speed);\n</code></pre>\n<p>If a class contains abstract methods then the class <strong>must</strong> be declared abstract. When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class. However, if it does not, then the subclass must also be declared abstract.</p>\n<pre><code class=\"language-java\">abstract class Car{\n\n    abstract void changeGear(int number);\n}\n</code></pre>\n<p>Take for example we are modelling animals, we may start the hierachy with a base class of <em>Animal</em>. Animals are capable of several things, flying, running, swimming, crawling. They are also capable of sleeping, eating, dreaming. In this regard, the many types of animals have similar characteristics, like eating and sleeping. So the common operations performed by animals, but in a different way is a good candidate for abstraction which will force the subclasses (or child classes) to provide their own implementation. Let us take the following example.</p>\n<pre><code class=\"language-java\">    abstract class Animal {\n\n        /**Types of food the animals eat*/\n        public abstract void eat(String food);\n\n        /**How long the anima will sleep*/\n        public void sleep(int hours){\n            try{\n                // 1000 milliseconds * 60 seconds * 60 minutes * hours\n                Thread.sleep(1000 * 60 *60 *hours);\n            }catch (InterruptedException ie){\n                ie.printStackTrace();\n            }\n        }\n\n        /**The sound the animals make*/\n        public abstract void makeNoise();\n    }\n</code></pre>\n<p>The <strong>abstract</strong> keyword is used in both the class and the method to declare that the class and the method are abstract. Any class that subclasses <code>Animal</code> must implement the <code>makeNoise</code> and the <code>eat</code> functions.</p>\n<pre><code class=\"language-java\">    public class Cat extends Animal{\n        @Override\n        public void eat(String food) {\n            System.out.println(\"Cats eat \" + food);\n        }\n\n        @Override\n        public void makeNoise() {\n            System.out.println(\"Cats meow a lot\");\n        }\n    }\n</code></pre>\n<p>Alternatively we could declare Animal as an interface instead of using an abstract class, and have the Cat implement the interface. You could - but you'd also need to implement the sleep method. By using abstract classes, you can inherit the implementation of other (non-abstract) methods. You can't do that with interfaces - an interface cannot provide any method implementations.</p>\n<h2>Abstract classes and Interfaces</h2>\n<p>Now, that we have a basic understanding of abstraction, we shal compare that to interfaces. What is the difference? They are similar in a way, but are obviously not the same. You <strong>can't</strong> instantiate an abstract class and they may contain a mix of methods containing a mix of methods declared with or without an implementation. With abstract classes, you can declare fields that are not static and final, and define public, protected, and private concrete methods. With interfaces on the other hand, all fields are automatically public, static, and final, and all methods that you declare or define (as default methods) are public. In addition, you can extend only one class, whether or not it is abstract, whereas you can implement any number of interfaces (basics of OOP).</p>\n<h2>Instances to use Abstract classes and Interfaces.</h2>\n<p>Abstract classes are best used in such scenarios:</p>\n<ul>\n<li>You want to share code among several closely related classes.</li>\n<li>You expect that classes that extend your abstract class have many common methods or fields, or require access modifiers other than public (such as protected and private).</li>\n<li>You want to declare non-static or non-final fields. This enables you to define methods that can access and modify the state of the object to which they belong.</li>\n</ul>\n<p>Interfaces on the other hand are best used in such scenarios:</p>\n<ul>\n<li>You expect that unrelated classes would implement your interface.</li>\n<li>You want to specify the behavior of a particular data type, but not concerned about who implements its behavior.</li>\n<li>You want to take advantage of multiple inheritance of type.</li>\n</ul>\n<p>These obviously are not the only scenarios, they are just but examples. A real practical example of Abstraction is found <a href=\"https://github.com/BrianLusina/Java-Playground/tree/master/AbstractionInterfaces/MotorVehicles\">here</a>.</p>","id":"65bbf04c-f57d-5914-83d7-79a1e45597a9","timeToRead":3,"frontmatter":{"title":"Abstraction and interfaces","subtitle":"When to use abstraction and when to use interfaces","excerpt":"Abstraction and interfaces are common words that most programmers will come across when desigining systems and platforms. They are very useful concepts that any programmer who knows about Object Oriented Programming (OOP) should grasp and know like the back of their hand. They not only make code readable and testable, but also make your life a hell of a lot easier.","path":"/tech/abstraction-and-interfaces","category":"tech","date":"October 28, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"abstract_class_interfaces.png","thumbnail":"abstract_class_interfaces.png","teaser":"abstract_class_interfaces.png","credit":"Agile Code","creditlink":"http://agile-code.com"},"tags":["abstraction","interfaces","oop"],"published":true}}],"page":4,"pagesSum":9,"prevPath":"/page/3","nextPath":"/page/5"}}}