{"componentChunkName":"component---src-templates-tags-tags-jsx","path":"/tags/ciphers/","result":{"data":{"allMarkdownRemark":{"totalCount":1,"edges":[{"node":{"frontmatter":{"title":"Vigenere Cipher","subtitle":"The Vigenere Cipher Broken down in Python","excerpt":"The Vigenere cipher is likely the the most secure ciphers out there. It builds on the principle of the Caesar cipher yet provides a decent way to avoid the easy to solve shift problems. The basic gist of this cipher is we have both a message and a key. The key can be any length, but you must repeat the key for the length of our message to get this to work","path":"/tech/vigenere-cipher","date":"September 07, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"vigenere_cipher.jpg","thumbnail":"vigenere_cipher.jpg","teaser":"vigenere_cipher.jpg","credit":"MTU","creditlink":"www.cs.mtu.edu"},"tags":["algorithms","puzzles","ciphers"]},"excerpt":"The Vigenere cipher is likely the the most secure ciphers out there. It builds on the principle of the Caesar cipher yet provides a decentâ€¦","timeToRead":4,"html":"<p>The Vigenere cipher is likely the the most secure ciphers out there. It builds on the principle of the Caesar cipher yet provides a decent way to avoid the easy to solve shift problems. The basic gist of this cipher is we have both a message and a key. The key can be any length, but you must repeat the key for the length of our message to get this to work. This can be seen here:</p>\n<pre><code class=\"language-plain\">alpha = ABCDEFGHIJKLMNOPQRSTUVWXYZ\nmessage  = IAMTHEWALRUS\nkey  = HELLOHELLOHE\n</code></pre>\n<p>Our key is actually \"HELLO\", but we expanded it to the length of our message giving us the repeated nature we see. Once we have these defined, we go character by character performing a pseudo-Caesar cipher.</p>\n<pre><code class=\"language-plain\">m1 = I = 9\nk1 = H = 8\n9 + 8 = 17 % 26 = 17 = Q\nc1 = Q\n</code></pre>\n<p>Looking at this, we see that the first character of our message is \"I\" which is the ninth letter in the alphabet. We then look at the first character of the key which is \"H\" or the eighth letter in the alphabet. We add those two numbers and modulo 26 giving us 17 which points to the seventeenth letter in the alphabet: \"Q\". We now know that the first letter of our ciphertext is \"Q\".</p>\n<p>We then repeat this method for each character in our message until we have the ciphertext. This can be better shown as the algorithm:</p>\n<p>Let m be our message and k be our key:\nE(m) = ((m1 + k1) % 26, (m2 + k2) % 26, ..., (mi + ki) % 26)\nD(m) = ((c1 - k1) % 26, (c2 - k2) % 26, ..., (ci - ki) % 26)\nThis is much like the Caesar cipher except instead of defining a fixed rotation, we allow our key's character index to be the rotation. As you can see, this is why the Vigenere cipher can be considered a string of Caesar ciphers. Pretty cool when you actually see it.</p>\n<p>So how do we attack this then?</p>\n<p>Well, the problem with this cipher is the fact that the key repeats itself. When you have a repeating key, it's common to see patterns in the ciphertext that completely match each other. By recognizing those patterns, you can determine the block size of the key and from there you simply do a Caesar brute force shift on each block until the plaintext appears.</p>\n<p>On relatively short messages, this is harder to crack (as with any short ciphertext) but if encrypting a uniformly distributed text then you can really start to pick up on these things.</p>\n<p>Now let's code this up in Python and see how how we can automate this:</p>\n<pre><code class=\"language-python\">from itertools import cycle\n\nALPHA = 'abcdefghijklmnopqrstuvwxyz'\n\n\ndef encrypt(key, plaintext):\n    \"\"\"Encrypt the string and return the ciphertext\"\"\"\n    pairs = zip(plaintext, cycle(key))\n    result = ''\n\n    for pair in pairs:\n        total = reduce(lambda x, y: ALPHA.index(x) + ALPHA.index(y), pair)\n        result += ALPHA[total % 26]\n\n    return result.lower()\n\n\ndef decrypt(key, ciphertext):\n    \"\"\"Decrypt the string and return the plaintext\"\"\"\n    pairs = zip(ciphertext, cycle(key))\n    result = ''\n\n    for pair in pairs:\n        total = reduce(lambda x, y: ALPHA.index(x) - ALPHA.index(y), pair)\n        result += ALPHA[total % 26]\n\n    return result\n\n\ndef show_result(plaintext, key):\n    \"\"\"Generate a resulting cipher with elements shown\"\"\"\n    encrypted = encrypt(key, plaintext)\n    decrypted = decrypt(key, encrypted)\n\n    print 'Key: %s' % key\n    print 'Plaintext: %s' % plaintext\n    print 'Encrytped: %s' % encrypted\n    print 'Decrytped: %s' % decrypted\n</code></pre>\n<h2>Step One</h2>\n<p>Import the <code>cycle()</code> function from the <code>itertools</code> library.</p>\n<p>Define our alphabet in order to get character indexes correctly, this can be done with the <code>string</code> module in Python, which enables us to get all the letters in the alphabet we need. This avoids the issue of forgetting a letter in case you hardcode the alphabet.</p>\n<p>The function <code>encrypt(key, plaintext)</code> takes in a key and a plain text, I build a tuple with the <code>zip()</code> function which is a terminating function. Which means it will stop as soon as the shorter string is exhausted.</p>\n<p>An example</p>\n<pre><code class=\"language-python\"># in\nlist(zip(string.ascii_lowercase, string.ascii_uppercase))\n\n# out\n[('a', 'A'), ('b', 'B'), ('c', 'C'), ('d', 'D'), ('e', 'E'), ('f', 'F'), ('g', 'G'), ('h', 'H'), ('i', 'I'), ('j', 'J'), ('k', 'K'), ('l', 'L'), ('m', 'M'), ('n', 'N'), ('o', 'O'), ('p', 'P'), ('q', 'Q'), ('r', 'R'), ('s', 'S'), ('t', 'T'), ('u', 'U'), ('v', 'V'), ('w', 'W'), ('x', 'X'), ('y', 'Y'), ('z', 'Z')]\n</code></pre>\n<p><code>cycle</code> is used to repeat the letters of the key for the entirety of the plaintext, note that this can repeat indefinately.</p>\n<p>Perform a loop in each of the pairs reducing them to a single value with <code>reduce</code> function from functools library. The <code>reduce</code> function takes in a function and an iterable object.</p>\n<p>The sum could be used here as well, but it would mean remembring that indexes of the letters and not the letters themselves are needed, or else we'll get a value error.</p>\n<p>Finally get the new letter after a modulo of 26 and append that to our resulting ciphertext string.</p>\n<h2>Step 2</h2>\n<p>Create the decipher function. This is fundamentally the same with the only difference being the fact that we subtract instead of adding the letters.</p>\n<h2>Step 3</h2>\n<p>Output these results. :)</p>\n<h2>Conclusion</h2>\n<p>In essence this is a Caeser's cipher with the only difference being the fact that we allow out key's character index to rotate instead of defining a fixed rotation. As you can see, this is why the Vigenere cipher can be considered a string of Caesar ciphers.</p>"}}]}},"pageContext":{"tag":"ciphers"}}}