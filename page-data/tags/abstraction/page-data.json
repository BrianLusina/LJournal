{"componentChunkName":"component---src-templates-tags-tags-jsx","path":"/tags/abstraction/","result":{"data":{"allMarkdownRemark":{"totalCount":3,"edges":[{"node":{"frontmatter":{"title":"Abstraction and interfaces","subtitle":"When to use abstraction and when to use interfaces","excerpt":"Abstraction and interfaces are common words that most programmers will come across when desigining systems and platforms. They are very useful concepts that any programmer who knows about Object Oriented Programming (OOP) should grasp and know like the back of their hand. They not only make code readable and testable, but also make your life a hell of a lot easier.","path":"/tech/abstraction-and-interfaces","date":"October 28, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"abstract_class_interfaces.png","thumbnail":"abstract_class_interfaces.png","teaser":"abstract_class_interfaces.png","credit":"Agile Code","creditlink":"http://agile-code.com"},"tags":["abstraction","interfaces","oop"]},"excerpt":"Abstraction and interfaces are common words that most programmers will come across when desigining systems and platforms. They are very…","timeToRead":3,"html":"<p>Abstraction and interfaces are common words that most programmers will come across when desigining systems and platforms. They are very useful concepts that any programmer who knows about Object Oriented Programming (OOP) should grasp and know like the back of their hand. They not only make code readable and testable, but also make your life a hell of a lot easier.</p>\n<p>Alright,let us get to it, so, I shall write about abstraction and interface in the Java programming language. However these very concepts can be applied to any OOP language out there.</p>\n<h2>Abstract classes</h2>\n<p>These are classes that contain one or more abstract methods. An abstract method is one that is declared but contains no implementation (without braces and followed by a semi-colon).</p>\n<pre><code class=\"language-java\">abstract void drive(double speed);\n</code></pre>\n<p>If a class contains abstract methods then the class <strong>must</strong> be declared abstract. When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class. However, if it does not, then the subclass must also be declared abstract.</p>\n<pre><code class=\"language-java\">abstract class Car{\n\n    abstract void changeGear(int number);\n}\n</code></pre>\n<p>Take for example we are modelling animals, we may start the hierachy with a base class of <em>Animal</em>. Animals are capable of several things, flying, running, swimming, crawling. They are also capable of sleeping, eating, dreaming. In this regard, the many types of animals have similar characteristics, like eating and sleeping. So the common operations performed by animals, but in a different way is a good candidate for abstraction which will force the subclasses (or child classes) to provide their own implementation. Let us take the following example.</p>\n<pre><code class=\"language-java\">    abstract class Animal {\n\n        /**Types of food the animals eat*/\n        public abstract void eat(String food);\n\n        /**How long the anima will sleep*/\n        public void sleep(int hours){\n            try{\n                // 1000 milliseconds * 60 seconds * 60 minutes * hours\n                Thread.sleep(1000 * 60 *60 *hours);\n            }catch (InterruptedException ie){\n                ie.printStackTrace();\n            }\n        }\n\n        /**The sound the animals make*/\n        public abstract void makeNoise();\n    }\n</code></pre>\n<p>The <strong>abstract</strong> keyword is used in both the class and the method to declare that the class and the method are abstract. Any class that subclasses <code>Animal</code> must implement the <code>makeNoise</code> and the <code>eat</code> functions.</p>\n<pre><code class=\"language-java\">    public class Cat extends Animal{\n        @Override\n        public void eat(String food) {\n            System.out.println(\"Cats eat \" + food);\n        }\n\n        @Override\n        public void makeNoise() {\n            System.out.println(\"Cats meow a lot\");\n        }\n    }\n</code></pre>\n<p>Alternatively we could declare Animal as an interface instead of using an abstract class, and have the Cat implement the interface. You could - but you'd also need to implement the sleep method. By using abstract classes, you can inherit the implementation of other (non-abstract) methods. You can't do that with interfaces - an interface cannot provide any method implementations.</p>\n<h2>Abstract classes and Interfaces</h2>\n<p>Now, that we have a basic understanding of abstraction, we shal compare that to interfaces. What is the difference? They are similar in a way, but are obviously not the same. You <strong>can't</strong> instantiate an abstract class and they may contain a mix of methods containing a mix of methods declared with or without an implementation. With abstract classes, you can declare fields that are not static and final, and define public, protected, and private concrete methods. With interfaces on the other hand, all fields are automatically public, static, and final, and all methods that you declare or define (as default methods) are public. In addition, you can extend only one class, whether or not it is abstract, whereas you can implement any number of interfaces (basics of OOP).</p>\n<h2>Instances to use Abstract classes and Interfaces.</h2>\n<p>Abstract classes are best used in such scenarios:</p>\n<ul>\n<li>You want to share code among several closely related classes.</li>\n<li>You expect that classes that extend your abstract class have many common methods or fields, or require access modifiers other than public (such as protected and private).</li>\n<li>You want to declare non-static or non-final fields. This enables you to define methods that can access and modify the state of the object to which they belong.</li>\n</ul>\n<p>Interfaces on the other hand are best used in such scenarios:</p>\n<ul>\n<li>You expect that unrelated classes would implement your interface.</li>\n<li>You want to specify the behavior of a particular data type, but not concerned about who implements its behavior.</li>\n<li>You want to take advantage of multiple inheritance of type.</li>\n</ul>\n<p>These obviously are not the only scenarios, they are just but examples. A real practical example of Abstraction is found <a href=\"https://github.com/BrianLusina/Java-Playground/tree/master/AbstractionInterfaces/MotorVehicles\">here</a>.</p>"}},{"node":{"frontmatter":{"title":"A Practical example of Abstraction","subtitle":"A more practical approach to abstraction in OOP","excerpt":"Abstraction in the real world.","path":"/tech/abstraction","date":"July 11, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"abstraction.jpg","thumbnail":"abstraction.jpg","teaser":"abstraction.jpg","credit":null,"creditlink":null},"tags":["encapsulation","objects","object oriented programming","abstraction"]},"excerpt":"Abstraction is one of the principles of Object Oriented Programming where a programmer hides/reduces information of an object and only…","timeToRead":2,"html":"<p>Abstraction is one of the principles of Object Oriented Programming where a programmer hides/reduces information of an object and only reveals the relevant information at the time. It works alongside <em>inheritance</em> and <em>encapsulation</em>. This is done in order to reduce complexity and ensure efficiency.</p>\n<p>In the process of abstraction, the programmer tries to ensure that the entity is named in a manner that will make sense and that it will have all the relevant aspects included and none of the extraneous ones.</p>\n<p>A practical example is a car. Not many people are concerned with the inner workings of a motor vehicle, save for mechanics, engineers and car enthusiasts. A car is an object that has certail states and behaviours. It has states such as <em>black</em> paint, <em>engine size</em> and <em>number of doors</em> etc. The behaviours are <em>accelerate</em>, <em>decelerate</em> and <em>stop</em>, just to mention a few. Now, for the driver to intaract with the car, they have to do so through the steering wheel, the gears and the peddles. These are the <strong>interfaces</strong>.</p>\n<p>These are what act as a go-between the driver and the internal components of the car. This is where abstraction steps in. The driver does not particularly know what is going on in the engine when they accelerate and when they stop. All they get to interact with are the steering wheel, pedals and various gauges on the car dashboard. Abstraction basically gives them this relevant information as it is what is needed at the time of driving. All the driver needs to know at all times when they are driving are the fuel gauge, the speed they are on and car temperature. They do not need to know about how the car measures heat every second or how it gauges how much petrol is left in the tank or even how it calculates the current speed. This information is hidden in the internal components of the car (<em>encapsulation</em>) and is queried (say, you take your car apart and study it) only when need be. So at all times only relevant information is displayed(<em>abstraction</em>).</p>\n<p>This, as you can see, reduces the complexity when driving said car and allows the driver to only intaract with what they need to interact with at the time of driving.</p>"}},{"node":{"frontmatter":{"title":"The 4 Principles of OOP","subtitle":"Principles governing OOP","excerpt":"For a program to be said to be object oriented, some principles have to be followed. These principles are crucial to enable the said program to be effective in order to be able to meet the needs the program was designed for.","path":"/tech/principles-of-oop","date":"June 03, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"principles-of-oop.jpg","thumbnail":"principles-of-oop.jpg","teaser":"principles-of-oop.jpg","credit":null,"creditlink":null},"tags":["oop","oop principles","objects","encapsulation","abstraction","interfaces","polymorphism"]},"excerpt":"For a program to be said to be object oriented, some principles have to be followed. These principles are crucial to enable the said program…","timeToRead":7,"html":"<p>For a program to be said to be object oriented, some principles have to be followed. These principles are crucial to enable the said program to be effective in order to be able to meet the needs the program was designed for.\nThe four principles are:</p>\n<ul>\n<li>Encapsulation</li>\n<li>Abstraction</li>\n<li>Inheritance</li>\n<li>Polymorphism</li>\n</ul>\n<h2>Encapsulation</h2>\n<p>This is the hiding of data implementation by restricting access to <em>setters</em> and <em>getters</em> Getters are accessor methods that allows the <em>state</em> of an object to be retrieved, while setters are mutator methods that allows on objects state to be modified. This enables the original data (variables or fields) to be protected as they are not directly modified, rather they are accessed through these methods. This enables one to make changes to a class without the worry that they are going to break other code that is using and calling the same class for information. Here is a brief example:</p>\n<pre><code class=\"language-Java\">public class Person{\n  private String fName;\n  private String lName;\n  private String email;\n\n  //Constructor\n  public Person(String fName,String lName,String email){\n    this.fName = fName;\n    this.lName = lName;\n    this.email = email.\n  }\n\n  //Getter and setter methods for each field\n  public String getFname{\n    return fName;\n  }\n\n  public void setfName(String fName){\n    this.fName = fName;\n  }\n\n  public String getLname{\n    return lName;\n  }\n\n  public void setlName(String lName){\n    this.lName = lName;\n  }\n\n  public String getEmail{\n    return email;\n  }\n\n  public void setEmail(String email){\n    this.email = email;\n  }\n}\n</code></pre>\n<blockquote>\n<p>Above is a Person class that contains the persons first name(<code>fName</code>), last name(<code>lName</code>) and email(<code>email</code>)</p>\n</blockquote>\n<p>This Person class fields <code>fName</code>, <code>lName</code> and <code>email</code> are hidden from outside and can not be accessed directly. However, they can be accessed through getter and setter methods, i.e. <code>getFname</code>, <code>getLname</code>, <code>getEmail</code>, <code>setFname</code>, <code>setLname</code> and <code>setEmail</code>.</p>\n<pre><code class=\"language-Java\">import Person\npublic class Main{\n  public static void main(String args[]){\n    //creates a new Person object\n    Person john = new Person(\"John\",\"Hancock\",\"john@example.com\");\n    System.out.println(john.fName); //will return an error, as this field can not be directly accessed\n    System.out.println(john.getFname());//will return John\n  }\n}\n</code></pre>\n<blockquote>\n<p>Above is a simple demonstration of encapsulation. <code>john</code> object is created using a custom constructor, which initializes the fields (<code>fName</code>,<code>lName</code> and <code>email</code>). the <code>getFname</code> is used to access the first name John.</p>\n</blockquote>\n<h2>Abstraction</h2>\n<p>Abstract means a concept or an Idea which is not associated with any particular instance. Using abstract class/interface we express the intent of the class rather than the actual implementation. In a way, one class should not know the inner details of another in order to use it, just knowing the interfaces should be good enough. Abstraction denotes a model, a view, or some other focused representation for an actual item.</p>\n<p>When we think about it every noun in the language is a category. When we say \"a bird\", we are not referring to a specific bird, but to the category that contains all the birds in the world, and describe them. So when I say \"a bird\" most people have a general idea of what I mean, what information they will have about each individual object that will be in this category and what kind of action it could do.</p>\n<pre><code class=\"language-Java\">public class Bird{\n  private String name;\n  private float height;\n  private float weight;\n  private boolean fly;\n\n  //constructor\n  public Bird(String name,float height, float weight, boolean fly){\n    this.name = name;\n    this.height = height;\n    this.weight = weight\n    this.fly = fly;\n  }\n\n  //getters and setters\n  public String getName(){\n    return name;\n  }\n\n  public void setName(String name){\n    this.name = name;\n  }\n\n  public float getHeight(){\n    return height;\n  }\n\n  public void setHeight(float height){\n    this.height = height;\n  }\n\n  public float getWeight(){\n    return weight;\n  }\n\n  public void setWeight(float weight){\n    this.weight = weight;\n  }\n\n  public boolean getFly(){\n    return fly;\n  }\n\n  public void setFly(boolean fly){\n    this.fly = fly;\n  }\n\n  public boolean canFly(){\n    //code to determine if the bird can fly and returns a boolean value\n  }\n\n  public boolean canChirp(){\n    //code to determine if the bird can chirp and returns a boolean value\n  }\n}\n</code></pre>\n<blockquote>\n<p>Above is a simple class that has the states(fields) of a bird class.</p>\n</blockquote>\n<p>This is an example of an abstract type of what a bird object is to us outside of the software world. The abstract bird is defined by the operations that can be performed on it, and the information we can get from it and give to it.</p>\n<h2>Inheritance</h2>\n<p>This is the ability of a new class to be created, from an existing class by <em>extending</em> it. The parent class is referred to as the <strong>superclass</strong> or <strong>base class</strong> or <strong>parent class</strong> or <strong>ancestor class</strong>. The <em>superclass</em> is the class that defines all the properties and methods of the subclasses. Objects can relate to eachother with either a <strong>has a</strong>, <strong>uses a</strong> or an <strong>is a</strong> relationship. <em>Is a</em> is the inheritance way of object relationship. A proper example is a vehicle class. All cars are vehicles, but they do not have the same properties and behaviours. They all inherit from the vehicle class, but there are features that are not common in all, which makes every vehicle object unique from the other. A truck is not the same from a sedan and a motorbike is not the same as a trailer, despite the fact that they are all vehicles. Let us look at an example:</p>\n<pre><code class=\"language-Java\">public class Vehicle{\n  private String name;\n  private String model;\n  private int engineSize;\n  private int wheels;\n  private int doors;\n  pritave int seats;\n  int speed = 0;\n  int gear = 1;\n\n  //constructor\n  public Vehicle(String name, String model,int engineSize,int wheels,int doors,int seats){\n    this.name = name;\n    this.model = model;\n    this.engineSize = engineSize;\n    this.wheels = wheels;\n    this.doors = doors;\n    this.seats = seats;\n  }\n\n  //getters and setters\n  public String getName(){\n    return name;\n  }\n\n  public void setName(String name){\n    this.name = name;\n  }\n\n    public String getName(){\n    return name;\n  }\n\n  public void setName(String name){\n    this.name = name;\n  }\n\n  public String getModel(){\n    return model;\n  }\n\n  public void setModel(String model){\n    this.model = model;\n  }\n\n  public int getEngineSize(){\n    return engineSize;\n  }\n\n  public void setEngine(String engineSize){\n    this.engineSize = engineSize;\n  }\n\n  public String getWheels(){\n    return wheels;\n  }\n\n  public void setWheels(String wheels){\n    this.wheels = wheels;\n  }\n\n  public String getDoors(){\n    return doors;\n  }\n\n  public void setSeats(String seats){\n    this.seats = seats;\n  }\n\n  //behaviours of a typical Vehicle object\n  public void changeGear(int newValue) {\n         gear = newValue;\n  }\n\n  public void speedUp(int increment) {\n         speed = speed + increment;\n  }\n\n  public void applyBrakes(int decrement) {\n       speed = speed - decrement;\n  }\n\n  pulic void printStates() {\n   System.out.println(\" speed:\" + speed + \" gear:\" + gear);\n  }\n}\n</code></pre>\n<blockquote>\n<p><code>Vehicle</code> class that describes all the properties of a vehicle object. This is the superclass</p>\n</blockquote>\n<p>The class above can be extended as shown below</p>\n<pre><code class=\"language-Java\">public class Truck extends Vehicle{\n  //perform actions here specific to a Truck object\n}\n\npublic class MotorBike extends Vehicle{\n  //perform actions specific to a MotorBike Object\n}\n</code></pre>\n<blockquote>\n<p><code>Truck</code> class gets all the properties of the <code>Vehicle</code> class</p>\n</blockquote>\n<p>Importance of inheritance:</p>\n<ul>\n<li>Reuse of code</li>\n<li>Prevention of new bugs</li>\n<li>Reducing code size</li>\n<li>Code readability</li>\n</ul>\n<h2>Polymorphism</h2>\n<p>It means one name many forms. Polymorphism manifests itself by having multiple methods all with the same name, but slightly different functionality. It is further of two types:</p>\n<ul>\n<li><em>Static (or compile-time) polymorphism</em> is achieved using method overloading</li>\n<li><em>Dynamic(or runtime) polymorphism</em> using method overriding.</li>\n</ul>\n<h3>Static polymorphism (or compile-time)</h3>\n<p>A method having same name can have multiple implementations, depending upon the argument(s) passed to it. For example, there can be three methods called add(int x, int y), add(float x, float y) and add(String x,String y). The compiler decides at compile time which method will be called by looking at the signature of the called method.</p>\n<pre><code class=\"language-Java\">public class StaticPoly{\n  public static void main(String[] args){\n    int xInt = 5;\n    int yInt =4;\n    String xStr = \"5\";\n    String yStr = \"4\";\n    float xFloat = 5.0;\n    float yFloat = 4.0;\n\n    System.out.println(add(xInt, yInt)); //output 9\n    System.out.println(add(xFloat, yFloat)); // output 9.0\n    System.out.println(and add(xStr,yStr)); //output \"9\"\n  }\n\n  public static int add(int x, int y){\n    return x+y;\n  }\n  public static float add(float x, float y){\n    return x+y;\n  }\n  public static String add(String x,String y){\n    int result = Integer.parseInt(x) + Integer.parseInt(y);\n    return String.valueOf(result);\n  }\n}\n</code></pre>\n<blockquote>\n<p>Demonstration of static polymorphism or method overloading</p>\n</blockquote>\n<h3>Dynamic polymorphism</h3>\n<p>A subclass may override a superclass method for more specific behaviour. The decision of which method to call is made at runtime. The calling code may declare the object to be of parent type. At runtime, depending upon the actual type of the object, the correct method will be invoked. An example may be of open() method for superclass Document. The subclasses doc and xls both override open() method. But it may not be known beforehand which document will be opened. At runtime, depending upon the object on which open() is called, the correct Document object's open() method will be invoked.</p>\n<p>Method overriding allows a subclass to override a specific implementation of a method that is already provided by one of its super-classes.</p>\n<pre><code class=\"language-Java\">public class Complex\n{\n    private int real;\n    public int Real\n    private int imaginary;\n\n    public Complex(int real, int imaginary){\n        this.real = real;\n        this.imaginary = imaginary;\n    }\n    public int getReal(){\n      return real;\n    }\n\n    public int getImaginary(){\n      return imaginary;\n    }\n\n    public static Complex operator +(Complex c1, Complex c2){\n        return new Complex(c1.Real + c2.Real, c1.Imaginary + c2.Imaginary);\n    }\n\n    public override string ToString(){\n        return (String.Format(\"{0} + {1}i\", real, imaginary));\n    }\n}\n</code></pre>\n<blockquote>\n<p>This class has one overridden method named ToString, which overrides the default implementation of the standard ToString method to support the correct string conversion of a complex number.</p>\n</blockquote>\n<pre><code class=\"language-Java\">public class DyanamicPoly{\n  public static void main(String[] args){\n  Complex num1 = new Complex(5, 7);\n  Complex num2 = new Complex(3, 8);\n\n  // Add two Complex numbers using the overloaded plus operator\n  Complex sum = num1 + num2;\n\n  // Print the numbers and the sum using the overriden ToString method\n  System.out.println(\"({0}) + ({1}) = {2}\", num1, num2, sum);\n  }\n}\n</code></pre>\n<h1>Conclusion</h1>\n<p>A good objecto oriented software follows these principles to the letter. These principles make your code easier to read, understand and also are effective when it comes to debugging and upgrading. They also make your code smaller, as you end up writing less code.</p>"}}]}},"pageContext":{"tag":"abstraction"}}}