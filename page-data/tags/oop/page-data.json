{"componentChunkName":"component---src-templates-tags-tags-jsx","path":"/tags/oop/","result":{"data":{"allMarkdownRemark":{"totalCount":2,"edges":[{"node":{"frontmatter":{"title":"Accessors and Modifiers","subtitle":"subtle introduction to getters and setters","excerpt":null,"path":"/tech/access-modifiers","date":"July 05, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":null,"thumbnail":null,"teaser":null,"credit":null,"creditlink":null},"tags":["OOP","getters and setters","accessors","modifiers"]},"excerpt":"This topic will simply extend from the Objective of OOP and 4 principles of OOP and will majorly focus only on accessors and modifiers, i.e…","timeToRead":5,"html":"<p>This topic will simply <em>extend</em> from the <a href=\"https://brianlusina.github.io/Object-Oriented-Programming/\">Objective of OOP</a> and <a href=\"https://brianlusina.github.io/Principles-Of-Oop/\">4 principles of OOP</a> and will majorly focus only on accessors and modifiers, i.e. <em>getters</em> and <em>setters</em>.</p>\n<p>Accessors are methods used in Object Oriented Programming to enable <em>access</em> to a class fields which may be private. In most cases it is advisable to make these fields private and allow allow access to them from the accessors and modifier methods. The accessor methods, or <em>getter</em> methods as they are most commonly known as, are only used to <strong>access</strong> or <em>get</em> the fields/states of a particular object. Modifiers or <em>setters</em> allow the modification or <em>setting</em> of the fields of a particular object.</p>\n<p>These are used in encapsulation and allow data hiding which makes code more secure and also reduces the amount of code written, which is what every developer seeks, to make code cleaner, smaller, but still maintain the overall functionality and readability.</p>\n<p>A simple example of a Car class will be used. A Car is a super class of every car type in the world. This Car class will contain all the fields/states and behaviours/methods of all the car types in the world.</p>\n<p>This is the code for writing a super class Car in Java:</p>\n<pre><code class=\"language-Java\">public class Car {\n    private int wheels;\n    private int engineCapacity;\n    private int seats;\n    private String name;\n\n    /**Constructor for the Car class*/\n    public Car(int wheels, int engineCapacity, int seats, String name){\n        this.wheels = wheels;\n        this.engineCapacity = engineCapacity;\n        this.seats = seats;\n        this.name = name;\n    }\n\n    /**ACCESSORS AND MODIFIERS getters and setters*/\n\n    /*get and set wheels*/\n    public int getWheels(){\n        return wheels;\n    }\n\n    public void setWheels(int wheels){\n        this.wheels = wheels;\n    }\n\n    /*set and get the engine capacity*/\n    public int getEngineCapacity(){\n        return engineCapacity;\n    }\n\n    public void setEngineCapacity(int engineCapacity){\n        this.engineCapacity = engineCapacity;\n    }\n\n    /*getters and setters for the seats*/\n    public int getSeats(){\n        return seats;\n    }\n\n    public void setSeats(int seats){\n        this.seats = seats;\n    }\n\n    /*get and set the name*/\n    public String getName(){\n        return name;\n    }\n\n    public void setName(String name){\n        this.name = name;\n    }\n\n}\n</code></pre>\n<blockquote>\n<p>This is a car class with a constructor to define its objects on creation the getters and setters have been defined to allow the object's fields or states to be modified by the instance.</p>\n</blockquote>\n<p>The usual convention for writing getters is by writing the word <strong>get</strong> and followed by the name of the field to access. So, in this case, to acces the <code>seats</code> field, the function created is <code>getSeats()</code>. This getter <strong>MUST</strong> return the data type of the same field it wants to access. So, in the case of seats, it must return and <code>int</code> data type as the <code>seats</code> variable is an integer type.\nIt is important to note that getter methods do not take any arguments.</p>\n<p>Setters are a bit different. To create a setter function, the same method as declaring a get method is applied. Use of the word <strong>set</strong> followed by the name of the variable. An example would be <code>setName</code>. This naming follows the camel casing convention for naming variables. The setter methods <strong>DO NOT</strong> return any value and thus the <em>void</em> is used, which means: <em>does not return any value</em>. This does not return a particular value as it's job is to set a particular value. In this case, <code>setName(String name)</code> takes in a String argument and modifies the current name field (or re-assigns the name variable) with the input in the <code>setName</code> method. The setter methods must take arguments as they are, after all, supposed to modify the current field to a new state.</p>\n<p>All this is made possible because the variables have been declared <code>private</code>. This restricts access, therefore the need for use of getters and setters.</p>\n<h2>Sample usage of accessors and modifiers</h2>\n<p>Below is a sample usage of getters and setters from the Car's class defined above:</p>\n<pre><code class=\"language-Java\">public class CarTest {\n    public static void main(String[] args){\n        Car merc = new Car(4, 3500, 5, \"Mercedez Benz\");\n        Car toyota = new Car(4, 1200, 5, \"Allion\");\n\n        /*The getters allows the private variables to be accessed from the constructor*/\n        System.out.printf(\"This is a %s with %d wheels, %d seats and an engine capacity of\n        %d CC \\n\", toyota.getName(), toyota.getWheels(), toyota.getSeats(),toyota.getEngineCapacity());\n\n//output is This is a Allion with 4 wheels, 5 seats and an engine capacity of 1200\n\n        System.out.printf(\"This is a %s with %d wheels, %d seats and an engine capacity of\n        %d CC \\n\", merc.getName(), merc.getWheels(), merc.getSeats(),merc.getEngineCapacity());\n        //output is This is a Mercedez Benz with 4 wheels, 5 seats and an engine capacity of 3500 CC\n\n        /*the setters modify the states or fields of the object*/\n        merc.setName(\"Mercedes SLS\");\n        merc.setEngineCapacity(4500);\n        merc.setWheels(4);\n        merc.setSeats(2);\n\n        /*these have been modified from the previous states to the current states as described below*/\n        System.out.printf(\"This is a %s with %d wheels, %d seats and an engine capacity of\n        %d CC \\n\", merc.getName(), merc.getWheels(), merc.getSeats(),merc.getEngineCapacity());\n        //output is This is a Mercedes SLS with 4 wheels, 2 seats and an engine capacity of 4500 CC\n\n        //below lines modify the toyota object\n        toyota.setName(\"Toyota Celica\");\n        toyota.setEngineCapacity(2500);\n        toyota.setWheels(4);\n        toyota.setSeats(2);\n\n        /*these have been modified from the previous states to the current states as described below*/\n        System.out.printf(\"This is a %s with %d wheels, %d seats and an engine capacity of %d CC\", toyota.getName(), toyota.getWheels(), toyota.getSeats(),toyota.getEngineCapacity());\n        //output is: This is a Toyota Celica with 4 wheels, 2 seats and an engine capacity of 2500 CC\n\n    }\n}\n</code></pre>\n<p>The <code>merc</code> and <code>toyota</code> objects are instances of the Car class, thus they inherit all the characteristics(fields and methods of the parent class) of Car class. This allows them access to the variables such as <code>seats</code>, <code>engineCapacity</code> and <code>name</code>, just ot mention a few. Note, however, that these variables can only be accessed from the getters and setters</p>\n<p>The getters allow access to the various fields that have been set in the constructor. a method such as <code>merc.getName()</code> returns <em>Mercedez Benz</em>, while <code>toyota.getName()</code> returns <em>Allion</em>. These are the fields set in the constructor. using <code>merc.name</code> will return an error.</p>\n<p>To rename these fields the setters have been used. A method call such as <code>merc.setEngineCapacity(4500)</code> will change the <code>engineCapacity</code> from 3500 to 4500. This is modifying. The same applies to <code>toyota.setSeats(2)</code>.</p>\n<p>This is a basic example and is mostly used to restrict access to a class' states and behaviour to the outside world thus increasing security of the code used.</p>\n<p>Sample code can be found here <a href=\"https://github.com/BrianLusina/Java-Playground/blob/master/Toy%20Problems/src/DataStructures/OOP/Car.java\">Car Class</a> and <a href=\"https://github.com/BrianLusina/Java-Playground/blob/master/Toy%20Problems/src/DataStructures/OOP/CarTest.java\">CarTest class</a>.</p>"}},{"node":{"frontmatter":{"title":"Objective of Object Oriented Programming.","subtitle":"Objected oriented programming","excerpt":"Object Oriented Programming, or as is popularly known in the programming realm OOP is a style of programming that is organized around objects rather than actions.","path":"/tech/object-oriented-programming","date":"June 02, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"object-oriented-programming.png","thumbnail":"object-oriented-programming.png","teaser":"object-oriented-programming.png","credit":null,"creditlink":null},"tags":["OOP","Objects"]},"excerpt":"Object Oriented Programming, or as is popularly known in the programming realm OOP is a style of programming that is organized around…","timeToRead":9,"html":"<p>Object Oriented Programming, or as is popularly known in the programming realm OOP is a style of programming that is organized around objects rather than actions. It takes the view that what we really care about are the objects we want to manipulate rather than the logic required to manipulate them. It is a concept that has been widely adopted and is recommended for every software developer. It not only makes life easier for you as a developer but also aids other developers in collaborating easily with your project, as it is lighter as compared to precedural programming.</p>\n<p>There are a couple of definitions that I believe are important to understand before delving deeper into OOP. Definitions such as <em>object</em>, <em>classes</em>, <em>inheritance</em>, <em>interface</em> and <em>packages</em>.</p>\n<h2>Object</h2>\n<p>An <em>object</em> is a software bundle of related state and behaviour. They are often used to model real life objects you find in everyday life. They are key to understanding what OOP is all about. Objects are all around us, the trees, your radio, your phone, your pet dog (or cat). All these objects, despite their differences, have 2 things in common. They have <strong>state</strong> and <strong>behaviour</strong>. Your pet has state (name, color, breed) and behaviour (bark, run, wag tail). Your car also has state (current gear, current speed) and behaviour (changing gear, applying breaks, etc). Despite one being a living thing and the other a machine, they both share 2 important characteristics; the have state and behaviour. If you look keenly at these objects keenly, you will notice that they greatly vary in complexity and may find that some contain other objects. This is the center of Object Oriented Programming.</p>\n<p>Software objects are no different from the real world objects. They contain states (fields or variables in some programming languages) and behaviour (methods or functions in some programming languages). A software object stores its states in fields and shows its behaviour in methods.</p>\n<p><img src=\"https://docs.oracle.com/javase/tutorial/figures/java/concepts-object.gif\" alt=\"image\" title=\"Software Object Courtesy Of Java Documentation\"></p>\n<blockquote>\n<p>Data Encapsulation: Hiding internal state and requiring all interaction to be performed through an object's methods. Methods operate on an object's internal state and serve as the primary mechanism for object-to-object communication. This is a fundamental principle of object-oriented programming.</p>\n</blockquote>\n<p>Objects have a couple of advatages:</p>\n<ul>\n<li><em>Allows for code re-use</em>: If an object already exists due to it being created by another developer, you can easily plug it into your source code and use it.</li>\n<li><em>Modularity</em>: An objects source code can be written independently of the system, allowing it, once created, to be passed around inside the system.</li>\n<li><em>Objects allow information hiding</em>: By interacting with the objects methods, the internal process remain hidden.</li>\n<li><em>Plug and Play</em>: If a particular object is problematic to your code, you could simply remove it and use another. This allows you to debug your code easily.</li>\n</ul>\n<h2>Class</h2>\n<p>A class is a <em>blue print</em> from which all your objects are created. Take your car or bicycle for example. They are thousands of cars in existence, your car is one of them. Most contain the same nuts and bolts, engine capacity and gearbox. This means they were made from a similar blue print (a similar plan). Your car is said to be an <strong>instance</strong> of the class of objects known as cars. So, basically a car, is a group of related objects with similar states and behaviours.</p>\n<pre><code class=\"language-Java\">class Car {\n\n    int speed = 0;\n    int gear = 1;\n\n    void changeGear(int newValue) {\n         gear = newValue;\n    }\n\n    void speedUp(int increment) {\n         speed = speed + increment;\n    }\n\n    void applyBrakes(int decrement) {\n         speed = speed - decrement;\n    }\n\n    void printStates() {\n         System.out.println(\" speed:\" +\n             speed + \" gear:\" + gear);\n    }\n}\n</code></pre>\n<p>Above is a Car class that has the states and the behaviours of a car. The states are shown by the <code>int</code> variables speed and gear while the behaviours are shown by the <code>changeGear(int enwValue)</code>, <code>speedUp(int increment)</code>, <code>applyBrakes(int decrement)</code> and <code>printStates()</code> methods. These methods are how this class will interact with the <em>outside</em> world. For those of you familiar with Java programming, you may have noticed that this class lacks the main method. This is becase this is a blue print for all other car objects and not the main application.</p>\n<pre><code class=\"language-Java\">class CarDemo {\n    public static void main(String[] args) {\n\n        // Create two different Car objects\n        Car car1 = new Car();\n        Car car2 = new Car();\n\n        // Invoke methods on the newly created objects\n        car1.speedUp(15);\n        car1.changeGear(3);\n        car1.printStates();\n\n        car2.speedUp(10);\n        car2.changeGear(2);\n        car2.speedUp(10);\n        car2.changeGear(3);\n        car2.printStates();\n    }\n}\n</code></pre>\n<p>This is the main application that will test for newly created car objects. The output will be as below.</p>\n<pre><code class=\"language-Java\">speed:15 gear:3\nspeed:20 gear:3\n</code></pre>\n<p>As you can see the <code>car1</code> and <code>car2</code> objects have the same states and have the same behaviour. This is despite being owned by 2 different people, for example. They will move in the same manner and have the same states.</p>\n<h2>Concept of Inheritance</h2>\n<p>Inheritance, as the name suggests, is <em>inheriting</em> characeteriestics from the parent. Like a son having the same nose and hair as the father, or having the same eyes and lips as the mother. This is inheritance. The same applies to programming. The <code>Car</code> class created above is the <em>parent</em> and the <code>car1</code> and <code>car2</code> are the <em>children</em>. The objects inherit states and behaviours from the <code>Car</code> class. This is in lay man terms. The correct terms to use are <strong>superclass</strong> and <strong>subclass</strong>. The <code>Car</code> class is the <em>superclass</em> and the car objects are the <em>subclasses</em> and are thus able to inherit from the <code>Car</code> class behaviours such as <code>changeGear</code>.</p>\n<p>This does not mean that these are the only states and behaviours they could have. Take, the cars above. One could be a Mercedeze Benz and the other a Jeep Wrangler. They are both cars, but they are unique from each other. The Mercedeze Benz has 4 seats, while the Jeep has 2. The engine sizes are different and so are their top speeds and the terrain which they can handle. But, the bottom line, they are cars and <em>inherit</em> from the <code>Car</code> class. In Java, each class is alowed to have one superclass, while each superclass can have many subclasses.</p>\n<p>Below image shows the hierachy of bicycle class.</p>\n<p><img src=\"https://docs.oracle.com/javase/tutorial/figures/java/concepts-bikeHierarchy.gif\" alt=\"bicycle\" title=\"Bicycle Hierarchy\"></p>\n<p>To create a subclass in Java, simply <em>extend</em> the superclass and inherit its methods.</p>\n<pre><code class=\"language-Java\">class MercedezBenz extends Car{\n    //perform actions here\n    //new fields for the mercedez benz go here\n    //and inherited methods as well as specific ones to mercedez benz\n}\n</code></pre>\n<p>This gives MercedezBenz all the same fields and methods as Car class, yet allows its code to focus exclusively on the features that make it unique. Thus, differentiating it from the JeepWrangler class. This makes code for your subclasses neat and easy to read. Caution must be taken as to properly document state and behavior that each superclass defines.</p>\n<h2>Interface</h2>\n<p>Methods are the means in which objects interact with the world outside. Methods from the object <em>interface</em> with the world outside. The buttons on your phone, for example, act as interfaces between the cpu components and you. Allowing you to access the states and behaviour of the phone, states such as <em>off</em> and <em>on</em> or behaviour such as <em>calling</em> or <em>sending message</em>.</p>\n<p>An interface can be thought of as a group of related methods with empty bodies. If the Car class behaviour was to be described in an interface it would be as follows:</p>\n<pre><code class=\"language-Java\">interface CarBehaviour{\n\n    void changeGear(int newValue);\n\n    void speedUp(int increment);\n\n    void applyBrakes(int decrement);\n}\n</code></pre>\n<p>To implement the above interface with your class, you would have to <em>implement</em> the <code>CarBehaviour</code> interface like so</p>\n<pre><code class=\"language-Java\">class JeepWrangler implements CarBehaviour{\n    int speed = 0;\n    int gear = 1;\n\n    void changeGear(int newValue) {\n         gear = newValue;\n    }\n\n    void speedUp(int increment) {\n         speed = speed + increment;\n    }\n\n    void applyBrakes(int decrement) {\n         speed = speed - decrement;\n    }\n\n    void printStates() {\n         System.out.println(\"speed: \" +\n             speed + \" gear:\" + gear);\n    }\n}\n</code></pre>\n<blockquote>\n<p>Note that the compiler will require that methods <code>changeGear</code>, <code>speedUp</code>, and <code>applyBrakes</code> all be <em>implemented</em>. Compilation will fail if those methods are missing from this class.</p>\n</blockquote>\n<p>An interface allows a class to become more formal about its behavior. Interfaces form a sort of contract between the class and the outside world. This contract is enforced at build time by the compiler. If your class claims to implement an interface, all methods defined by that interface must appear in its source code before the class will successfully compile.</p>\n<h2>Different Languages Same Objects</h2>\n<p>Objects can be created in many ways, this mostly depends on the programming language used. In Java, for example,</p>\n<pre><code class=\"language-Java\">//className objectToCreate = new className();\nCar mercedezBenz = new Car();\n</code></pre>\n<p>The <code>new</code> word is a keyword, which means it is reserved in Java for specifically creating objects. Therefore it can not be used as a variable name.</p>\n<p>in JavaScript, creation of an object can be as follows:</p>\n<pre><code class=\"language-JavaScript\">function fnName1(value1,value2){\n    this.value1 = value1;\n    this.value2 = value2;\n    }\n//alternatively\nvar fnName2 = new Object{};\nfnName2.[\"value1\"] = value1;\nfnName2.value2 = value2;\n</code></pre>\n<blockquote>\n<p>The first part is creation of an object using a custom constructor, while the alternative is using an object constructor in which values can be added using either dot notation or bracket notation</p>\n</blockquote>\n<p>To access methods and instance variables, one uses the <strong>dot operator</strong> (.) to access a method or variable that lies in a newly created object.</p>\n<p>It is always good practice to <strong>encapsulate</strong> your class. This protects your code and prevents editing of your variables. Instead these fields of variables should be accessed through <em>getter</em> and <em>setter</em> methods.</p>\n<p>Take the example below:</p>\n<pre><code class=\"language-JavaScript\">class Car{\n    var engine,gasTank,gas,door;\n\n    function driveForward(howFar){}\n    function reverse(howFar){}\n    function stop(){}\n    function openDoor(){}\n\n    //getters and setters\n    function getGas(){\n        return gas;\n    }\n\n    function getGasTank(){\n        return gasTank;\n    }\n\n    function setGas(gas){\n        this.gas = gas;\n    }\n\n    function setGasTank(gasTank){\n        this.gasTank = gasTank;\n    }\n}\n</code></pre>\n<blockquote>\n<p>The above class has getters and setters. The fields <code>engine</code>, <code>gas</code>, <code>gasTank</code> and <code>door</code> can not be accessed outside this class without the getters and setters</p>\n</blockquote>\n<p>To access these fields you need to call the function such as <code>getGasTank()</code> which will return the value of field <code>gasTank</code>. This makes sure that your fields remain secure and can only be edited from inside the class and not outside.</p>\n<h2>Method Overload!</h2>\n<p>It is possible in OOP to create methods that accept any type of variable, such as double, integer,String and return the same intended result. This is known as <em>overloading of methods</em>. It makes it easy to use just one function name that accepts any variable type, but performs the same function. Like taking int two integers, such as 4 and 5 and returning the sum. Now, what if the user enters 4 and 5 as strings? The intended purpose is to still return the same result of 9 regardless of the variable type. This is where method overloading comes in handy.</p>\n<ul>\n<li>First create multiple methods with the same name</li>\n<li>Make sure that each created method has a different return type, number of arguments or type of arguments</li>\n</ul>\n<p>Languages such as <a href=\"www.w3schools.com/js\" title=\"More information on JavaScript\">JavaScript</a> do not allow overloading, because they do not assign variable types to variables when they are created. Languages such as <a href=\"https://en.wikipedia.org/wiki/Java_(programming_language)\" title=\"More info on Java\">Java</a> allow overloading.</p>\n<pre><code class=\"language-Java\">public int addNumbers(int a, int b){\n    return a+b;\n}\n\npublic String addNumbers(String a,String b){\n    int result = Integer.parseInt(a) + Integer.parseInt(b);\n    return String.valueOf(result);\n}\n</code></pre>\n<blockquote>\n<p>The above methods have the same name, but accept different types of arguments. The first one accepts 2 integers and returns their sum. The second one accepts 2 strings, converts them to integers and sums them and returns the string literal of the integer.</p>\n</blockquote>\n<p>The above functions perform the same function, but accept and return different variable types. This is an example of overloading methods.</p>\n<h2>Conclusion</h2>\n<p>There is so much more to OOP, these are just some of the basics. These basics will get you started to creating software that uses and utilizes the power of OOP. It will make writing code that much easier.\nIn conclusion, Objective of Object Oriented Programming si to make creation of software easy and fluid.</p>"}}]}},"pageContext":{"tag":"OOP"}}}