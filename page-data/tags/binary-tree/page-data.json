{"componentChunkName":"component---src-templates-tags-tags-jsx","path":"/tags/binary-tree/","result":{"data":{"allMarkdownRemark":{"totalCount":2,"edges":[{"node":{"frontmatter":{"title":"Binary Trees Heights","subtitle":"Relationship between a binary tree's height and its number of nodes","excerpt":"A binary tree is a tree where every node has two or fewer children. The children are usually called left and right.","path":"/tech/binary-tree-heights","date":"May 17, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":null,"thumbnail":"binary_tree_depth.svg","teaser":"binary_tree_depth.svg","credit":null,"creditlink":null},"tags":["data-structures","binary-tree"]},"excerpt":"A binary tree is a tree where every node has two or fewer children. The children are usually called left and right. This lets us build a…","timeToRead":3,"html":"<p>A binary tree is a tree where every node has two or fewer children. The children are usually called left and right.</p>\n<pre><code class=\"language-python\">class BinaryTreeNode(object):\n\n    def __init__(self, value):\n        self.value = value\n        self.left  = None\n        self.right = None\n</code></pre>\n<p>This lets us build a structure like this:</p>\n<p><img src=\"https://www.interviewcake.com/images/svgs/binary_tree__depth_5.svg?bust=145\"></p>\n<blockquote>\n<p>A tree represented by cirlces connected with lines.</p>\n</blockquote>\n<p>The root node is on top, and connects to 2 children below it. Each of those children connect to 2 children below them, which all connect to their own 2 children, which all connect to their own 2 children.</p>\n<p>That particular example is special because every level of the tree is completely full. There are no \"gaps.\" We call this kind of tree \"perfect.\"</p>\n<p>Binary trees have a few interesting properties when they're perfect:</p>\n<ol>\n<li><strong>Property 1: the number of total nodes on each \"level\" doubles as we move down the tree.</strong></li>\n</ol>\n<p><img src=\"https://www.interviewcake.com/images/svgs/binary_tree__depth_5_with_number_of_nodes_labelled.svg?bust=145\"></p>\n<p>A binary tree with 5 rows of nodes. The root node is on top, and every node has 2 children in the row below. Each row is labelled with the number of nodes in the row, which doubles from the top down: 1, 2, 4, 8, 16.</p>\n<ol start=\"2\">\n<li><strong>Property 2: the number of nodes on the last level is equal to the sum of the number of nodes on all other levels (plus 1).</strong></li>\n</ol>\n<p>In other words, about half of our nodes are on the last level.</p>\n<p>Let's call the number of nodes <strong>n</strong>, and the height of the tree <strong>h</strong>. <strong>h</strong> can also be thought of as the \"number of levels.\"</p>\n<p>If we had <em>h</em>, how could we calculate <em>n</em>?</p>\n<p>Let's just add up the number of nodes on each level! How many nodes are on each level?</p>\n<p>If we zero-index the levels, the number of nodes on the <em>x<sup>th</sup></em> level is exactly 2<sup>x</sup></p>\n<ol>\n<li>Level 0: 2<sup>0</sup> nodes,</li>\n<li>Level 1: 2<sup>1</sup> nodes,</li>\n<li>Level 2: 2<sup>2</sup> nodes,</li>\n<li>Level 3: 2<sup>3</sup> nodes,</li>\n<li>etc</li>\n</ol>\n<p>So our total number of nodes is:</p>\n<p>n = 2<sup>0</sup> + 2<sup>1</sup> + 2<sup>2</sup> + 2<sup>3</sup> + ... + 2<sup>{h-1}</sup></p>\n<blockquote>\n<p>Why only up to 2<sup>{h-1}</sup>? Notice that we started counting our levels at 0. So if we have h levels in total, the last level is actually the \"h-1\"-th level. That means the number of nodes on the last level is 2<sup>{h-1}</sup>.</p>\n</blockquote>\n<p>But we can simplify. <em>Property 2</em> tells us that the number of nodes on the last level is (1 more than) half of the total number of nodes, so we can just take the number of nodes on the last level, multiply it by 2, and subtract 1 to get the number of nodes overall. We know the number of nodes on the last level is 2<sup>h-1</sup>, So:</p>\n<pre>\nn = 2<sup>h-1</sup> * 2 - 1\n\nn = 2<sup>h-1</sup> * 2 - 1\n\nn = 2<sup>h-1</sup> * 2^1 - 1\n\nn = 2<sup>h-1+1</sup>- 1\n\nn = 2<sup>h</sup> - 1\n</pre>\n<p>So that's how we can go from h to n. What about the other direction?</p>\n<p>We need to bring the h down from the exponent. That's what logs are for!</p>\n<p>First, some quick review. log<sub>10</sub>(100) simply means, <strong>What power must you raise 10 to in order to get 100?</strong>. Which is 2, because 10<sup>2</sup> = 100</p>\n<p>We can use logs in algebra to bring variables down from exponents by exploiting the fact that we can simplify log<sub>10</sub>(10<sup>2</sup>)</p>\n<p>What power must we raise 10 to in order to get 10<sup>2</sup>? That's easy—it's 2.</p>\n<p>So in this case we can take the log<sub>2</sub> of both sides:</p>\n<pre>\nn = 2<sup>h</sup> - 1\nn + 1 = 2<sup>h</sup>\nlog<sub>2</sub>((n+1)) = log<sub>2</sub>(2<sup>h</sup>)\nlog<sub>2</sub>(n+1) = h\n</pre>\n<p>So that's the relationship between height and total nodes in a perfect binary tree.</p>"}},{"node":{"frontmatter":{"title":"Perfect Binary Tree","subtitle":"A gentle introduction to perfect binary trees","excerpt":"Binary trees are part of a data structure known as `Trees`, yeah, I know, the forefathers of computer science and software engineering were quite creative. They were quite observant. Trees, more or less, look like trees, like the literal trees in nature. Now, that we have the most basic and almost worst analogy out there, what are binary trees?","path":"/tech/binary-tree","date":"January 26, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"binary_tree.png","thumbnail":"binary_tree.png","teaser":"binary_tree.png","credit":"Quora","creditlink":null},"tags":["algorithms","data-structures","binary-tree"]},"excerpt":"Binary trees are part of a data structure known as Trees, yeah, I know, the forefathers of computer science and software engineering were…","timeToRead":4,"html":"<p>Binary trees are part of a data structure known as <code>Trees</code>, yeah, I know, the forefathers of computer science and software engineering were quite creative. They were quite observant. Trees, more or less, look like trees, like the literal trees in nature. Now, that we have the most basic and almost worst analogy out there, what are binary trees?</p>\n<p>I shall give a basic and brief introduction into <code>binary trees</code>, this will assume that you have knowledge on tree data structures. Even if you don't, you can still read on, they are all pretty much related, so the knowledge is transferable.</p>\n<p>A binary tree is a <code>tree</code> where every node has 2 or fewer children. The children are usually called <code>left</code> and <code>right</code>.\nA simple implementation in <code>Python</code>:</p>\n<pre><code class=\"language-python\">class BinaryTreeNode(object):\n    def __init__(self, value):\n        self.value = value\n         self.left = None\n         self.right = None\n</code></pre>\n<blockquote>\n<p>A class definition for a Binary Tree Node in Python</p>\n</blockquote>\n<p>In JavaScript:</p>\n<pre><code class=\"language-javascript\">function BinaryTreeNode(value) {\n  this.value = value\n  this.left = null\n  this.right = null\n}\n</code></pre>\n<blockquote>\n<p>An object definition in JavaScript</p>\n</blockquote>\n<p>In Java:</p>\n<pre><code class=\"language-java\">public class &#x3C;T> BinaryTreeNode{\n    public T value;\n    public BinaryTreeNode left;\n    public BinaryTreeNode right;\n\n    public BinaryTreeNode(T value){\n        this.value = value;\n    }\n}\n</code></pre>\n<blockquote>\n<p>Binary Tree node implementation of Binary Tree node in Java, this uses T to define objects.</p>\n</blockquote>\n<p>And finally in Ruby:</p>\n<pre><code class=\"language-ruby\">class BinaryTreeNode\n\n    attr_accessor :value, :left, :right\n\n    def initialize(value)\n        @value = value\n        @left  = nil\n        @right = nil\n    end\nend\n</code></pre>\n<p>Why these languages? Well, because I am familiar with them and also to show that it does not matter the language, the implementation of a data structure is usually the same.</p>\n<p><img src=\"https://www.interviewcake.com/images/svgs/binary_tree__depth_5.svg?bust=138\" alt=\"binary tree\"></p>\n<blockquote>\n<p>Binary tree data structure, you will notice, it pretty much looks like a tree.</p>\n</blockquote>\n<p>This particular example is special because every level of the tree is completely full. There are no \"gaps.\" We call this kind of tree \"perfect.\"</p>\n<p>Binary trees have a few interesting properties when they're perfect:</p>\n<ol>\n<li>The number of total nodes on <em>each</em> doubles as we move down the tree\n<img src=\"https://www.interviewcake.com/images/svgs/binary_tree__depth_5_with_number_of_nodes_labelled.svg?bust=138\" alt=\"perfectBinaryTree\"></li>\n<li>\n<p>The number of nodes on the last level is equal to the sum of all the nodes on other levels(plus 1)\nLet's call the number of nodes <code>n</code>, and the height of the tree <code>h</code>. <code>h</code> can also be thought of as the <em>number of levels</em>. If we had <code>h</code>, how could we calculate <code>n</code>?\nLet's just add up the number of nodes on each level! How many nodes are on each level?\nIf we zero-index the levels, the number of nodes on the <code>x</code>th level is exactly <code>2^x</code>!</p>\n<ul>\n<li>Level 0: 2^0 nodes</li>\n<li>Level 1: 2^1 nodes,</li>\n<li>Level 2: 2^2 nodes,</li>\n<li>Level 3: 2^3 nodes,</li>\n<li>etc</li>\n</ul>\n<p>So our total number of nodes is:\n$$n= 2^0 + 2^1 +2^2 +2^3 +...+2^{h−1}$$ > Why only up to 2^{h-1} ? Notice that we started counting our levels at 0. So if > we have h levels in total, the last level is actually the \"h−1\"-th level. > That means the number of nodes on the last level is 2^{h-1}.</p>\n<p>But we can simplify. Property 2 tells us that the number of nodes on the last level is (1 more than) half of the total number of nodes, so we can just take the number of nodes on the last level, multiply it by 2, and subtract 1 to get the number of nodes overall.\nWe know the number of nodes on the last level is 2^{h-1}, So:</p>\n<p>$$ n = 2^{h-1} * 2 - 1$$\n$$n = 2^{h−1}∗2^{1}−1$$\n$$n = 2^{h-1+1}- 1$$\n$$n = 2^{h} - 1$$</p>\n<p>So that's how we can go from <code>h</code> to <code>n</code>. What about the other direction?</p>\n<p>We need to bring the <code>h</code> down from the exponent. That's what logs are for!</p>\n<p>First, some quick review on Algebra. $$log<em>{10}(100)$$ simply means, \"What power must you raise 10 to in order to get 100?\". Which is 2, because $$10^2 = 100$$.\nWe can use logs in algebra to bring variables down from exponents by exploiting the fact that we can simplify $$log</em>{10}(10^2)$$. What power must we raise 10 to in order to get $$10^2$$?\nThat's easy — it's 2.</p>\n<p>So in this case we can take the $$log_{2}$$ of both sides:</p>\n<p>$$n = 2^{h} - 1$$\n$$n + 1 = 2^{h}$$\n$$log<em>{2}{((n+1))} = log</em>{2}{(2^{h})}$$\n$$log_{2}{(n+1)} = h$$</p>\n</li>\n</ol>\n<h3>Conclusion</h3>\n<p>So that's the relationship between height and total nodes in a perfect binary tree.\nI know it involved a bit of Math, which you did not want nor expect, however, this will make the programs you write faster and better and of course easier to maintain and debug.</p>\n<p>Let us plant more trees!</p>"}}]}},"pageContext":{"tag":"binary-tree"}}}