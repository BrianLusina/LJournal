{"componentChunkName":"component---src-templates-tags-tags-jsx","path":"/tags/memoize/","result":{"data":{"allMarkdownRemark":{"totalCount":1,"edges":[{"node":{"frontmatter":{"title":"Concept of Memoize","subtitle":"A gentle introduction to memoize","excerpt":"Memoization ensures that a function doesn't run for the same inputs more than once by keeping a record of the results for given inputs (usually in a dictionary).","path":"/tech/memoize-python","date":"May 17, 2017","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":null,"thumbnail":"memoize.png","teaser":"memoize.png","credit":null,"creditlink":null},"tags":["data-structures","python","algorithms","memoize"]},"excerpt":"Memoization ensures that a function doesn't run for the same inputs more than once by keeping a record of the results for given inputsâ€¦","timeToRead":2,"html":"<p>Memoization ensures that a function doesn't run for the same inputs more than once by keeping a record of the results for given inputs (usually in a dictionary).</p>\n<p>For example, a simple recursive function for computing the n<sup>th</sup> fibonacci number:</p>\n<pre><code class=\"language-python\">def fib_recursive(n):\n    if n &#x3C; 0:\n        raise IndexError('Index was negative. No such thing as a negative index in a series.')\n\n    # base cases\n    if n in [0, 1]:\n        return n\n\n    print \"computing fib_recursive(%i)\" % n\n    return fib_recursive(n - 1) + fib_recursive(n - 2)\n</code></pre>\n<p>This will run the same input a couple of times</p>\n<pre><code class=\"language-bash\">>>> fib_recursive(8)\ncomputing fib_recursive(8)\ncomputing fib_recursive(7)\ncomputing fib_recursive(6)\ncomputing fib_recursive(5)\ncomputing fib_recursive(4)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(2)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(4)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(2)\ncomputing fib_recursive(5)\ncomputing fib_recursive(4)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(2)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(6)\ncomputing fib_recursive(5)\ncomputing fib_recursive(4)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(2)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(4)\ncomputing fib_recursive(3)\ncomputing fib_recursive(2)\ncomputing fib_recursive(2)\n21\n</code></pre>\n<p>We can imagine the recursive calls of this function as a tree, where the two children of a node are the two recursive calls it makes. We can see that the tree quickly branches out of control:</p>\n<p><img src=\"https://www.interviewcake.com/images/svgs/fibonacci__binary_tree_recursive.svg?bust=145\"></p>\n<p>To avoid the duplicate work caused by the branching, we can wrap the function in a class that stores an instance variable, memo, that maps inputs to outputs. Then we simply:</p>\n<ol>\n<li>Check memo to see if we can avoid computing the answer for any given input, and</li>\n<li>Save the results of any calculations to memo.</li>\n</ol>\n<pre><code class=\"language-python\">class Fibber:\n    def __init__(self):\n        self.memo = {}\n\n    def fib(self, n):\n\n        if n &#x3C; 0:\n            raise Exception(\"Index was negative. No such thing as a negative index in a series.\")\n\n        # base cases\n        elif n in [0, 1]:\n            return n\n\n        # see if we've already calculated this\n        if n in self.memo:\n            print \"grabbing memo[%i]\" % n\n            return self.memo[n]\n\n        print \"computing fib(%i)\" % n\n        result = self.fib(n - 1) + self.fib(n - 2)\n\n        # memoize\n        self.memo[n] = result\n\n        return result\n</code></pre>\n<p>We save a bunch of calls by checking the memo:</p>\n<pre><code class=\"language-python\">>>> Fibber().fib(8)\ncomputing fib(8)\ncomputing fib(7)\ncomputing fib(6)\ncomputing fib(5)\ncomputing fib(4)\ncomputing fib(3)\ncomputing fib(2)\ngrabbing memo[2]\ngrabbing memo[3]\ngrabbing memo[4]\ngrabbing memo[5]\ngrabbing memo[6]\n21\n</code></pre>\n<p>Now in our recurrence tree, no node appears more than twice:</p>\n<p><img src=\"https://www.interviewcake.com/images/svgs/fibonacci__binary_tree_memoized.svg?bust=145\"></p>\n<p>Memoization is a common strategy for dynamic programming problems, which are problems where the solution is composed of solutions to the same problem with smaller inputs (as with the fibonacci problem, above). The other common strategy for dynamic programming problems is going bottom-up, which is usually cleaner and often more efficient.</p>"}}]}},"pageContext":{"tag":"memoize"}}}