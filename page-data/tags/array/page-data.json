{"componentChunkName":"component---src-templates-tags-tags-jsx","path":"/tags/array/","result":{"data":{"allMarkdownRemark":{"totalCount":1,"edges":[{"node":{"frontmatter":{"title":"Sorting Algorithms","subtitle":"Brief overview of some sorting algorithms","excerpt":"Algorithms are set to achieve a certain outcome. Sorting algoritms follow numerical order and usually has random access to an array. This means that it can access random indexes of an array to perform a sort.","path":"/tech/sorting-algorithms","date":"July 12, 2016","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"sorting-algorithms.png","thumbnail":"sorting-algorithms.png","teaser":"sorting-algorithms.png","credit":null,"creditlink":null},"tags":["algorithms","sorting algorithms","array"]},"excerpt":"Algorithms are set to achieve a certain outcome. Sorting algoritms follow numerical order and usually has random access to an array. Thisâ€¦","timeToRead":2,"html":"<p>Algorithms are set to achieve a certain outcome. Sorting algoritms follow numerical order and usually has random access to an array. This means that it can access random indexes of an array to perform a sort.</p>\n<h1>Bubble Sort</h1>\n<p>Convinient for small data sets. Consider an array of elements such that:\nint[] arr = new int[]{14,33,27,10,33,19,42,44};\nThe array is not sorted. To sort this array, we compare 2 values at a time.\nSteps:</p>\n<ul>\n<li>compare 14 and 33, since 14 is less than 33, it remains in place</li>\n<li>next we compare 33 and 27, 27 is less than 33, hence we have to swap postions such that;\n<code>arr[1]</code> = 33 takes the place of <code>arr[2]</code> and vice versa.\nThe array now becomes:\n{14,27,33,10,33,19,48,44}</li>\n<li>The next comparison is now between 33 and 10. 10 is less than 33, so we swap positions as before.</li>\n<li>The process continues until all the elements in the array follow natural ordering.</li>\n</ul>\n<p>This is obviously convenient for small data sets as we are comparing 2 elements at a time. If the array was of length 50, it would take much longer to complete and would be inefficient. This is not what an ideal algorithm should achieve.</p>\n<pre><code class=\"language-java\">    /**\n     * @implNote\n     * set flag to true to begin first pass, initialize the step variable, create the temp variable\n     * within while loop, set the flag to false awaiting first pass\n     * record the steps taken in a variable called steps\n     * holds the temp value for the current element in array\n     * assign the current position of the array to the next element\n     * assign the next position of the array to the temp value\n     * set the flag to true to allow continuing of loop, record the steps taken\n     * @param toSort array to perform the bubble sort\n     * @return toSort the sorted array\n     * */\n    public static int[] bubbly(int[] toSort){\n        boolean flag = true;\n        int steps = 0;\n        int temp;\n        while(flag){\n            flag = false;\n            for(int x = 0; x &#x3C; toSort.length-1;x++){\n                if(toSort[x] > toSort[x+1]){\n                    steps++;\n                    temp = toSort[x];\n                    toSort[x] = toSort[x+1];\n                    toSort[x+1] = temp;\n                    flag = true;\n                }\n\n            }\n        }\n        System.out.println(String.valueOf(steps)+ \" steps taken\");\n        return toSort;\n    }\n\n    public static void main(String[] args){\n        int[] arr = new int[]{18,29,1,100,17};\n        int[] arrTwo = new int[]{100,16,33,48,60,21,80};\n        /*Bubble sort Ascending*/\n        System.out.println(Arrays.toString(bubbly(arr)));\n        System.out.println(Arrays.toString(bubbly(arrTwo)));\n        /*5 steps taken\n        [1, 17, 18, 29, 100]\n        9 steps taken\n        [16, 21, 33, 48, 60, 80, 100]*/\n    }\n</code></pre>\n<blockquote>\n<p>Demonstration of a bubble sort algorithm, sorting elements in ascending order</p>\n</blockquote>\n<p>Code snippet right <a href=\"https://github.com/BrianLusina/Java-Playground/blob/master/Toy%20Problems/src/SortingAlgorithms/BubbleSortDemo.java\">here</a>.</p>\n<h1>Merge Sort</h1>\n<p>Uses the <em>divide and conquer rule</em> it divides a problem into smaller parts until it reaches the simplest form possible. Then it rejoins the divided elements in a sorted format until it is a full list again. This sorting algorithm is mostly used in arrays.</p>\n<p>Consider this example\n27 10 12 25 34 16 15 31\ndivide it into two parts\n27 10 12 25 34 16 15 31\ndivide each part into two parts\n27 10 12 25 34 16 15 31\ndivide each part into two parts\n27 10 12 25 34 16 15 31</p>\n<p>merge (cleverly-!) parts</p>\n<p>10 27 12 25 16 34 15 31\nmerge parts\n10 12 25 27 15 16 31 34\nmerge parts into one\n10 12 15 16 25 27 31 34</p>\n<h1>Insertion Sort</h1>"}}]}},"pageContext":{"tag":"array"}}}