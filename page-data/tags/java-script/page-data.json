{"componentChunkName":"component---src-templates-tags-tags-jsx","path":"/tags/java-script/","result":{"data":{"allMarkdownRemark":{"totalCount":1,"edges":[{"node":{"frontmatter":{"title":"Object Immutability In JavaScript","subtitle":"Creating object immutability in JavaScript","excerpt":"Creating object immutability in JavaScript has its advantages when it comes to programming, it ensures that objects retain their properties and has no unexpected side-effects. How to we create this immutability in JavaScript?","path":"/tech/object-immutability-js","date":"September 18, 2018","author":{"name":"Brian Lusina","link":"/brian_lusina","avatar":"brian_lusina.jpg"},"image":{"feature":"object-freeze.png","thumbnail":"object-freeze.png","teaser":"object-freeze.png","credit":null,"creditlink":null},"tags":["JavaScript","Objects"]},"excerpt":"What is immutabilty? I see this word being thrown around a lot, especially in the software industry, where other phrases such as clean codeâ€¦","timeToRead":5,"html":"<p>What is immutabilty? I see this word being thrown around a lot, especially in the software industry, where other phrases such as <strong>clean code</strong> and <strong>code quality</strong> are constantly being emphasized. What is it? Why is it necessary to understand what it is and how to use it?</p>\n<p>In this post, I shall write briefly about what it is and how to use it. This will not use any JS framework, but will be pure JavaScript. This is because this is applicable in any JavaScript context(read framework). Frameworks and libraries come with their own rules of immutability. How do they creat these rules arround immutability?</p>\n<blockquote>\n<p>Immutability means <em>not capable or susceptible to change</em></p>\n</blockquote>\n<p>In other words, not capable of change. In object oriented programming and functional programming, this means that an immutable object is an <em>object whose state cannot be modified after it is created</em>. Objects in general have state and behaviour. When an object is immutable, the state and behaviour can not change.</p>\n<p>This has several benefits. First of all ensures this ensures that there are no intended side-effects and we know exactly what an object's state and behaviour is at any given time within the application's lifecycle. It makes us more confident when writing our code, as we know exactly what to expect from an immutable object.</p>\n<p>Of course, this also means that it's state can not be modified and can also be an issue in the case where we do need to alter it's current state. This is why we create a copy of the object and alter the state of the copy instead of the original object(A pattern that is used in <a href=\"http://redux.js.org\">Redux</a>).</p>\n<p>Before delving into that, let us see how to create object immutability in plain ol' JavaScript:</p>\n<pre><code class=\"language-javascript\">let johnDoe = {\n    firstName: \"John\",\n    lastName: \"Doe\",\n    email: \"johndoe@email.com\",\n    age: 50\n}\n\nconst frozenJohnDoe = Object.freeze(johnDoe);\n\nfrozenJohnDoe.age = 33;\n// Throws an error in strict mode\n\nfrozenJohnDoe.age;\n// expected output: 50\n</code></pre>\n<blockquote>\n<p>An example of immutabililty in JavaScript</p>\n</blockquote>\n<p>Above, we have a <code>johnDoe</code> object with some properties (<code>firstName</code>, <code>lastName</code>, <code>email</code> and <code>age</code>). These properties at time of create are mutable(can be changed). To make this object immutable, we use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\">Object.freeze</a>. A very handy function that <em>freezes</em> the object. Therefore, we can not alter any of its properties on the following lines.</p>\n<p>This means nothing can be added or removed from the frozen object. Our <code>johnDoe</code> object is now frozen and can never be able to alter his age, sorry John :(. This gives us a sense of what to always expect when we use the frozen object. We can always be guaranteed that his age will be 50 when we use it.</p>\n<p>It is important to note that when not running in <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode\">strict mode</a>, it will appear as if mutation of the object's properties can be done. Here is an example:</p>\n<pre><code class=\"language-javascript\">// still using our johnDoe object above\n> johnDoe.age = 5\n5\n> johnDoe\n{ firstName: 'John',\n  lastName: 'Doe',\n  email: 'johndoe@email.com',\n  age: 50 }\n</code></pre>\n<blockquote>\n<p>While running in a Node REPL</p>\n</blockquote>\n<p>While trying to set the age of the object to 5, no error is thrown and thus it will appear as if a successful mutation actually occured, but in reality, the properties remain the same, age has not been altered.</p>\n<p>Data properties of frozen objects can not be changed, configurable attributes are set to false. This is what sets the immutability of the object. There is a problem though. What if my object's properties' values were other objects? Are those immutable to? An example:</p>\n<pre><code class=\"language-javascript\">> let shoppingCart = {\n    fruits: {\n        banana: \"banana\",\n        apple: \"apple\",\n        oranges: \"oranges\"\n    },\n    bread: {\n        brown: \"brown bread\",\n        white: \"white bread\"\n    }\n    price: 50\n}\n// freeze our object, we do not need to save a copy of it. As the function returns our initial object and NOT a fronzen copy\n> Object.freeze(shoppingCart)\n\n// fruits remains as is\n> shoppingCart.fruits\n{\n    banana: \"banana\",\n    apple: \"apple\",\n    oranges: \"oranges\"\n}\n// attempt to mutate the fruits object's properties\n> shoppingCart.fruits.banana = \"very ripe banana\"\n'very ripe banana'\n\n> shoppingCart.fruits\n{\n    banana: \"very ripe banana\",\n    apple: \"apple\",\n    oranges: \"oranges\"\n}\n</code></pre>\n<blockquote>\n<p>Again, running in a Node REPL</p>\n</blockquote>\n<p>As, you can see from above, the <code>fruits</code> object's values can be mutated, yet it is in a frozen object <code>shoppingCart</code>. This is known as <strong>shallow freeze</strong>. This means that the immediate properties of <code>shoppingCart</code> have been made immutable, however, if the values of said properties are objects, they are not frozen.</p>\n<p>For the fruits object to also have the same level of immutability, they have to also be frozen:</p>\n<pre><code class=\"language-javascript\">> let fruits = {\n    banana: \"banana\",\n    apple: \"apple\",\n    oranges: \"oranges\"\n};\n> Object.freeze(fruits);\n\n> let bread = {\n    brown: \"brown bread\",\n    white: \"white bread\"\n}\n> Object.freeze(bread);\n\n> let shoppingCart = {\n    fruits,\n    bread,\n    price: 50\n};\n\n// freeze our object, we do not need to save a copy of it\n> Object.freeze(shoppingCart)\n\n// fruits remains as is\n> shoppingCart.fruits\n{\n    banana: \"banana\",\n    apple: \"apple\",\n    oranges: \"oranges\"\n}\n// attempt to mutate the fruits object's properties\n> shoppingCart.fruits.banana = \"very ripe banana\"\n'very ripe banana'\n\n> shoppingCart.fruits\n{\n    banana: \"banana\",\n    apple: \"apple\",\n    oranges: \"oranges\"\n}\n</code></pre>\n<blockquote>\n<p>Now we have immutability for our fruits :)</p>\n</blockquote>\n<p>Of course, this can be a pain when dealing with objects that have properties that have other objects and those objects have properties that have other objects and so forth. Creating a recursive function that freezes all properties of the object that are objects themselves will save us the time and ensure that we attain <strong>deep freeze</strong> on our object.</p>\n<p>We have to ensure that the recurstion does not end up in a cycle though.</p>\n<pre><code class=\"language-javascript\">const deepFreeze = object => {\n    // get the property names\n    let propNames = Object.getOwnPropertyNames(object);\n\n    // freeze properties before freezing self\n    for(let name of propNames){\n        let value = object[name]\n\n        object[name] = value &#x26;&#x26; typeof value === \"object\" ?\n            deepFreeze(value) : value\n    }\n\n    // freeze self\n    return Object.freeze(object);\n}\n</code></pre>\n<blockquote>\n<p>This function will recursively freeze all properties of an object that are objects.</p>\n</blockquote>\n<p>We can now use this function as below:</p>\n<pre><code class=\"language-javascript\">var collection = {\n    internal: {\n        a: null\n    }\n};\n\ndeepFreeze(collection);\n\n// fails silently in non-strict mode\ncollection.internal.a = 'anotherValue';\ncollection.internal.a; // null\n</code></pre>\n<p>You can check whether out objects are frozen with <code>Object.isFrozen</code>, this takes in an object and checks whether the configurable properties have been set to false and returns a boolean value (true, if the object is frozen, false otherwise).</p>\n<p><strong>Object.freeze</strong> also works on arrays:</p>\n<pre><code class=\"language-javascript\">let a = [0];\nObject.freeze(a); // The array cannot be modified now.\n\na[0]=1; // fails silently\na.push(2); // fails silently\n\n// In strict mode such attempts will throw TypeErrors\nfunction fail() {\n  \"use strict\"\n  a[0] = 1;\n  a.push(2);\n}\n\nfail();\n</code></pre>\n<h2>The End</h2>\n<p>Next time you are writing a Javascript module and you are exposing objects that other developers may use, make sure that they have the exact needed permissions to alter your objects, otherwise they may broke your code without even realising it. Make sure also to document it.</p>"}}]}},"pageContext":{"tag":"JavaScript"}}}